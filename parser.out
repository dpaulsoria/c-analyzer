Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AUTO
    BACKSLASH
    BACKSPACE
    B_AND
    B_COMPLEMENT
    B_OR
    B_XOR
    CHAR
    CHARACTER
    CONST
    DO
    DOT
    DOUBLE_APOS
    DOUBLE_QUOTE
    ENUM
    EXTERN
    FF_PAGEBREAK
    FS_CHAR
    FS_DOUBLE
    FS_FLOAT
    FS_HEX
    FS_INT
    FS_LONG
    FS_LONG_DOUBLE
    FS_OCT
    FS_OCT_LONG
    FS_POINTER
    FS_SCI_NOTATION
    FS_STRING
    FS_UNSIGNED_INT
    FS_UNSIGNED_LONG
    GOTO
    HTAB
    IGNORE
    LBRACKET
    NEWLINE
    NULL
    PP_DATE
    PP_DTMACRO
    PP_ERROR
    PP_FILE
    PP_IF
    PP_IFDEF
    PP_IFNDEF
    PP_LINE
    PP_PRAGMA
    PP_STMACRO
    PP_TIME
    PP_TIMESTAMP
    PP_UNDEF
    QUESTIONMARK
    RBRACKET
    REGISTER
    RETURN
    SHIFT_LEFT
    SHIFT_RIGHT
    SIGNED
    SINGLE_APOS
    SINGLE_QUOTE
    SIZEOF
    STATIC
    STRUCT
    TILDE
    TYPEDEF
    UNION
    UNSIGNED
    VOID
    VOLTILE
    VTAB

Grammar

Rule 0     S' -> ROOT
Rule 1     ROOT -> PREPROCESOR_DIRECTIVE
Rule 2     ROOT -> DEFINE
Rule 3     ROOT -> INCLUDE
Rule 4     ROOT -> VALUE
Rule 5     ROOT -> NUMBER
Rule 6     ROOT -> CONTROL_STRUCTURES
Rule 7     ROOT -> WHILE_STRUCTURE
Rule 8     ROOT -> SWITCH_STRUCTURE
Rule 9     ROOT -> IF_STRUCTURE
Rule 10    ROOT -> FOR_STRUCTURE
Rule 11    ROOT -> CODE
Rule 12    ROOT -> EXPRESSION
Rule 13    ROOT -> EXPRESSIONS
Rule 14    ROOT -> FUNCTION
Rule 15    ROOT -> INTEGER_TYPE
Rule 16    ROOT -> DECIMAL_TYPE
Rule 17    ROOT -> INTEGER_DECLARATION
Rule 18    ROOT -> DECIMAL_DECLARATION
Rule 19    ROOT -> ASSIGNMENT_DECLARATION
Rule 20    ROOT -> ASSIGNMENT_OPERATOR
Rule 21    ROOT -> COMENTARIOLEX
Rule 22    ROOT -> VARIABLELEX
Rule 23    ROOT -> OPERATOR
Rule 24    ROOT -> OPERATION
Rule 25    ROOT -> OPERATIONS
Rule 26    ROOT -> COMPARISON_OPERATOR
Rule 27    ROOT -> COMPARISON
Rule 28    ROOT -> COMPARISONS
Rule 29    ROOT -> LOGICAL_OPERATOR
Rule 30    ROOT -> SENTENCE
Rule 31    ROOT -> SWITCH_BODY
Rule 32    ROOT -> BUCLE
Rule 33    ROOT -> ELSE_STRUCTURE
Rule 34    ROOT -> FUNCTION_ARGUMENTS
Rule 35    ROOT -> DECLARATIONS
Rule 36    PREPROCESOR_DIRECTIVE -> DEFINE
Rule 37    PREPROCESOR_DIRECTIVE -> INCLUDE
Rule 38    DEFINE -> PP_DEFINE VARIABLELEX VALUE
Rule 39    INCLUDE -> PP_INCLUDE HEADER_LIB
Rule 40    VALUE -> NUMBER
Rule 41    VALUE -> STRING
Rule 42    NUMBER -> INTEGER
Rule 43    NUMBER -> DECIMAL
Rule 44    CONTROL_STRUCTURES -> IF_STRUCTURE
Rule 45    CONTROL_STRUCTURES -> FOR_STRUCTURE
Rule 46    CONTROL_STRUCTURES -> WHILE_STRUCTURE
Rule 47    CONTROL_STRUCTURES -> SWITCH_STRUCTURE
Rule 48    BODY_STRUCTURE -> EXPRESSIONS
Rule 49    BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON
Rule 50    BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON
Rule 51    WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
Rule 52    SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
Rule 53    SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON
Rule 54    SWITCH_BODY -> SWITCH_CASE
Rule 55    SWITCH_BODY -> SWITCH_DEFAULT
Rule 56    SWITCH_BODY -> SWITCH_CASE SWITCH_BODY
Rule 57    SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
Rule 58    BUCLE -> VARIABLELEX INCREASE
Rule 59    BUCLE -> DECREASE VARIABLELEX
Rule 60    FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
Rule 61    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 62    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
Rule 63    ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 64    ELSE_STRUCTURE -> ELSE IF_STRUCTURE
Rule 65    DECLARATIONS -> INTEGER_DECLARATION
Rule 66    DECLARATIONS -> DECIMAL_DECLARATION
Rule 67    CODE -> FUNCTION
Rule 68    CODE -> INTEGER_DECLARATION
Rule 69    CODE -> DECIMAL_DECLARATION
Rule 70    CODE -> ASSIGNMENT_DECLARATION
Rule 71    CODE -> COMENTARIOLEX
Rule 72    EXPRESSION -> CODE SEMICOLON
Rule 73    EXPRESSION -> CONTROL_STRUCTURES
Rule 74    EXPRESSIONS -> EXPRESSION
Rule 75    EXPRESSIONS -> EXPRESSION EXPRESSIONS
Rule 76    FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
Rule 77    FUNCTION_ARGUMENTS -> SENTENCES
Rule 78    FUNCTION_ARGUMENTS -> COMPARISONS
Rule 79    INTEGER_TYPE -> INT
Rule 80    INTEGER_TYPE -> SHORT
Rule 81    INTEGER_TYPE -> LONG
Rule 82    DECIMAL_TYPE -> FLOAT
Rule 83    DECIMAL_TYPE -> DOUBLE
Rule 84    INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER
Rule 85    DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL
Rule 86    ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE
Rule 87    ASSIGNMENT_OPERATOR -> EQUAL
Rule 88    ASSIGNMENT_OPERATOR -> PLUS_EQUAL
Rule 89    ASSIGNMENT_OPERATOR -> MINUS_EQUAL
Rule 90    ASSIGNMENT_OPERATOR -> DIV_EQUAL
Rule 91    ASSIGNMENT_OPERATOR -> TIMES_EQUAL
Rule 92    ASSIGNMENT_OPERATOR -> MOD_EQUAL
Rule 93    ASSIGNMENT_OPERATOR -> AND_EQUAL
Rule 94    ASSIGNMENT_OPERATOR -> OR_EQUAL
Rule 95    ASSIGNMENT_OPERATOR -> XOR_EQUAL
Rule 96    ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL
Rule 97    ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL
Rule 98    ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL
Rule 99    COMENTARIOLEX -> COMMENT
Rule 100   VARIABLELEX -> VARNAME
Rule 101   OPERATOR -> PLUS
Rule 102   OPERATOR -> MINUS
Rule 103   OPERATOR -> TIMES
Rule 104   OPERATOR -> MODULUS
Rule 105   OPERATOR -> DIVIDE
Rule 106   OPERATION -> NUMBER OPERATOR NUMBER
Rule 107   OPERATIONS -> OPERATION
Rule 108   OPERATIONS -> OPERATION OPERATOR OPERATIONS
Rule 109   COMPARISON_OPERATOR -> EQUAL_TO
Rule 110   COMPARISON_OPERATOR -> NOT_EQUAL
Rule 111   COMPARISON_OPERATOR -> GREATER_THAN
Rule 112   COMPARISON_OPERATOR -> LESS_THAN
Rule 113   COMPARISON_OPERATOR -> GREATER_EQUAL
Rule 114   COMPARISON_OPERATOR -> LESS_EQUAL
Rule 115   COMPARISON -> VALUE COMPARISON_OPERATOR VALUE
Rule 116   COMPARISON -> SENTENCE COMPARISON_OPERATOR SENTENCE
Rule 117   COMPARISONS -> COMPARISON
Rule 118   COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS
Rule 119   LOGICAL_OPERATOR -> AND
Rule 120   LOGICAL_OPERATOR -> OR
Rule 121   LOGICAL_OPERATOR -> NOT
Rule 122   SENTENCE -> NUMBER
Rule 123   SENTENCE -> VARNAME
Rule 124   SENTENCES -> SENTENCE
Rule 125   SENTENCES -> SENTENCE COMMA SENTENCES

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 119
AND_EQUAL            : 93
AUTO                 : 
BACKSLASH            : 
BACKSPACE            : 
BREAK                : 49 52 53
B_AND                : 
B_COMPLEMENT         : 
B_OR                 : 
B_XOR                : 
CASE                 : 52
CHAR                 : 
CHARACTER            : 
COLON                : 52 53
COMMA                : 125
COMMENT              : 99
COMPLEMENT_EQUAL     : 96
CONST                : 
CONTINUE             : 50
DECIMAL              : 43 85
DECREASE             : 59
DEFAULT              : 53
DIVIDE               : 105
DIV_EQUAL            : 90
DO                   : 
DOT                  : 
DOUBLE               : 83
DOUBLE_APOS          : 
DOUBLE_QUOTE         : 
ELSE                 : 63 64
ENUM                 : 
EQUAL                : 84 85 87
EQUAL_TO             : 109
EXTERN               : 
FF_PAGEBREAK         : 
FLOAT                : 82
FOR                  : 60
FS_CHAR              : 
FS_DOUBLE            : 
FS_FLOAT             : 
FS_HEX               : 
FS_INT               : 
FS_LONG              : 
FS_LONG_DOUBLE       : 
FS_OCT               : 
FS_OCT_LONG          : 
FS_POINTER           : 
FS_SCI_NOTATION      : 
FS_STRING            : 
FS_UNSIGNED_INT      : 
FS_UNSIGNED_LONG     : 
GOTO                 : 
GREATER_EQUAL        : 113
GREATER_THAN         : 111
HEADER_LIB           : 39
HTAB                 : 
IF                   : 61 62
IGNORE               : 
INCREASE             : 58
INT                  : 79
INTEGER              : 42 52 84
LBRACKET             : 
LCURL_BRACE          : 51 57 61 62 63
LESS_EQUAL           : 114
LESS_THAN            : 112
LONG                 : 81
LPAREN               : 51 57 60 61 62 76
MINUS                : 102
MINUS_EQUAL          : 89
MODULUS              : 104
MOD_EQUAL            : 92
NEWLINE              : 
NOT                  : 121
NOT_EQUAL            : 110
NULL                 : 
OR                   : 120
OR_EQUAL             : 94
PLUS                 : 101
PLUS_EQUAL           : 88
PP_DATE              : 
PP_DEFINE            : 38
PP_DTMACRO           : 
PP_ERROR             : 
PP_FILE              : 
PP_IF                : 
PP_IFDEF             : 
PP_IFNDEF            : 
PP_INCLUDE           : 39
PP_LINE              : 
PP_PRAGMA            : 
PP_STMACRO           : 
PP_TIME              : 
PP_TIMESTAMP         : 
PP_UNDEF             : 
QUESTIONMARK         : 
RBRACKET             : 
RCURL_BRACE          : 51 57 61 62 63
REGISTER             : 
RETURN               : 
RPAREN               : 51 57 60 61 62 76
SEMICOLON            : 49 50 52 53 60 60 72
SHIFTL_EQUAL         : 97
SHIFTR_EQUAL         : 98
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
SHORT                : 80
SIGNED               : 
SINGLE_APOS          : 
SINGLE_QUOTE         : 
SIZEOF               : 
STATIC               : 
STRING               : 41
STRUCT               : 
SWITCH               : 57
TILDE                : 
TIMES                : 103
TIMES_EQUAL          : 91
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VARNAME              : 76 84 85 86 100 123
VOID                 : 
VOLTILE              : 
VTAB                 : 
WHILE                : 51
XOR_EQUAL            : 95
error                : 

Nonterminals, with rules where they appear

ASSIGNMENT_DECLARATION : 19 70
ASSIGNMENT_OPERATOR  : 20 86
BODY_STRUCTURE       : 51
BUCLE                : 32 60
CODE                 : 11 72
COMENTARIOLEX        : 21 71
COMPARISON           : 27 117 118
COMPARISONS          : 28 51 57 60 61 62 78 118
COMPARISON_OPERATOR  : 26 115 116
CONTROL_STRUCTURES   : 6 73
DECIMAL_DECLARATION  : 18 66 69
DECIMAL_TYPE         : 16 85
DECLARATIONS         : 35 60
DEFINE               : 2 36
ELSE_STRUCTURE       : 33 62
EXPRESSION           : 12 74 75
EXPRESSIONS          : 13 48 49 50 52 53 61 62 63 75
FOR_STRUCTURE        : 10 45
FUNCTION             : 14 67
FUNCTION_ARGUMENTS   : 34 76
IF_STRUCTURE         : 9 44 64
INCLUDE              : 3 37
INTEGER_DECLARATION  : 17 65 68
INTEGER_TYPE         : 15 84
LOGICAL_OPERATOR     : 29 118
NUMBER               : 5 40 106 106 122
OPERATION            : 24 107 108
OPERATIONS           : 25 108
OPERATOR             : 23 106 108
PREPROCESOR_DIRECTIVE : 1
ROOT                 : 0
SENTENCE             : 30 86 116 116 124 125
SENTENCES            : 77 125
SWITCH_BODY          : 31 56 57
SWITCH_CASE          : 54 56
SWITCH_DEFAULT       : 55
SWITCH_STRUCTURE     : 8 47
VALUE                : 4 38 115 115
VARIABLELEX          : 22 38 58 59
WHILE_STRUCTURE      : 7 46

Parsing method: LALR

state 0

    (0) S' -> . ROOT
    (1) ROOT -> . PREPROCESOR_DIRECTIVE
    (2) ROOT -> . DEFINE
    (3) ROOT -> . INCLUDE
    (4) ROOT -> . VALUE
    (5) ROOT -> . NUMBER
    (6) ROOT -> . CONTROL_STRUCTURES
    (7) ROOT -> . WHILE_STRUCTURE
    (8) ROOT -> . SWITCH_STRUCTURE
    (9) ROOT -> . IF_STRUCTURE
    (10) ROOT -> . FOR_STRUCTURE
    (11) ROOT -> . CODE
    (12) ROOT -> . EXPRESSION
    (13) ROOT -> . EXPRESSIONS
    (14) ROOT -> . FUNCTION
    (15) ROOT -> . INTEGER_TYPE
    (16) ROOT -> . DECIMAL_TYPE
    (17) ROOT -> . INTEGER_DECLARATION
    (18) ROOT -> . DECIMAL_DECLARATION
    (19) ROOT -> . ASSIGNMENT_DECLARATION
    (20) ROOT -> . ASSIGNMENT_OPERATOR
    (21) ROOT -> . COMENTARIOLEX
    (22) ROOT -> . VARIABLELEX
    (23) ROOT -> . OPERATOR
    (24) ROOT -> . OPERATION
    (25) ROOT -> . OPERATIONS
    (26) ROOT -> . COMPARISON_OPERATOR
    (27) ROOT -> . COMPARISON
    (28) ROOT -> . COMPARISONS
    (29) ROOT -> . LOGICAL_OPERATOR
    (30) ROOT -> . SENTENCE
    (31) ROOT -> . SWITCH_BODY
    (32) ROOT -> . BUCLE
    (33) ROOT -> . ELSE_STRUCTURE
    (34) ROOT -> . FUNCTION_ARGUMENTS
    (35) ROOT -> . DECLARATIONS
    (36) PREPROCESOR_DIRECTIVE -> . DEFINE
    (37) PREPROCESOR_DIRECTIVE -> . INCLUDE
    (38) DEFINE -> . PP_DEFINE VARIABLELEX VALUE
    (39) INCLUDE -> . PP_INCLUDE HEADER_LIB
    (40) VALUE -> . NUMBER
    (41) VALUE -> . STRING
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL
    (44) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (45) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (46) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (47) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (51) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (57) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (60) FOR_STRUCTURE -> . FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (67) CODE -> . FUNCTION
    (68) CODE -> . INTEGER_DECLARATION
    (69) CODE -> . DECIMAL_DECLARATION
    (70) CODE -> . ASSIGNMENT_DECLARATION
    (71) CODE -> . COMENTARIOLEX
    (72) EXPRESSION -> . CODE SEMICOLON
    (73) EXPRESSION -> . CONTROL_STRUCTURES
    (74) EXPRESSIONS -> . EXPRESSION
    (75) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (76) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (79) INTEGER_TYPE -> . INT
    (80) INTEGER_TYPE -> . SHORT
    (81) INTEGER_TYPE -> . LONG
    (82) DECIMAL_TYPE -> . FLOAT
    (83) DECIMAL_TYPE -> . DOUBLE
    (84) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (85) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (86) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (87) ASSIGNMENT_OPERATOR -> . EQUAL
    (88) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (89) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (90) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (91) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (92) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (93) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (94) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (95) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (96) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (97) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (98) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL
    (99) COMENTARIOLEX -> . COMMENT
    (100) VARIABLELEX -> . VARNAME
    (101) OPERATOR -> . PLUS
    (102) OPERATOR -> . MINUS
    (103) OPERATOR -> . TIMES
    (104) OPERATOR -> . MODULUS
    (105) OPERATOR -> . DIVIDE
    (106) OPERATION -> . NUMBER OPERATOR NUMBER
    (107) OPERATIONS -> . OPERATION
    (108) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (109) COMPARISON_OPERATOR -> . EQUAL_TO
    (110) COMPARISON_OPERATOR -> . NOT_EQUAL
    (111) COMPARISON_OPERATOR -> . GREATER_THAN
    (112) COMPARISON_OPERATOR -> . LESS_THAN
    (113) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (114) COMPARISON_OPERATOR -> . LESS_EQUAL
    (115) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (116) COMPARISON -> . SENTENCE COMPARISON_OPERATOR SENTENCE
    (117) COMPARISONS -> . COMPARISON
    (118) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (119) LOGICAL_OPERATOR -> . AND
    (120) LOGICAL_OPERATOR -> . OR
    (121) LOGICAL_OPERATOR -> . NOT
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (54) SWITCH_BODY -> . SWITCH_CASE
    (55) SWITCH_BODY -> . SWITCH_DEFAULT
    (56) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (58) BUCLE -> . VARIABLELEX INCREASE
    (59) BUCLE -> . DECREASE VARIABLELEX
    (63) ELSE_STRUCTURE -> . ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (64) ELSE_STRUCTURE -> . ELSE IF_STRUCTURE
    (77) FUNCTION_ARGUMENTS -> . SENTENCES
    (78) FUNCTION_ARGUMENTS -> . COMPARISONS
    (65) DECLARATIONS -> . INTEGER_DECLARATION
    (66) DECLARATIONS -> . DECIMAL_DECLARATION
    (52) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (53) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON
    (124) SENTENCES -> . SENTENCE
    (125) SENTENCES -> . SENTENCE COMMA SENTENCES

    PP_DEFINE       shift and go to state 37
    PP_INCLUDE      shift and go to state 38
    STRING          shift and go to state 39
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41
    WHILE           shift and go to state 42
    SWITCH          shift and go to state 43
    IF              shift and go to state 44
    FOR             shift and go to state 45
    VARNAME         shift and go to state 46
    INT             shift and go to state 47
    SHORT           shift and go to state 48
    LONG            shift and go to state 49
    FLOAT           shift and go to state 50
    DOUBLE          shift and go to state 51
    EQUAL           shift and go to state 52
    PLUS_EQUAL      shift and go to state 53
    MINUS_EQUAL     shift and go to state 54
    DIV_EQUAL       shift and go to state 55
    TIMES_EQUAL     shift and go to state 56
    MOD_EQUAL       shift and go to state 57
    AND_EQUAL       shift and go to state 58
    OR_EQUAL        shift and go to state 59
    XOR_EQUAL       shift and go to state 60
    COMPLEMENT_EQUAL shift and go to state 61
    SHIFTL_EQUAL    shift and go to state 62
    SHIFTR_EQUAL    shift and go to state 63
    COMMENT         shift and go to state 64
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    MODULUS         shift and go to state 68
    DIVIDE          shift and go to state 69
    EQUAL_TO        shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    GREATER_THAN    shift and go to state 72
    LESS_THAN       shift and go to state 73
    GREATER_EQUAL   shift and go to state 74
    LESS_EQUAL      shift and go to state 75
    AND             shift and go to state 76
    OR              shift and go to state 77
    NOT             shift and go to state 78
    DECREASE        shift and go to state 81
    ELSE            shift and go to state 82
    CASE            shift and go to state 84
    DEFAULT         shift and go to state 85

    ROOT                           shift and go to state 1
    PREPROCESOR_DIRECTIVE          shift and go to state 2
    DEFINE                         shift and go to state 3
    INCLUDE                        shift and go to state 4
    VALUE                          shift and go to state 5
    NUMBER                         shift and go to state 6
    CONTROL_STRUCTURES             shift and go to state 7
    WHILE_STRUCTURE                shift and go to state 8
    SWITCH_STRUCTURE               shift and go to state 9
    IF_STRUCTURE                   shift and go to state 10
    FOR_STRUCTURE                  shift and go to state 11
    CODE                           shift and go to state 12
    EXPRESSION                     shift and go to state 13
    EXPRESSIONS                    shift and go to state 14
    FUNCTION                       shift and go to state 15
    INTEGER_TYPE                   shift and go to state 16
    DECIMAL_TYPE                   shift and go to state 17
    INTEGER_DECLARATION            shift and go to state 18
    DECIMAL_DECLARATION            shift and go to state 19
    ASSIGNMENT_DECLARATION         shift and go to state 20
    ASSIGNMENT_OPERATOR            shift and go to state 21
    COMENTARIOLEX                  shift and go to state 22
    VARIABLELEX                    shift and go to state 23
    OPERATOR                       shift and go to state 24
    OPERATION                      shift and go to state 25
    OPERATIONS                     shift and go to state 26
    COMPARISON_OPERATOR            shift and go to state 27
    COMPARISON                     shift and go to state 28
    COMPARISONS                    shift and go to state 29
    LOGICAL_OPERATOR               shift and go to state 30
    SENTENCE                       shift and go to state 31
    SWITCH_BODY                    shift and go to state 32
    BUCLE                          shift and go to state 33
    ELSE_STRUCTURE                 shift and go to state 34
    FUNCTION_ARGUMENTS             shift and go to state 35
    DECLARATIONS                   shift and go to state 36
    SWITCH_CASE                    shift and go to state 79
    SWITCH_DEFAULT                 shift and go to state 80
    SENTENCES                      shift and go to state 83

state 1

    (0) S' -> ROOT .



state 2

    (1) ROOT -> PREPROCESOR_DIRECTIVE .

    $end            reduce using rule 1 (ROOT -> PREPROCESOR_DIRECTIVE .)


state 3

    (2) ROOT -> DEFINE .
    (36) PREPROCESOR_DIRECTIVE -> DEFINE .

  ! reduce/reduce conflict for $end resolved using rule 2 (ROOT -> DEFINE .)
    $end            reduce using rule 2 (ROOT -> DEFINE .)

  ! $end            [ reduce using rule 36 (PREPROCESOR_DIRECTIVE -> DEFINE .) ]


state 4

    (3) ROOT -> INCLUDE .
    (37) PREPROCESOR_DIRECTIVE -> INCLUDE .

  ! reduce/reduce conflict for $end resolved using rule 3 (ROOT -> INCLUDE .)
    $end            reduce using rule 3 (ROOT -> INCLUDE .)

  ! $end            [ reduce using rule 37 (PREPROCESOR_DIRECTIVE -> INCLUDE .) ]


state 5

    (4) ROOT -> VALUE .
    (115) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (109) COMPARISON_OPERATOR -> . EQUAL_TO
    (110) COMPARISON_OPERATOR -> . NOT_EQUAL
    (111) COMPARISON_OPERATOR -> . GREATER_THAN
    (112) COMPARISON_OPERATOR -> . LESS_THAN
    (113) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (114) COMPARISON_OPERATOR -> . LESS_EQUAL

    $end            reduce using rule 4 (ROOT -> VALUE .)
    EQUAL_TO        shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    GREATER_THAN    shift and go to state 72
    LESS_THAN       shift and go to state 73
    GREATER_EQUAL   shift and go to state 74
    LESS_EQUAL      shift and go to state 75

    COMPARISON_OPERATOR            shift and go to state 86

state 6

    (5) ROOT -> NUMBER .
    (40) VALUE -> NUMBER .
    (106) OPERATION -> NUMBER . OPERATOR NUMBER
    (122) SENTENCE -> NUMBER .
    (101) OPERATOR -> . PLUS
    (102) OPERATOR -> . MINUS
    (103) OPERATOR -> . TIMES
    (104) OPERATOR -> . MODULUS
    (105) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
    $end            reduce using rule 5 (ROOT -> NUMBER .)
    EQUAL_TO        reduce using rule 40 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 40 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 40 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 40 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 40 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 40 (VALUE -> NUMBER .)
    COMMA           reduce using rule 122 (SENTENCE -> NUMBER .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    MODULUS         shift and go to state 68
    DIVIDE          shift and go to state 69

  ! $end            [ reduce using rule 40 (VALUE -> NUMBER .) ]
  ! EQUAL_TO        [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! NOT_EQUAL       [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! GREATER_THAN    [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! LESS_THAN       [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! GREATER_EQUAL   [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! LESS_EQUAL      [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! $end            [ reduce using rule 122 (SENTENCE -> NUMBER .) ]

    OPERATOR                       shift and go to state 87

state 7

    (6) ROOT -> CONTROL_STRUCTURES .
    (73) EXPRESSION -> CONTROL_STRUCTURES .

  ! reduce/reduce conflict for $end resolved using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    $end            reduce using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    VARNAME         reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    FOR             reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)

  ! $end            [ reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .) ]


state 8

    (7) ROOT -> WHILE_STRUCTURE .
    (46) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 7 (ROOT -> WHILE_STRUCTURE .)
    $end            reduce using rule 7 (ROOT -> WHILE_STRUCTURE .)
    VARNAME         reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FOR             reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)

  ! $end            [ reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .) ]


state 9

    (8) ROOT -> SWITCH_STRUCTURE .
    (47) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    $end            reduce using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    VARNAME         reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FOR             reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)

  ! $end            [ reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .) ]


state 10

    (9) ROOT -> IF_STRUCTURE .
    (44) CONTROL_STRUCTURES -> IF_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 9 (ROOT -> IF_STRUCTURE .)
    $end            reduce using rule 9 (ROOT -> IF_STRUCTURE .)
    VARNAME         reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FOR             reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)

  ! $end            [ reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .) ]


state 11

    (10) ROOT -> FOR_STRUCTURE .
    (45) CONTROL_STRUCTURES -> FOR_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 10 (ROOT -> FOR_STRUCTURE .)
    $end            reduce using rule 10 (ROOT -> FOR_STRUCTURE .)
    VARNAME         reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FOR             reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)

  ! $end            [ reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .) ]


state 12

    (11) ROOT -> CODE .
    (72) EXPRESSION -> CODE . SEMICOLON

    $end            reduce using rule 11 (ROOT -> CODE .)
    SEMICOLON       shift and go to state 88


state 13

    (12) ROOT -> EXPRESSION .
    (74) EXPRESSIONS -> EXPRESSION .
    (75) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (74) EXPRESSIONS -> . EXPRESSION
    (75) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (72) EXPRESSION -> . CODE SEMICOLON
    (73) EXPRESSION -> . CONTROL_STRUCTURES
    (67) CODE -> . FUNCTION
    (68) CODE -> . INTEGER_DECLARATION
    (69) CODE -> . DECIMAL_DECLARATION
    (70) CODE -> . ASSIGNMENT_DECLARATION
    (71) CODE -> . COMENTARIOLEX
    (44) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (45) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (46) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (47) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (76) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (84) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (85) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (86) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (99) COMENTARIOLEX -> . COMMENT
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (60) FOR_STRUCTURE -> . FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (51) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (57) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (79) INTEGER_TYPE -> . INT
    (80) INTEGER_TYPE -> . SHORT
    (81) INTEGER_TYPE -> . LONG
    (82) DECIMAL_TYPE -> . FLOAT
    (83) DECIMAL_TYPE -> . DOUBLE

  ! reduce/reduce conflict for $end resolved using rule 12 (ROOT -> EXPRESSION .)
    $end            reduce using rule 12 (ROOT -> EXPRESSION .)
    VARNAME         shift and go to state 102
    COMMENT         shift and go to state 64
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 42
    SWITCH          shift and go to state 43
    INT             shift and go to state 47
    SHORT           shift and go to state 48
    LONG            shift and go to state 49
    FLOAT           shift and go to state 50
    DOUBLE          shift and go to state 51

  ! $end            [ reduce using rule 74 (EXPRESSIONS -> EXPRESSION .) ]

    EXPRESSION                     shift and go to state 89
    EXPRESSIONS                    shift and go to state 90
    CODE                           shift and go to state 91
    CONTROL_STRUCTURES             shift and go to state 92
    FUNCTION                       shift and go to state 93
    INTEGER_DECLARATION            shift and go to state 94
    DECIMAL_DECLARATION            shift and go to state 95
    ASSIGNMENT_DECLARATION         shift and go to state 96
    COMENTARIOLEX                  shift and go to state 97
    IF_STRUCTURE                   shift and go to state 98
    FOR_STRUCTURE                  shift and go to state 99
    WHILE_STRUCTURE                shift and go to state 100
    SWITCH_STRUCTURE               shift and go to state 101
    INTEGER_TYPE                   shift and go to state 103
    DECIMAL_TYPE                   shift and go to state 104

state 14

    (13) ROOT -> EXPRESSIONS .

    $end            reduce using rule 13 (ROOT -> EXPRESSIONS .)


state 15

    (14) ROOT -> FUNCTION .
    (67) CODE -> FUNCTION .

  ! reduce/reduce conflict for $end resolved using rule 14 (ROOT -> FUNCTION .)
    $end            reduce using rule 14 (ROOT -> FUNCTION .)
    SEMICOLON       reduce using rule 67 (CODE -> FUNCTION .)

  ! $end            [ reduce using rule 67 (CODE -> FUNCTION .) ]


state 16

    (15) ROOT -> INTEGER_TYPE .
    (84) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    $end            reduce using rule 15 (ROOT -> INTEGER_TYPE .)
    VARNAME         shift and go to state 105


state 17

    (16) ROOT -> DECIMAL_TYPE .
    (85) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    $end            reduce using rule 16 (ROOT -> DECIMAL_TYPE .)
    VARNAME         shift and go to state 106


state 18

    (17) ROOT -> INTEGER_DECLARATION .
    (68) CODE -> INTEGER_DECLARATION .
    (65) DECLARATIONS -> INTEGER_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 17 (ROOT -> INTEGER_DECLARATION .)
  ! reduce/reduce conflict for $end resolved using rule 17 (ROOT -> INTEGER_DECLARATION .)
    $end            reduce using rule 17 (ROOT -> INTEGER_DECLARATION .)
    SEMICOLON       reduce using rule 68 (CODE -> INTEGER_DECLARATION .)

  ! $end            [ reduce using rule 68 (CODE -> INTEGER_DECLARATION .) ]
  ! $end            [ reduce using rule 65 (DECLARATIONS -> INTEGER_DECLARATION .) ]


state 19

    (18) ROOT -> DECIMAL_DECLARATION .
    (69) CODE -> DECIMAL_DECLARATION .
    (66) DECLARATIONS -> DECIMAL_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 18 (ROOT -> DECIMAL_DECLARATION .)
  ! reduce/reduce conflict for $end resolved using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    $end            reduce using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    SEMICOLON       reduce using rule 69 (CODE -> DECIMAL_DECLARATION .)

  ! $end            [ reduce using rule 69 (CODE -> DECIMAL_DECLARATION .) ]
  ! $end            [ reduce using rule 66 (DECLARATIONS -> DECIMAL_DECLARATION .) ]


state 20

    (19) ROOT -> ASSIGNMENT_DECLARATION .
    (70) CODE -> ASSIGNMENT_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    $end            reduce using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    SEMICOLON       reduce using rule 70 (CODE -> ASSIGNMENT_DECLARATION .)

  ! $end            [ reduce using rule 70 (CODE -> ASSIGNMENT_DECLARATION .) ]


state 21

    (20) ROOT -> ASSIGNMENT_OPERATOR .

    $end            reduce using rule 20 (ROOT -> ASSIGNMENT_OPERATOR .)


state 22

    (21) ROOT -> COMENTARIOLEX .
    (71) CODE -> COMENTARIOLEX .

  ! reduce/reduce conflict for $end resolved using rule 21 (ROOT -> COMENTARIOLEX .)
    $end            reduce using rule 21 (ROOT -> COMENTARIOLEX .)
    SEMICOLON       reduce using rule 71 (CODE -> COMENTARIOLEX .)

  ! $end            [ reduce using rule 71 (CODE -> COMENTARIOLEX .) ]


state 23

    (22) ROOT -> VARIABLELEX .
    (58) BUCLE -> VARIABLELEX . INCREASE

    $end            reduce using rule 22 (ROOT -> VARIABLELEX .)
    INCREASE        shift and go to state 107


state 24

    (23) ROOT -> OPERATOR .

    $end            reduce using rule 23 (ROOT -> OPERATOR .)


state 25

    (24) ROOT -> OPERATION .
    (107) OPERATIONS -> OPERATION .
    (108) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (101) OPERATOR -> . PLUS
    (102) OPERATOR -> . MINUS
    (103) OPERATOR -> . TIMES
    (104) OPERATOR -> . MODULUS
    (105) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 24 (ROOT -> OPERATION .)
    $end            reduce using rule 24 (ROOT -> OPERATION .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    MODULUS         shift and go to state 68
    DIVIDE          shift and go to state 69

  ! $end            [ reduce using rule 107 (OPERATIONS -> OPERATION .) ]

    OPERATOR                       shift and go to state 108

state 26

    (25) ROOT -> OPERATIONS .

    $end            reduce using rule 25 (ROOT -> OPERATIONS .)


state 27

    (26) ROOT -> COMPARISON_OPERATOR .

    $end            reduce using rule 26 (ROOT -> COMPARISON_OPERATOR .)


state 28

    (27) ROOT -> COMPARISON .
    (117) COMPARISONS -> COMPARISON .
    (118) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (119) LOGICAL_OPERATOR -> . AND
    (120) LOGICAL_OPERATOR -> . OR
    (121) LOGICAL_OPERATOR -> . NOT

  ! reduce/reduce conflict for $end resolved using rule 27 (ROOT -> COMPARISON .)
    $end            reduce using rule 27 (ROOT -> COMPARISON .)
    AND             shift and go to state 76
    OR              shift and go to state 77
    NOT             shift and go to state 78

  ! $end            [ reduce using rule 117 (COMPARISONS -> COMPARISON .) ]

    LOGICAL_OPERATOR               shift and go to state 109

state 29

    (28) ROOT -> COMPARISONS .
    (78) FUNCTION_ARGUMENTS -> COMPARISONS .

  ! reduce/reduce conflict for $end resolved using rule 28 (ROOT -> COMPARISONS .)
    $end            reduce using rule 28 (ROOT -> COMPARISONS .)

  ! $end            [ reduce using rule 78 (FUNCTION_ARGUMENTS -> COMPARISONS .) ]


state 30

    (29) ROOT -> LOGICAL_OPERATOR .

    $end            reduce using rule 29 (ROOT -> LOGICAL_OPERATOR .)


state 31

    (30) ROOT -> SENTENCE .
    (116) COMPARISON -> SENTENCE . COMPARISON_OPERATOR SENTENCE
    (124) SENTENCES -> SENTENCE .
    (125) SENTENCES -> SENTENCE . COMMA SENTENCES
    (109) COMPARISON_OPERATOR -> . EQUAL_TO
    (110) COMPARISON_OPERATOR -> . NOT_EQUAL
    (111) COMPARISON_OPERATOR -> . GREATER_THAN
    (112) COMPARISON_OPERATOR -> . LESS_THAN
    (113) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (114) COMPARISON_OPERATOR -> . LESS_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 30 (ROOT -> SENTENCE .)
    $end            reduce using rule 30 (ROOT -> SENTENCE .)
    COMMA           shift and go to state 111
    EQUAL_TO        shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    GREATER_THAN    shift and go to state 72
    LESS_THAN       shift and go to state 73
    GREATER_EQUAL   shift and go to state 74
    LESS_EQUAL      shift and go to state 75

  ! $end            [ reduce using rule 124 (SENTENCES -> SENTENCE .) ]

    COMPARISON_OPERATOR            shift and go to state 110

state 32

    (31) ROOT -> SWITCH_BODY .

    $end            reduce using rule 31 (ROOT -> SWITCH_BODY .)


state 33

    (32) ROOT -> BUCLE .

    $end            reduce using rule 32 (ROOT -> BUCLE .)


state 34

    (33) ROOT -> ELSE_STRUCTURE .

    $end            reduce using rule 33 (ROOT -> ELSE_STRUCTURE .)


state 35

    (34) ROOT -> FUNCTION_ARGUMENTS .

    $end            reduce using rule 34 (ROOT -> FUNCTION_ARGUMENTS .)


state 36

    (35) ROOT -> DECLARATIONS .

    $end            reduce using rule 35 (ROOT -> DECLARATIONS .)


state 37

    (38) DEFINE -> PP_DEFINE . VARIABLELEX VALUE
    (100) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 113

    VARIABLELEX                    shift and go to state 112

state 38

    (39) INCLUDE -> PP_INCLUDE . HEADER_LIB

    HEADER_LIB      shift and go to state 114


state 39

    (41) VALUE -> STRING .

    EQUAL_TO        reduce using rule 41 (VALUE -> STRING .)
    NOT_EQUAL       reduce using rule 41 (VALUE -> STRING .)
    GREATER_THAN    reduce using rule 41 (VALUE -> STRING .)
    LESS_THAN       reduce using rule 41 (VALUE -> STRING .)
    GREATER_EQUAL   reduce using rule 41 (VALUE -> STRING .)
    LESS_EQUAL      reduce using rule 41 (VALUE -> STRING .)
    $end            reduce using rule 41 (VALUE -> STRING .)
    AND             reduce using rule 41 (VALUE -> STRING .)
    OR              reduce using rule 41 (VALUE -> STRING .)
    NOT             reduce using rule 41 (VALUE -> STRING .)
    RPAREN          reduce using rule 41 (VALUE -> STRING .)
    SEMICOLON       reduce using rule 41 (VALUE -> STRING .)


state 40

    (42) NUMBER -> INTEGER .

    PLUS            reduce using rule 42 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 42 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 42 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 42 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 42 (NUMBER -> INTEGER .)
    $end            reduce using rule 42 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 42 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 42 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 42 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 42 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 42 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 42 (NUMBER -> INTEGER .)
    COMMA           reduce using rule 42 (NUMBER -> INTEGER .)
    AND             reduce using rule 42 (NUMBER -> INTEGER .)
    OR              reduce using rule 42 (NUMBER -> INTEGER .)
    NOT             reduce using rule 42 (NUMBER -> INTEGER .)
    RPAREN          reduce using rule 42 (NUMBER -> INTEGER .)
    SEMICOLON       reduce using rule 42 (NUMBER -> INTEGER .)


state 41

    (43) NUMBER -> DECIMAL .

    PLUS            reduce using rule 43 (NUMBER -> DECIMAL .)
    MINUS           reduce using rule 43 (NUMBER -> DECIMAL .)
    TIMES           reduce using rule 43 (NUMBER -> DECIMAL .)
    MODULUS         reduce using rule 43 (NUMBER -> DECIMAL .)
    DIVIDE          reduce using rule 43 (NUMBER -> DECIMAL .)
    $end            reduce using rule 43 (NUMBER -> DECIMAL .)
    EQUAL_TO        reduce using rule 43 (NUMBER -> DECIMAL .)
    NOT_EQUAL       reduce using rule 43 (NUMBER -> DECIMAL .)
    GREATER_THAN    reduce using rule 43 (NUMBER -> DECIMAL .)
    LESS_THAN       reduce using rule 43 (NUMBER -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 43 (NUMBER -> DECIMAL .)
    LESS_EQUAL      reduce using rule 43 (NUMBER -> DECIMAL .)
    COMMA           reduce using rule 43 (NUMBER -> DECIMAL .)
    AND             reduce using rule 43 (NUMBER -> DECIMAL .)
    OR              reduce using rule 43 (NUMBER -> DECIMAL .)
    NOT             reduce using rule 43 (NUMBER -> DECIMAL .)
    RPAREN          reduce using rule 43 (NUMBER -> DECIMAL .)
    SEMICOLON       reduce using rule 43 (NUMBER -> DECIMAL .)


state 42

    (51) WHILE_STRUCTURE -> WHILE . LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LPAREN          shift and go to state 115


state 43

    (57) SWITCH_STRUCTURE -> SWITCH . LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LPAREN          shift and go to state 116


state 44

    (61) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LPAREN          shift and go to state 117


state 45

    (60) FOR_STRUCTURE -> FOR . LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN

    LPAREN          shift and go to state 118


state 46

    (76) FUNCTION -> VARNAME . LPAREN FUNCTION_ARGUMENTS RPAREN
    (86) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (100) VARIABLELEX -> VARNAME .
    (123) SENTENCE -> VARNAME .
    (87) ASSIGNMENT_OPERATOR -> . EQUAL
    (88) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (89) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (90) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (91) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (92) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (93) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (94) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (95) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (96) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (97) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (98) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 100 (VARIABLELEX -> VARNAME .)
    LPAREN          shift and go to state 119
    INCREASE        reduce using rule 100 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 100 (VARIABLELEX -> VARNAME .)
    COMMA           reduce using rule 123 (SENTENCE -> VARNAME .)
    EQUAL_TO        reduce using rule 123 (SENTENCE -> VARNAME .)
    NOT_EQUAL       reduce using rule 123 (SENTENCE -> VARNAME .)
    GREATER_THAN    reduce using rule 123 (SENTENCE -> VARNAME .)
    LESS_THAN       reduce using rule 123 (SENTENCE -> VARNAME .)
    GREATER_EQUAL   reduce using rule 123 (SENTENCE -> VARNAME .)
    LESS_EQUAL      reduce using rule 123 (SENTENCE -> VARNAME .)
    EQUAL           shift and go to state 52
    PLUS_EQUAL      shift and go to state 53
    MINUS_EQUAL     shift and go to state 54
    DIV_EQUAL       shift and go to state 55
    TIMES_EQUAL     shift and go to state 56
    MOD_EQUAL       shift and go to state 57
    AND_EQUAL       shift and go to state 58
    OR_EQUAL        shift and go to state 59
    XOR_EQUAL       shift and go to state 60
    COMPLEMENT_EQUAL shift and go to state 61
    SHIFTL_EQUAL    shift and go to state 62
    SHIFTR_EQUAL    shift and go to state 63

  ! $end            [ reduce using rule 123 (SENTENCE -> VARNAME .) ]

    ASSIGNMENT_OPERATOR            shift and go to state 120

state 47

    (79) INTEGER_TYPE -> INT .

    VARNAME         reduce using rule 79 (INTEGER_TYPE -> INT .)
    $end            reduce using rule 79 (INTEGER_TYPE -> INT .)


state 48

    (80) INTEGER_TYPE -> SHORT .

    VARNAME         reduce using rule 80 (INTEGER_TYPE -> SHORT .)
    $end            reduce using rule 80 (INTEGER_TYPE -> SHORT .)


state 49

    (81) INTEGER_TYPE -> LONG .

    VARNAME         reduce using rule 81 (INTEGER_TYPE -> LONG .)
    $end            reduce using rule 81 (INTEGER_TYPE -> LONG .)


state 50

    (82) DECIMAL_TYPE -> FLOAT .

    VARNAME         reduce using rule 82 (DECIMAL_TYPE -> FLOAT .)
    $end            reduce using rule 82 (DECIMAL_TYPE -> FLOAT .)


state 51

    (83) DECIMAL_TYPE -> DOUBLE .

    VARNAME         reduce using rule 83 (DECIMAL_TYPE -> DOUBLE .)
    $end            reduce using rule 83 (DECIMAL_TYPE -> DOUBLE .)


state 52

    (87) ASSIGNMENT_OPERATOR -> EQUAL .

    $end            reduce using rule 87 (ASSIGNMENT_OPERATOR -> EQUAL .)
    VARNAME         reduce using rule 87 (ASSIGNMENT_OPERATOR -> EQUAL .)
    INTEGER         reduce using rule 87 (ASSIGNMENT_OPERATOR -> EQUAL .)
    DECIMAL         reduce using rule 87 (ASSIGNMENT_OPERATOR -> EQUAL .)


state 53

    (88) ASSIGNMENT_OPERATOR -> PLUS_EQUAL .

    $end            reduce using rule 88 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    VARNAME         reduce using rule 88 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    INTEGER         reduce using rule 88 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    DECIMAL         reduce using rule 88 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)


state 54

    (89) ASSIGNMENT_OPERATOR -> MINUS_EQUAL .

    $end            reduce using rule 89 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    VARNAME         reduce using rule 89 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    INTEGER         reduce using rule 89 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    DECIMAL         reduce using rule 89 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)


state 55

    (90) ASSIGNMENT_OPERATOR -> DIV_EQUAL .

    $end            reduce using rule 90 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    VARNAME         reduce using rule 90 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    INTEGER         reduce using rule 90 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    DECIMAL         reduce using rule 90 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)


state 56

    (91) ASSIGNMENT_OPERATOR -> TIMES_EQUAL .

    $end            reduce using rule 91 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    VARNAME         reduce using rule 91 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    INTEGER         reduce using rule 91 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    DECIMAL         reduce using rule 91 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)


state 57

    (92) ASSIGNMENT_OPERATOR -> MOD_EQUAL .

    $end            reduce using rule 92 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    VARNAME         reduce using rule 92 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    INTEGER         reduce using rule 92 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    DECIMAL         reduce using rule 92 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)


state 58

    (93) ASSIGNMENT_OPERATOR -> AND_EQUAL .

    $end            reduce using rule 93 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    VARNAME         reduce using rule 93 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    INTEGER         reduce using rule 93 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    DECIMAL         reduce using rule 93 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)


state 59

    (94) ASSIGNMENT_OPERATOR -> OR_EQUAL .

    $end            reduce using rule 94 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    VARNAME         reduce using rule 94 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    INTEGER         reduce using rule 94 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    DECIMAL         reduce using rule 94 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)


state 60

    (95) ASSIGNMENT_OPERATOR -> XOR_EQUAL .

    $end            reduce using rule 95 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    VARNAME         reduce using rule 95 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    INTEGER         reduce using rule 95 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    DECIMAL         reduce using rule 95 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)


state 61

    (96) ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .

    $end            reduce using rule 96 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    VARNAME         reduce using rule 96 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    INTEGER         reduce using rule 96 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    DECIMAL         reduce using rule 96 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)


state 62

    (97) ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .

    $end            reduce using rule 97 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    VARNAME         reduce using rule 97 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    INTEGER         reduce using rule 97 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    DECIMAL         reduce using rule 97 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)


state 63

    (98) ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .

    $end            reduce using rule 98 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    VARNAME         reduce using rule 98 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    INTEGER         reduce using rule 98 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    DECIMAL         reduce using rule 98 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)


state 64

    (99) COMENTARIOLEX -> COMMENT .

    $end            reduce using rule 99 (COMENTARIOLEX -> COMMENT .)
    SEMICOLON       reduce using rule 99 (COMENTARIOLEX -> COMMENT .)


state 65

    (101) OPERATOR -> PLUS .

    $end            reduce using rule 101 (OPERATOR -> PLUS .)
    INTEGER         reduce using rule 101 (OPERATOR -> PLUS .)
    DECIMAL         reduce using rule 101 (OPERATOR -> PLUS .)


state 66

    (102) OPERATOR -> MINUS .

    $end            reduce using rule 102 (OPERATOR -> MINUS .)
    INTEGER         reduce using rule 102 (OPERATOR -> MINUS .)
    DECIMAL         reduce using rule 102 (OPERATOR -> MINUS .)


state 67

    (103) OPERATOR -> TIMES .

    $end            reduce using rule 103 (OPERATOR -> TIMES .)
    INTEGER         reduce using rule 103 (OPERATOR -> TIMES .)
    DECIMAL         reduce using rule 103 (OPERATOR -> TIMES .)


state 68

    (104) OPERATOR -> MODULUS .

    $end            reduce using rule 104 (OPERATOR -> MODULUS .)
    INTEGER         reduce using rule 104 (OPERATOR -> MODULUS .)
    DECIMAL         reduce using rule 104 (OPERATOR -> MODULUS .)


state 69

    (105) OPERATOR -> DIVIDE .

    $end            reduce using rule 105 (OPERATOR -> DIVIDE .)
    INTEGER         reduce using rule 105 (OPERATOR -> DIVIDE .)
    DECIMAL         reduce using rule 105 (OPERATOR -> DIVIDE .)


state 70

    (109) COMPARISON_OPERATOR -> EQUAL_TO .

    $end            reduce using rule 109 (COMPARISON_OPERATOR -> EQUAL_TO .)
    STRING          reduce using rule 109 (COMPARISON_OPERATOR -> EQUAL_TO .)
    INTEGER         reduce using rule 109 (COMPARISON_OPERATOR -> EQUAL_TO .)
    DECIMAL         reduce using rule 109 (COMPARISON_OPERATOR -> EQUAL_TO .)
    VARNAME         reduce using rule 109 (COMPARISON_OPERATOR -> EQUAL_TO .)


state 71

    (110) COMPARISON_OPERATOR -> NOT_EQUAL .

    $end            reduce using rule 110 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    STRING          reduce using rule 110 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    INTEGER         reduce using rule 110 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    DECIMAL         reduce using rule 110 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    VARNAME         reduce using rule 110 (COMPARISON_OPERATOR -> NOT_EQUAL .)


state 72

    (111) COMPARISON_OPERATOR -> GREATER_THAN .

    $end            reduce using rule 111 (COMPARISON_OPERATOR -> GREATER_THAN .)
    STRING          reduce using rule 111 (COMPARISON_OPERATOR -> GREATER_THAN .)
    INTEGER         reduce using rule 111 (COMPARISON_OPERATOR -> GREATER_THAN .)
    DECIMAL         reduce using rule 111 (COMPARISON_OPERATOR -> GREATER_THAN .)
    VARNAME         reduce using rule 111 (COMPARISON_OPERATOR -> GREATER_THAN .)


state 73

    (112) COMPARISON_OPERATOR -> LESS_THAN .

    $end            reduce using rule 112 (COMPARISON_OPERATOR -> LESS_THAN .)
    STRING          reduce using rule 112 (COMPARISON_OPERATOR -> LESS_THAN .)
    INTEGER         reduce using rule 112 (COMPARISON_OPERATOR -> LESS_THAN .)
    DECIMAL         reduce using rule 112 (COMPARISON_OPERATOR -> LESS_THAN .)
    VARNAME         reduce using rule 112 (COMPARISON_OPERATOR -> LESS_THAN .)


state 74

    (113) COMPARISON_OPERATOR -> GREATER_EQUAL .

    $end            reduce using rule 113 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    STRING          reduce using rule 113 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    INTEGER         reduce using rule 113 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    DECIMAL         reduce using rule 113 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    VARNAME         reduce using rule 113 (COMPARISON_OPERATOR -> GREATER_EQUAL .)


state 75

    (114) COMPARISON_OPERATOR -> LESS_EQUAL .

    $end            reduce using rule 114 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    STRING          reduce using rule 114 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    INTEGER         reduce using rule 114 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    DECIMAL         reduce using rule 114 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    VARNAME         reduce using rule 114 (COMPARISON_OPERATOR -> LESS_EQUAL .)


state 76

    (119) LOGICAL_OPERATOR -> AND .

    $end            reduce using rule 119 (LOGICAL_OPERATOR -> AND .)
    STRING          reduce using rule 119 (LOGICAL_OPERATOR -> AND .)
    VARNAME         reduce using rule 119 (LOGICAL_OPERATOR -> AND .)
    INTEGER         reduce using rule 119 (LOGICAL_OPERATOR -> AND .)
    DECIMAL         reduce using rule 119 (LOGICAL_OPERATOR -> AND .)


state 77

    (120) LOGICAL_OPERATOR -> OR .

    $end            reduce using rule 120 (LOGICAL_OPERATOR -> OR .)
    STRING          reduce using rule 120 (LOGICAL_OPERATOR -> OR .)
    VARNAME         reduce using rule 120 (LOGICAL_OPERATOR -> OR .)
    INTEGER         reduce using rule 120 (LOGICAL_OPERATOR -> OR .)
    DECIMAL         reduce using rule 120 (LOGICAL_OPERATOR -> OR .)


state 78

    (121) LOGICAL_OPERATOR -> NOT .

    $end            reduce using rule 121 (LOGICAL_OPERATOR -> NOT .)
    STRING          reduce using rule 121 (LOGICAL_OPERATOR -> NOT .)
    VARNAME         reduce using rule 121 (LOGICAL_OPERATOR -> NOT .)
    INTEGER         reduce using rule 121 (LOGICAL_OPERATOR -> NOT .)
    DECIMAL         reduce using rule 121 (LOGICAL_OPERATOR -> NOT .)


state 79

    (54) SWITCH_BODY -> SWITCH_CASE .
    (56) SWITCH_BODY -> SWITCH_CASE . SWITCH_BODY
    (54) SWITCH_BODY -> . SWITCH_CASE
    (55) SWITCH_BODY -> . SWITCH_DEFAULT
    (56) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (52) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (53) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    $end            reduce using rule 54 (SWITCH_BODY -> SWITCH_CASE .)
    RCURL_BRACE     reduce using rule 54 (SWITCH_BODY -> SWITCH_CASE .)
    CASE            shift and go to state 84
    DEFAULT         shift and go to state 85

    SWITCH_CASE                    shift and go to state 79
    SWITCH_BODY                    shift and go to state 121
    SWITCH_DEFAULT                 shift and go to state 80

state 80

    (55) SWITCH_BODY -> SWITCH_DEFAULT .

    $end            reduce using rule 55 (SWITCH_BODY -> SWITCH_DEFAULT .)
    RCURL_BRACE     reduce using rule 55 (SWITCH_BODY -> SWITCH_DEFAULT .)


state 81

    (59) BUCLE -> DECREASE . VARIABLELEX
    (100) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 113

    VARIABLELEX                    shift and go to state 122

state 82

    (63) ELSE_STRUCTURE -> ELSE . LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (64) ELSE_STRUCTURE -> ELSE . IF_STRUCTURE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LCURL_BRACE     shift and go to state 123
    IF              shift and go to state 44

    IF_STRUCTURE                   shift and go to state 124

state 83

    (77) FUNCTION_ARGUMENTS -> SENTENCES .

    $end            reduce using rule 77 (FUNCTION_ARGUMENTS -> SENTENCES .)
    RPAREN          reduce using rule 77 (FUNCTION_ARGUMENTS -> SENTENCES .)


state 84

    (52) SWITCH_CASE -> CASE . INTEGER COLON EXPRESSIONS BREAK SEMICOLON

    INTEGER         shift and go to state 125


state 85

    (53) SWITCH_DEFAULT -> DEFAULT . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 126


state 86

    (115) COMPARISON -> VALUE COMPARISON_OPERATOR . VALUE
    (40) VALUE -> . NUMBER
    (41) VALUE -> . STRING
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    STRING          shift and go to state 39
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    VALUE                          shift and go to state 127
    NUMBER                         shift and go to state 128

state 87

    (106) OPERATION -> NUMBER OPERATOR . NUMBER
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    NUMBER                         shift and go to state 129

state 88

    (72) EXPRESSION -> CODE SEMICOLON .

    VARNAME         reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    COMMENT         reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    IF              reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    FOR             reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    WHILE           reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    SWITCH          reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    INT             reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    SHORT           reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    LONG            reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    FLOAT           reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    DOUBLE          reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    $end            reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    RCURL_BRACE     reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    BREAK           reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)
    CONTINUE        reduce using rule 72 (EXPRESSION -> CODE SEMICOLON .)


state 89

    (74) EXPRESSIONS -> EXPRESSION .
    (75) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (74) EXPRESSIONS -> . EXPRESSION
    (75) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (72) EXPRESSION -> . CODE SEMICOLON
    (73) EXPRESSION -> . CONTROL_STRUCTURES
    (67) CODE -> . FUNCTION
    (68) CODE -> . INTEGER_DECLARATION
    (69) CODE -> . DECIMAL_DECLARATION
    (70) CODE -> . ASSIGNMENT_DECLARATION
    (71) CODE -> . COMENTARIOLEX
    (44) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (45) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (46) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (47) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (76) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (84) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (85) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (86) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (99) COMENTARIOLEX -> . COMMENT
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (60) FOR_STRUCTURE -> . FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (51) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (57) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (79) INTEGER_TYPE -> . INT
    (80) INTEGER_TYPE -> . SHORT
    (81) INTEGER_TYPE -> . LONG
    (82) DECIMAL_TYPE -> . FLOAT
    (83) DECIMAL_TYPE -> . DOUBLE

    $end            reduce using rule 74 (EXPRESSIONS -> EXPRESSION .)
    RCURL_BRACE     reduce using rule 74 (EXPRESSIONS -> EXPRESSION .)
    BREAK           reduce using rule 74 (EXPRESSIONS -> EXPRESSION .)
    CONTINUE        reduce using rule 74 (EXPRESSIONS -> EXPRESSION .)
    VARNAME         shift and go to state 102
    COMMENT         shift and go to state 64
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 42
    SWITCH          shift and go to state 43
    INT             shift and go to state 47
    SHORT           shift and go to state 48
    LONG            shift and go to state 49
    FLOAT           shift and go to state 50
    DOUBLE          shift and go to state 51

    EXPRESSION                     shift and go to state 89
    EXPRESSIONS                    shift and go to state 90
    CODE                           shift and go to state 91
    CONTROL_STRUCTURES             shift and go to state 92
    FUNCTION                       shift and go to state 93
    INTEGER_DECLARATION            shift and go to state 94
    DECIMAL_DECLARATION            shift and go to state 95
    ASSIGNMENT_DECLARATION         shift and go to state 96
    COMENTARIOLEX                  shift and go to state 97
    IF_STRUCTURE                   shift and go to state 98
    FOR_STRUCTURE                  shift and go to state 99
    WHILE_STRUCTURE                shift and go to state 100
    SWITCH_STRUCTURE               shift and go to state 101
    INTEGER_TYPE                   shift and go to state 103
    DECIMAL_TYPE                   shift and go to state 104

state 90

    (75) EXPRESSIONS -> EXPRESSION EXPRESSIONS .

    $end            reduce using rule 75 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    RCURL_BRACE     reduce using rule 75 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    BREAK           reduce using rule 75 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    CONTINUE        reduce using rule 75 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)


state 91

    (72) EXPRESSION -> CODE . SEMICOLON

    SEMICOLON       shift and go to state 88


state 92

    (73) EXPRESSION -> CONTROL_STRUCTURES .

    VARNAME         reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    FOR             reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    $end            reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    RCURL_BRACE     reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    BREAK           reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)
    CONTINUE        reduce using rule 73 (EXPRESSION -> CONTROL_STRUCTURES .)


state 93

    (67) CODE -> FUNCTION .

    SEMICOLON       reduce using rule 67 (CODE -> FUNCTION .)


state 94

    (68) CODE -> INTEGER_DECLARATION .

    SEMICOLON       reduce using rule 68 (CODE -> INTEGER_DECLARATION .)


state 95

    (69) CODE -> DECIMAL_DECLARATION .

    SEMICOLON       reduce using rule 69 (CODE -> DECIMAL_DECLARATION .)


state 96

    (70) CODE -> ASSIGNMENT_DECLARATION .

    SEMICOLON       reduce using rule 70 (CODE -> ASSIGNMENT_DECLARATION .)


state 97

    (71) CODE -> COMENTARIOLEX .

    SEMICOLON       reduce using rule 71 (CODE -> COMENTARIOLEX .)


state 98

    (44) CONTROL_STRUCTURES -> IF_STRUCTURE .

    VARNAME         reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FOR             reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    $end            reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    RCURL_BRACE     reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    BREAK           reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    CONTINUE        reduce using rule 44 (CONTROL_STRUCTURES -> IF_STRUCTURE .)


state 99

    (45) CONTROL_STRUCTURES -> FOR_STRUCTURE .

    VARNAME         reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FOR             reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    $end            reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    RCURL_BRACE     reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    BREAK           reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    CONTINUE        reduce using rule 45 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)


state 100

    (46) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

    VARNAME         reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FOR             reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    $end            reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    RCURL_BRACE     reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    BREAK           reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    CONTINUE        reduce using rule 46 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)


state 101

    (47) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

    VARNAME         reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FOR             reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    $end            reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    RCURL_BRACE     reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    BREAK           reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    CONTINUE        reduce using rule 47 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)


state 102

    (76) FUNCTION -> VARNAME . LPAREN FUNCTION_ARGUMENTS RPAREN
    (86) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (87) ASSIGNMENT_OPERATOR -> . EQUAL
    (88) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (89) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (90) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (91) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (92) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (93) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (94) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (95) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (96) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (97) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (98) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

    LPAREN          shift and go to state 119
    EQUAL           shift and go to state 52
    PLUS_EQUAL      shift and go to state 53
    MINUS_EQUAL     shift and go to state 54
    DIV_EQUAL       shift and go to state 55
    TIMES_EQUAL     shift and go to state 56
    MOD_EQUAL       shift and go to state 57
    AND_EQUAL       shift and go to state 58
    OR_EQUAL        shift and go to state 59
    XOR_EQUAL       shift and go to state 60
    COMPLEMENT_EQUAL shift and go to state 61
    SHIFTL_EQUAL    shift and go to state 62
    SHIFTR_EQUAL    shift and go to state 63

    ASSIGNMENT_OPERATOR            shift and go to state 120

state 103

    (84) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    VARNAME         shift and go to state 105


state 104

    (85) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    VARNAME         shift and go to state 106


state 105

    (84) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME . EQUAL INTEGER

    EQUAL           shift and go to state 130


state 106

    (85) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME . EQUAL DECIMAL

    EQUAL           shift and go to state 131


state 107

    (58) BUCLE -> VARIABLELEX INCREASE .

    $end            reduce using rule 58 (BUCLE -> VARIABLELEX INCREASE .)
    RPAREN          reduce using rule 58 (BUCLE -> VARIABLELEX INCREASE .)


state 108

    (108) OPERATIONS -> OPERATION OPERATOR . OPERATIONS
    (107) OPERATIONS -> . OPERATION
    (108) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (106) OPERATION -> . NUMBER OPERATOR NUMBER
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    OPERATION                      shift and go to state 132
    OPERATIONS                     shift and go to state 133
    NUMBER                         shift and go to state 134

state 109

    (118) COMPARISONS -> COMPARISON LOGICAL_OPERATOR . COMPARISONS
    (117) COMPARISONS -> . COMPARISON
    (118) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (115) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (116) COMPARISON -> . SENTENCE COMPARISON_OPERATOR SENTENCE
    (40) VALUE -> . NUMBER
    (41) VALUE -> . STRING
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    STRING          shift and go to state 39
    VARNAME         shift and go to state 140
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    COMPARISON                     shift and go to state 135
    COMPARISONS                    shift and go to state 136
    VALUE                          shift and go to state 137
    SENTENCE                       shift and go to state 138
    NUMBER                         shift and go to state 139

state 110

    (116) COMPARISON -> SENTENCE COMPARISON_OPERATOR . SENTENCE
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 140
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    SENTENCE                       shift and go to state 141
    NUMBER                         shift and go to state 142

state 111

    (125) SENTENCES -> SENTENCE COMMA . SENTENCES
    (124) SENTENCES -> . SENTENCE
    (125) SENTENCES -> . SENTENCE COMMA SENTENCES
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 140
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    SENTENCE                       shift and go to state 143
    SENTENCES                      shift and go to state 144
    NUMBER                         shift and go to state 142

state 112

    (38) DEFINE -> PP_DEFINE VARIABLELEX . VALUE
    (40) VALUE -> . NUMBER
    (41) VALUE -> . STRING
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    STRING          shift and go to state 39
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    VALUE                          shift and go to state 145
    NUMBER                         shift and go to state 128

state 113

    (100) VARIABLELEX -> VARNAME .

    STRING          reduce using rule 100 (VARIABLELEX -> VARNAME .)
    INTEGER         reduce using rule 100 (VARIABLELEX -> VARNAME .)
    DECIMAL         reduce using rule 100 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 100 (VARIABLELEX -> VARNAME .)
    RPAREN          reduce using rule 100 (VARIABLELEX -> VARNAME .)
    INCREASE        reduce using rule 100 (VARIABLELEX -> VARNAME .)


state 114

    (39) INCLUDE -> PP_INCLUDE HEADER_LIB .

    $end            reduce using rule 39 (INCLUDE -> PP_INCLUDE HEADER_LIB .)


state 115

    (51) WHILE_STRUCTURE -> WHILE LPAREN . COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (117) COMPARISONS -> . COMPARISON
    (118) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (115) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (116) COMPARISON -> . SENTENCE COMPARISON_OPERATOR SENTENCE
    (40) VALUE -> . NUMBER
    (41) VALUE -> . STRING
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    STRING          shift and go to state 39
    VARNAME         shift and go to state 140
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    COMPARISONS                    shift and go to state 146
    COMPARISON                     shift and go to state 135
    VALUE                          shift and go to state 137
    SENTENCE                       shift and go to state 138
    NUMBER                         shift and go to state 139

state 116

    (57) SWITCH_STRUCTURE -> SWITCH LPAREN . COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (117) COMPARISONS -> . COMPARISON
    (118) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (115) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (116) COMPARISON -> . SENTENCE COMPARISON_OPERATOR SENTENCE
    (40) VALUE -> . NUMBER
    (41) VALUE -> . STRING
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    STRING          shift and go to state 39
    VARNAME         shift and go to state 140
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    COMPARISONS                    shift and go to state 147
    COMPARISON                     shift and go to state 135
    VALUE                          shift and go to state 137
    SENTENCE                       shift and go to state 138
    NUMBER                         shift and go to state 139

state 117

    (61) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (117) COMPARISONS -> . COMPARISON
    (118) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (115) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (116) COMPARISON -> . SENTENCE COMPARISON_OPERATOR SENTENCE
    (40) VALUE -> . NUMBER
    (41) VALUE -> . STRING
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    STRING          shift and go to state 39
    VARNAME         shift and go to state 140
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    COMPARISONS                    shift and go to state 148
    COMPARISON                     shift and go to state 135
    VALUE                          shift and go to state 137
    SENTENCE                       shift and go to state 138
    NUMBER                         shift and go to state 139

state 118

    (60) FOR_STRUCTURE -> FOR LPAREN . DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (65) DECLARATIONS -> . INTEGER_DECLARATION
    (66) DECLARATIONS -> . DECIMAL_DECLARATION
    (84) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (85) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (79) INTEGER_TYPE -> . INT
    (80) INTEGER_TYPE -> . SHORT
    (81) INTEGER_TYPE -> . LONG
    (82) DECIMAL_TYPE -> . FLOAT
    (83) DECIMAL_TYPE -> . DOUBLE

    INT             shift and go to state 47
    SHORT           shift and go to state 48
    LONG            shift and go to state 49
    FLOAT           shift and go to state 50
    DOUBLE          shift and go to state 51

    DECLARATIONS                   shift and go to state 149
    INTEGER_DECLARATION            shift and go to state 150
    DECIMAL_DECLARATION            shift and go to state 151
    INTEGER_TYPE                   shift and go to state 103
    DECIMAL_TYPE                   shift and go to state 104

state 119

    (76) FUNCTION -> VARNAME LPAREN . FUNCTION_ARGUMENTS RPAREN
    (77) FUNCTION_ARGUMENTS -> . SENTENCES
    (78) FUNCTION_ARGUMENTS -> . COMPARISONS
    (124) SENTENCES -> . SENTENCE
    (125) SENTENCES -> . SENTENCE COMMA SENTENCES
    (117) COMPARISONS -> . COMPARISON
    (118) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (115) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (116) COMPARISON -> . SENTENCE COMPARISON_OPERATOR SENTENCE
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL
    (40) VALUE -> . NUMBER
    (41) VALUE -> . STRING

    VARNAME         shift and go to state 140
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41
    STRING          shift and go to state 39

    FUNCTION_ARGUMENTS             shift and go to state 152
    SENTENCES                      shift and go to state 83
    COMPARISONS                    shift and go to state 153
    SENTENCE                       shift and go to state 154
    COMPARISON                     shift and go to state 135
    NUMBER                         shift and go to state 155
    VALUE                          shift and go to state 137

state 120

    (86) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR . SENTENCE
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 140
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    SENTENCE                       shift and go to state 156
    NUMBER                         shift and go to state 142

state 121

    (56) SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .

    $end            reduce using rule 56 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)
    RCURL_BRACE     reduce using rule 56 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)


state 122

    (59) BUCLE -> DECREASE VARIABLELEX .

    $end            reduce using rule 59 (BUCLE -> DECREASE VARIABLELEX .)
    RPAREN          reduce using rule 59 (BUCLE -> DECREASE VARIABLELEX .)


state 123

    (63) ELSE_STRUCTURE -> ELSE LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (74) EXPRESSIONS -> . EXPRESSION
    (75) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (72) EXPRESSION -> . CODE SEMICOLON
    (73) EXPRESSION -> . CONTROL_STRUCTURES
    (67) CODE -> . FUNCTION
    (68) CODE -> . INTEGER_DECLARATION
    (69) CODE -> . DECIMAL_DECLARATION
    (70) CODE -> . ASSIGNMENT_DECLARATION
    (71) CODE -> . COMENTARIOLEX
    (44) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (45) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (46) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (47) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (76) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (84) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (85) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (86) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (99) COMENTARIOLEX -> . COMMENT
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (60) FOR_STRUCTURE -> . FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (51) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (57) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (79) INTEGER_TYPE -> . INT
    (80) INTEGER_TYPE -> . SHORT
    (81) INTEGER_TYPE -> . LONG
    (82) DECIMAL_TYPE -> . FLOAT
    (83) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 102
    COMMENT         shift and go to state 64
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 42
    SWITCH          shift and go to state 43
    INT             shift and go to state 47
    SHORT           shift and go to state 48
    LONG            shift and go to state 49
    FLOAT           shift and go to state 50
    DOUBLE          shift and go to state 51

    EXPRESSIONS                    shift and go to state 157
    EXPRESSION                     shift and go to state 89
    CODE                           shift and go to state 91
    CONTROL_STRUCTURES             shift and go to state 92
    FUNCTION                       shift and go to state 93
    INTEGER_DECLARATION            shift and go to state 94
    DECIMAL_DECLARATION            shift and go to state 95
    ASSIGNMENT_DECLARATION         shift and go to state 96
    COMENTARIOLEX                  shift and go to state 97
    IF_STRUCTURE                   shift and go to state 98
    FOR_STRUCTURE                  shift and go to state 99
    WHILE_STRUCTURE                shift and go to state 100
    SWITCH_STRUCTURE               shift and go to state 101
    INTEGER_TYPE                   shift and go to state 103
    DECIMAL_TYPE                   shift and go to state 104

state 124

    (64) ELSE_STRUCTURE -> ELSE IF_STRUCTURE .

    $end            reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    VARNAME         reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    COMMENT         reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    IF              reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    FOR             reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    WHILE           reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    SWITCH          reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    INT             reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    SHORT           reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    LONG            reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    FLOAT           reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    DOUBLE          reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    RCURL_BRACE     reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    BREAK           reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    CONTINUE        reduce using rule 64 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)


state 125

    (52) SWITCH_CASE -> CASE INTEGER . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 158


state 126

    (53) SWITCH_DEFAULT -> DEFAULT COLON . EXPRESSIONS BREAK SEMICOLON
    (74) EXPRESSIONS -> . EXPRESSION
    (75) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (72) EXPRESSION -> . CODE SEMICOLON
    (73) EXPRESSION -> . CONTROL_STRUCTURES
    (67) CODE -> . FUNCTION
    (68) CODE -> . INTEGER_DECLARATION
    (69) CODE -> . DECIMAL_DECLARATION
    (70) CODE -> . ASSIGNMENT_DECLARATION
    (71) CODE -> . COMENTARIOLEX
    (44) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (45) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (46) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (47) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (76) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (84) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (85) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (86) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (99) COMENTARIOLEX -> . COMMENT
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (60) FOR_STRUCTURE -> . FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (51) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (57) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (79) INTEGER_TYPE -> . INT
    (80) INTEGER_TYPE -> . SHORT
    (81) INTEGER_TYPE -> . LONG
    (82) DECIMAL_TYPE -> . FLOAT
    (83) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 102
    COMMENT         shift and go to state 64
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 42
    SWITCH          shift and go to state 43
    INT             shift and go to state 47
    SHORT           shift and go to state 48
    LONG            shift and go to state 49
    FLOAT           shift and go to state 50
    DOUBLE          shift and go to state 51

    EXPRESSIONS                    shift and go to state 159
    EXPRESSION                     shift and go to state 89
    CODE                           shift and go to state 91
    CONTROL_STRUCTURES             shift and go to state 92
    FUNCTION                       shift and go to state 93
    INTEGER_DECLARATION            shift and go to state 94
    DECIMAL_DECLARATION            shift and go to state 95
    ASSIGNMENT_DECLARATION         shift and go to state 96
    COMENTARIOLEX                  shift and go to state 97
    IF_STRUCTURE                   shift and go to state 98
    FOR_STRUCTURE                  shift and go to state 99
    WHILE_STRUCTURE                shift and go to state 100
    SWITCH_STRUCTURE               shift and go to state 101
    INTEGER_TYPE                   shift and go to state 103
    DECIMAL_TYPE                   shift and go to state 104

state 127

    (115) COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .

    AND             reduce using rule 115 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    OR              reduce using rule 115 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    NOT             reduce using rule 115 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    $end            reduce using rule 115 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    RPAREN          reduce using rule 115 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    SEMICOLON       reduce using rule 115 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)


state 128

    (40) VALUE -> NUMBER .

    AND             reduce using rule 40 (VALUE -> NUMBER .)
    OR              reduce using rule 40 (VALUE -> NUMBER .)
    NOT             reduce using rule 40 (VALUE -> NUMBER .)
    $end            reduce using rule 40 (VALUE -> NUMBER .)
    RPAREN          reduce using rule 40 (VALUE -> NUMBER .)
    SEMICOLON       reduce using rule 40 (VALUE -> NUMBER .)


state 129

    (106) OPERATION -> NUMBER OPERATOR NUMBER .

    PLUS            reduce using rule 106 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MINUS           reduce using rule 106 (OPERATION -> NUMBER OPERATOR NUMBER .)
    TIMES           reduce using rule 106 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MODULUS         reduce using rule 106 (OPERATION -> NUMBER OPERATOR NUMBER .)
    DIVIDE          reduce using rule 106 (OPERATION -> NUMBER OPERATOR NUMBER .)
    $end            reduce using rule 106 (OPERATION -> NUMBER OPERATOR NUMBER .)


state 130

    (84) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL . INTEGER

    INTEGER         shift and go to state 160


state 131

    (85) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL . DECIMAL

    DECIMAL         shift and go to state 161


state 132

    (107) OPERATIONS -> OPERATION .
    (108) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (101) OPERATOR -> . PLUS
    (102) OPERATOR -> . MINUS
    (103) OPERATOR -> . TIMES
    (104) OPERATOR -> . MODULUS
    (105) OPERATOR -> . DIVIDE

    $end            reduce using rule 107 (OPERATIONS -> OPERATION .)
    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    MODULUS         shift and go to state 68
    DIVIDE          shift and go to state 69

    OPERATOR                       shift and go to state 108

state 133

    (108) OPERATIONS -> OPERATION OPERATOR OPERATIONS .

    $end            reduce using rule 108 (OPERATIONS -> OPERATION OPERATOR OPERATIONS .)


state 134

    (106) OPERATION -> NUMBER . OPERATOR NUMBER
    (101) OPERATOR -> . PLUS
    (102) OPERATOR -> . MINUS
    (103) OPERATOR -> . TIMES
    (104) OPERATOR -> . MODULUS
    (105) OPERATOR -> . DIVIDE

    PLUS            shift and go to state 65
    MINUS           shift and go to state 66
    TIMES           shift and go to state 67
    MODULUS         shift and go to state 68
    DIVIDE          shift and go to state 69

    OPERATOR                       shift and go to state 87

state 135

    (117) COMPARISONS -> COMPARISON .
    (118) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (119) LOGICAL_OPERATOR -> . AND
    (120) LOGICAL_OPERATOR -> . OR
    (121) LOGICAL_OPERATOR -> . NOT

    $end            reduce using rule 117 (COMPARISONS -> COMPARISON .)
    RPAREN          reduce using rule 117 (COMPARISONS -> COMPARISON .)
    SEMICOLON       reduce using rule 117 (COMPARISONS -> COMPARISON .)
    AND             shift and go to state 76
    OR              shift and go to state 77
    NOT             shift and go to state 78

    LOGICAL_OPERATOR               shift and go to state 109

state 136

    (118) COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .

    $end            reduce using rule 118 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)
    RPAREN          reduce using rule 118 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)
    SEMICOLON       reduce using rule 118 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)


state 137

    (115) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (109) COMPARISON_OPERATOR -> . EQUAL_TO
    (110) COMPARISON_OPERATOR -> . NOT_EQUAL
    (111) COMPARISON_OPERATOR -> . GREATER_THAN
    (112) COMPARISON_OPERATOR -> . LESS_THAN
    (113) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (114) COMPARISON_OPERATOR -> . LESS_EQUAL

    EQUAL_TO        shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    GREATER_THAN    shift and go to state 72
    LESS_THAN       shift and go to state 73
    GREATER_EQUAL   shift and go to state 74
    LESS_EQUAL      shift and go to state 75

    COMPARISON_OPERATOR            shift and go to state 86

state 138

    (116) COMPARISON -> SENTENCE . COMPARISON_OPERATOR SENTENCE
    (109) COMPARISON_OPERATOR -> . EQUAL_TO
    (110) COMPARISON_OPERATOR -> . NOT_EQUAL
    (111) COMPARISON_OPERATOR -> . GREATER_THAN
    (112) COMPARISON_OPERATOR -> . LESS_THAN
    (113) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (114) COMPARISON_OPERATOR -> . LESS_EQUAL

    EQUAL_TO        shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    GREATER_THAN    shift and go to state 72
    LESS_THAN       shift and go to state 73
    GREATER_EQUAL   shift and go to state 74
    LESS_EQUAL      shift and go to state 75

    COMPARISON_OPERATOR            shift and go to state 110

state 139

    (40) VALUE -> NUMBER .
    (122) SENTENCE -> NUMBER .

  ! reduce/reduce conflict for EQUAL_TO resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 40 (VALUE -> NUMBER .)
    EQUAL_TO        reduce using rule 40 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 40 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 40 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 40 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 40 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 40 (VALUE -> NUMBER .)

  ! EQUAL_TO        [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! NOT_EQUAL       [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! GREATER_THAN    [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! LESS_THAN       [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! GREATER_EQUAL   [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! LESS_EQUAL      [ reduce using rule 122 (SENTENCE -> NUMBER .) ]


state 140

    (123) SENTENCE -> VARNAME .

    EQUAL_TO        reduce using rule 123 (SENTENCE -> VARNAME .)
    NOT_EQUAL       reduce using rule 123 (SENTENCE -> VARNAME .)
    GREATER_THAN    reduce using rule 123 (SENTENCE -> VARNAME .)
    LESS_THAN       reduce using rule 123 (SENTENCE -> VARNAME .)
    GREATER_EQUAL   reduce using rule 123 (SENTENCE -> VARNAME .)
    LESS_EQUAL      reduce using rule 123 (SENTENCE -> VARNAME .)
    AND             reduce using rule 123 (SENTENCE -> VARNAME .)
    OR              reduce using rule 123 (SENTENCE -> VARNAME .)
    NOT             reduce using rule 123 (SENTENCE -> VARNAME .)
    $end            reduce using rule 123 (SENTENCE -> VARNAME .)
    RPAREN          reduce using rule 123 (SENTENCE -> VARNAME .)
    SEMICOLON       reduce using rule 123 (SENTENCE -> VARNAME .)
    COMMA           reduce using rule 123 (SENTENCE -> VARNAME .)


state 141

    (116) COMPARISON -> SENTENCE COMPARISON_OPERATOR SENTENCE .

    AND             reduce using rule 116 (COMPARISON -> SENTENCE COMPARISON_OPERATOR SENTENCE .)
    OR              reduce using rule 116 (COMPARISON -> SENTENCE COMPARISON_OPERATOR SENTENCE .)
    NOT             reduce using rule 116 (COMPARISON -> SENTENCE COMPARISON_OPERATOR SENTENCE .)
    $end            reduce using rule 116 (COMPARISON -> SENTENCE COMPARISON_OPERATOR SENTENCE .)
    RPAREN          reduce using rule 116 (COMPARISON -> SENTENCE COMPARISON_OPERATOR SENTENCE .)
    SEMICOLON       reduce using rule 116 (COMPARISON -> SENTENCE COMPARISON_OPERATOR SENTENCE .)


state 142

    (122) SENTENCE -> NUMBER .

    AND             reduce using rule 122 (SENTENCE -> NUMBER .)
    OR              reduce using rule 122 (SENTENCE -> NUMBER .)
    NOT             reduce using rule 122 (SENTENCE -> NUMBER .)
    $end            reduce using rule 122 (SENTENCE -> NUMBER .)
    RPAREN          reduce using rule 122 (SENTENCE -> NUMBER .)
    SEMICOLON       reduce using rule 122 (SENTENCE -> NUMBER .)
    COMMA           reduce using rule 122 (SENTENCE -> NUMBER .)


state 143

    (124) SENTENCES -> SENTENCE .
    (125) SENTENCES -> SENTENCE . COMMA SENTENCES

    $end            reduce using rule 124 (SENTENCES -> SENTENCE .)
    RPAREN          reduce using rule 124 (SENTENCES -> SENTENCE .)
    COMMA           shift and go to state 111


state 144

    (125) SENTENCES -> SENTENCE COMMA SENTENCES .

    $end            reduce using rule 125 (SENTENCES -> SENTENCE COMMA SENTENCES .)
    RPAREN          reduce using rule 125 (SENTENCES -> SENTENCE COMMA SENTENCES .)


state 145

    (38) DEFINE -> PP_DEFINE VARIABLELEX VALUE .

    $end            reduce using rule 38 (DEFINE -> PP_DEFINE VARIABLELEX VALUE .)


state 146

    (51) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS . RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    RPAREN          shift and go to state 162


state 147

    (57) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS . RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    RPAREN          shift and go to state 163


state 148

    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    RPAREN          shift and go to state 164


state 149

    (60) FOR_STRUCTURE -> FOR LPAREN DECLARATIONS . SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN

    SEMICOLON       shift and go to state 165


state 150

    (65) DECLARATIONS -> INTEGER_DECLARATION .

    SEMICOLON       reduce using rule 65 (DECLARATIONS -> INTEGER_DECLARATION .)


state 151

    (66) DECLARATIONS -> DECIMAL_DECLARATION .

    SEMICOLON       reduce using rule 66 (DECLARATIONS -> DECIMAL_DECLARATION .)


state 152

    (76) FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS . RPAREN

    RPAREN          shift and go to state 166


state 153

    (78) FUNCTION_ARGUMENTS -> COMPARISONS .

    RPAREN          reduce using rule 78 (FUNCTION_ARGUMENTS -> COMPARISONS .)


state 154

    (124) SENTENCES -> SENTENCE .
    (125) SENTENCES -> SENTENCE . COMMA SENTENCES
    (116) COMPARISON -> SENTENCE . COMPARISON_OPERATOR SENTENCE
    (109) COMPARISON_OPERATOR -> . EQUAL_TO
    (110) COMPARISON_OPERATOR -> . NOT_EQUAL
    (111) COMPARISON_OPERATOR -> . GREATER_THAN
    (112) COMPARISON_OPERATOR -> . LESS_THAN
    (113) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (114) COMPARISON_OPERATOR -> . LESS_EQUAL

    RPAREN          reduce using rule 124 (SENTENCES -> SENTENCE .)
    COMMA           shift and go to state 111
    EQUAL_TO        shift and go to state 70
    NOT_EQUAL       shift and go to state 71
    GREATER_THAN    shift and go to state 72
    LESS_THAN       shift and go to state 73
    GREATER_EQUAL   shift and go to state 74
    LESS_EQUAL      shift and go to state 75

    COMPARISON_OPERATOR            shift and go to state 110

state 155

    (122) SENTENCE -> NUMBER .
    (40) VALUE -> NUMBER .

  ! reduce/reduce conflict for EQUAL_TO resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 40 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 40 (VALUE -> NUMBER .)
    COMMA           reduce using rule 122 (SENTENCE -> NUMBER .)
    RPAREN          reduce using rule 122 (SENTENCE -> NUMBER .)
    EQUAL_TO        reduce using rule 40 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 40 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 40 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 40 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 40 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 40 (VALUE -> NUMBER .)

  ! EQUAL_TO        [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! NOT_EQUAL       [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! GREATER_THAN    [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! LESS_THAN       [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! GREATER_EQUAL   [ reduce using rule 122 (SENTENCE -> NUMBER .) ]
  ! LESS_EQUAL      [ reduce using rule 122 (SENTENCE -> NUMBER .) ]


state 156

    (86) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .

    $end            reduce using rule 86 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)
    SEMICOLON       reduce using rule 86 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)


state 157

    (63) ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS . RCURL_BRACE

    RCURL_BRACE     shift and go to state 167


state 158

    (52) SWITCH_CASE -> CASE INTEGER COLON . EXPRESSIONS BREAK SEMICOLON
    (74) EXPRESSIONS -> . EXPRESSION
    (75) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (72) EXPRESSION -> . CODE SEMICOLON
    (73) EXPRESSION -> . CONTROL_STRUCTURES
    (67) CODE -> . FUNCTION
    (68) CODE -> . INTEGER_DECLARATION
    (69) CODE -> . DECIMAL_DECLARATION
    (70) CODE -> . ASSIGNMENT_DECLARATION
    (71) CODE -> . COMENTARIOLEX
    (44) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (45) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (46) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (47) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (76) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (84) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (85) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (86) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (99) COMENTARIOLEX -> . COMMENT
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (60) FOR_STRUCTURE -> . FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (51) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (57) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (79) INTEGER_TYPE -> . INT
    (80) INTEGER_TYPE -> . SHORT
    (81) INTEGER_TYPE -> . LONG
    (82) DECIMAL_TYPE -> . FLOAT
    (83) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 102
    COMMENT         shift and go to state 64
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 42
    SWITCH          shift and go to state 43
    INT             shift and go to state 47
    SHORT           shift and go to state 48
    LONG            shift and go to state 49
    FLOAT           shift and go to state 50
    DOUBLE          shift and go to state 51

    EXPRESSIONS                    shift and go to state 168
    EXPRESSION                     shift and go to state 89
    CODE                           shift and go to state 91
    CONTROL_STRUCTURES             shift and go to state 92
    FUNCTION                       shift and go to state 93
    INTEGER_DECLARATION            shift and go to state 94
    DECIMAL_DECLARATION            shift and go to state 95
    ASSIGNMENT_DECLARATION         shift and go to state 96
    COMENTARIOLEX                  shift and go to state 97
    IF_STRUCTURE                   shift and go to state 98
    FOR_STRUCTURE                  shift and go to state 99
    WHILE_STRUCTURE                shift and go to state 100
    SWITCH_STRUCTURE               shift and go to state 101
    INTEGER_TYPE                   shift and go to state 103
    DECIMAL_TYPE                   shift and go to state 104

state 159

    (53) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 169


state 160

    (84) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .

    $end            reduce using rule 84 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)
    SEMICOLON       reduce using rule 84 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)


state 161

    (85) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .

    $end            reduce using rule 85 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)
    SEMICOLON       reduce using rule 85 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)


state 162

    (51) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN . LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LCURL_BRACE     shift and go to state 170


state 163

    (57) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN . LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LCURL_BRACE     shift and go to state 171


state 164

    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LCURL_BRACE     shift and go to state 172


state 165

    (60) FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON . COMPARISONS SEMICOLON BUCLE RPAREN
    (117) COMPARISONS -> . COMPARISON
    (118) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (115) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (116) COMPARISON -> . SENTENCE COMPARISON_OPERATOR SENTENCE
    (40) VALUE -> . NUMBER
    (41) VALUE -> . STRING
    (122) SENTENCE -> . NUMBER
    (123) SENTENCE -> . VARNAME
    (42) NUMBER -> . INTEGER
    (43) NUMBER -> . DECIMAL

    STRING          shift and go to state 39
    VARNAME         shift and go to state 140
    INTEGER         shift and go to state 40
    DECIMAL         shift and go to state 41

    COMPARISONS                    shift and go to state 173
    COMPARISON                     shift and go to state 135
    VALUE                          shift and go to state 137
    SENTENCE                       shift and go to state 138
    NUMBER                         shift and go to state 139

state 166

    (76) FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN .

    $end            reduce using rule 76 (FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN .)
    SEMICOLON       reduce using rule 76 (FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN .)


state 167

    (63) ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .

    $end            reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    VARNAME         reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    COMMENT         reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    IF              reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FOR             reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    WHILE           reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SWITCH          reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INT             reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SHORT           reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    LONG            reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FLOAT           reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    DOUBLE          reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    BREAK           reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    CONTINUE        reduce using rule 63 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)


state 168

    (52) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 174


state 169

    (53) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 175


state 170

    (51) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE . BODY_STRUCTURE RCURL_BRACE
    (48) BODY_STRUCTURE -> . EXPRESSIONS
    (49) BODY_STRUCTURE -> . EXPRESSIONS BREAK SEMICOLON
    (50) BODY_STRUCTURE -> . EXPRESSIONS CONTINUE SEMICOLON
    (74) EXPRESSIONS -> . EXPRESSION
    (75) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (72) EXPRESSION -> . CODE SEMICOLON
    (73) EXPRESSION -> . CONTROL_STRUCTURES
    (67) CODE -> . FUNCTION
    (68) CODE -> . INTEGER_DECLARATION
    (69) CODE -> . DECIMAL_DECLARATION
    (70) CODE -> . ASSIGNMENT_DECLARATION
    (71) CODE -> . COMENTARIOLEX
    (44) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (45) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (46) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (47) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (76) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (84) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (85) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (86) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (99) COMENTARIOLEX -> . COMMENT
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (60) FOR_STRUCTURE -> . FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (51) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (57) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (79) INTEGER_TYPE -> . INT
    (80) INTEGER_TYPE -> . SHORT
    (81) INTEGER_TYPE -> . LONG
    (82) DECIMAL_TYPE -> . FLOAT
    (83) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 102
    COMMENT         shift and go to state 64
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 42
    SWITCH          shift and go to state 43
    INT             shift and go to state 47
    SHORT           shift and go to state 48
    LONG            shift and go to state 49
    FLOAT           shift and go to state 50
    DOUBLE          shift and go to state 51

    BODY_STRUCTURE                 shift and go to state 176
    EXPRESSIONS                    shift and go to state 177
    EXPRESSION                     shift and go to state 89
    CODE                           shift and go to state 91
    CONTROL_STRUCTURES             shift and go to state 92
    FUNCTION                       shift and go to state 93
    INTEGER_DECLARATION            shift and go to state 94
    DECIMAL_DECLARATION            shift and go to state 95
    ASSIGNMENT_DECLARATION         shift and go to state 96
    COMENTARIOLEX                  shift and go to state 97
    IF_STRUCTURE                   shift and go to state 98
    FOR_STRUCTURE                  shift and go to state 99
    WHILE_STRUCTURE                shift and go to state 100
    SWITCH_STRUCTURE               shift and go to state 101
    INTEGER_TYPE                   shift and go to state 103
    DECIMAL_TYPE                   shift and go to state 104

state 171

    (57) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE . SWITCH_BODY RCURL_BRACE
    (54) SWITCH_BODY -> . SWITCH_CASE
    (55) SWITCH_BODY -> . SWITCH_DEFAULT
    (56) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (52) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (53) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    CASE            shift and go to state 84
    DEFAULT         shift and go to state 85

    SWITCH_BODY                    shift and go to state 178
    SWITCH_CASE                    shift and go to state 79
    SWITCH_DEFAULT                 shift and go to state 80

state 172

    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (74) EXPRESSIONS -> . EXPRESSION
    (75) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (72) EXPRESSION -> . CODE SEMICOLON
    (73) EXPRESSION -> . CONTROL_STRUCTURES
    (67) CODE -> . FUNCTION
    (68) CODE -> . INTEGER_DECLARATION
    (69) CODE -> . DECIMAL_DECLARATION
    (70) CODE -> . ASSIGNMENT_DECLARATION
    (71) CODE -> . COMENTARIOLEX
    (44) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (45) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (46) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (47) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (76) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (84) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (85) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (86) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (99) COMENTARIOLEX -> . COMMENT
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (60) FOR_STRUCTURE -> . FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (51) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (57) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (79) INTEGER_TYPE -> . INT
    (80) INTEGER_TYPE -> . SHORT
    (81) INTEGER_TYPE -> . LONG
    (82) DECIMAL_TYPE -> . FLOAT
    (83) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 102
    COMMENT         shift and go to state 64
    IF              shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 42
    SWITCH          shift and go to state 43
    INT             shift and go to state 47
    SHORT           shift and go to state 48
    LONG            shift and go to state 49
    FLOAT           shift and go to state 50
    DOUBLE          shift and go to state 51

    EXPRESSIONS                    shift and go to state 179
    EXPRESSION                     shift and go to state 89
    CODE                           shift and go to state 91
    CONTROL_STRUCTURES             shift and go to state 92
    FUNCTION                       shift and go to state 93
    INTEGER_DECLARATION            shift and go to state 94
    DECIMAL_DECLARATION            shift and go to state 95
    ASSIGNMENT_DECLARATION         shift and go to state 96
    COMENTARIOLEX                  shift and go to state 97
    IF_STRUCTURE                   shift and go to state 98
    FOR_STRUCTURE                  shift and go to state 99
    WHILE_STRUCTURE                shift and go to state 100
    SWITCH_STRUCTURE               shift and go to state 101
    INTEGER_TYPE                   shift and go to state 103
    DECIMAL_TYPE                   shift and go to state 104

state 173

    (60) FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS . SEMICOLON BUCLE RPAREN

    SEMICOLON       shift and go to state 180


state 174

    (52) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 181


state 175

    (53) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .

    $end            reduce using rule 53 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 53 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)


state 176

    (51) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE . RCURL_BRACE

    RCURL_BRACE     shift and go to state 182


state 177

    (48) BODY_STRUCTURE -> EXPRESSIONS .
    (49) BODY_STRUCTURE -> EXPRESSIONS . BREAK SEMICOLON
    (50) BODY_STRUCTURE -> EXPRESSIONS . CONTINUE SEMICOLON

    RCURL_BRACE     reduce using rule 48 (BODY_STRUCTURE -> EXPRESSIONS .)
    BREAK           shift and go to state 183
    CONTINUE        shift and go to state 184


state 178

    (57) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY . RCURL_BRACE

    RCURL_BRACE     shift and go to state 185


state 179

    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE
    (62) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE ELSE_STRUCTURE

    RCURL_BRACE     shift and go to state 186


state 180

    (60) FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON . BUCLE RPAREN
    (58) BUCLE -> . VARIABLELEX INCREASE
    (59) BUCLE -> . DECREASE VARIABLELEX
    (100) VARIABLELEX -> . VARNAME

    DECREASE        shift and go to state 81
    VARNAME         shift and go to state 113

    BUCLE                          shift and go to state 187
    VARIABLELEX                    shift and go to state 188

state 181

    (52) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .

    CASE            reduce using rule 52 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    DEFAULT         reduce using rule 52 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    $end            reduce using rule 52 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 52 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)


state 182

    (51) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .

    $end            reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    VARNAME         reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    COMMENT         reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    IF              reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    FOR             reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    WHILE           reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SWITCH          reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    INT             reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SHORT           reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    LONG            reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    FLOAT           reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    DOUBLE          reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    BREAK           reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    CONTINUE        reduce using rule 51 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)


state 183

    (49) BODY_STRUCTURE -> EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 189


state 184

    (50) BODY_STRUCTURE -> EXPRESSIONS CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 190


state 185

    (57) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .

    $end            reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    VARNAME         reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    COMMENT         reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    IF              reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    FOR             reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    WHILE           reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SWITCH          reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    INT             reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SHORT           reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    LONG            reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    FLOAT           reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    DOUBLE          reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    BREAK           reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    CONTINUE        reduce using rule 57 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)


state 186

    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .
    (62) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE . ELSE_STRUCTURE
    (63) ELSE_STRUCTURE -> . ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (64) ELSE_STRUCTURE -> . ELSE IF_STRUCTURE

    $end            reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    VARNAME         reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    COMMENT         reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    IF              reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FOR             reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    WHILE           reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SWITCH          reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INT             reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SHORT           reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    LONG            reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FLOAT           reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    DOUBLE          reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    BREAK           reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    CONTINUE        reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    ELSE            shift and go to state 82

    ELSE_STRUCTURE                 shift and go to state 191

state 187

    (60) FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE . RPAREN

    RPAREN          shift and go to state 192


state 188

    (58) BUCLE -> VARIABLELEX . INCREASE

    INCREASE        shift and go to state 107


state 189

    (49) BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .

    RCURL_BRACE     reduce using rule 49 (BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .)


state 190

    (50) BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .

    RCURL_BRACE     reduce using rule 50 (BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .)


state 191

    (62) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .

    $end            reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    VARNAME         reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    COMMENT         reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    IF              reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    FOR             reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    WHILE           reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    SWITCH          reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    INT             reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    SHORT           reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    LONG            reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    FLOAT           reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    DOUBLE          reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    RCURL_BRACE     reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    BREAK           reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    CONTINUE        reduce using rule 62 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)


state 192

    (60) FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .

    $end            reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    VARNAME         reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    COMMENT         reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    IF              reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    FOR             reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    WHILE           reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    SWITCH          reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    INT             reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    SHORT           reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    LONG            reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    FLOAT           reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    DOUBLE          reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    RCURL_BRACE     reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    BREAK           reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    CONTINUE        reduce using rule 60 (FOR_STRUCTURE -> FOR LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (ROOT -> DEFINE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> DEFINE) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (ROOT -> INCLUDE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> INCLUDE) in state 4
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (VALUE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (VALUE -> NUMBER)
WARNING: rejected rule (SENTENCE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (SENTENCE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (ROOT -> CONTROL_STRUCTURES)
WARNING: rejected rule (EXPRESSION -> CONTROL_STRUCTURES) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (ROOT -> WHILE_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> WHILE_STRUCTURE) in state 8
WARNING: reduce/reduce conflict in state 9 resolved using rule (ROOT -> SWITCH_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> SWITCH_STRUCTURE) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (ROOT -> IF_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> IF_STRUCTURE) in state 10
WARNING: reduce/reduce conflict in state 11 resolved using rule (ROOT -> FOR_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> FOR_STRUCTURE) in state 11
WARNING: reduce/reduce conflict in state 13 resolved using rule (ROOT -> EXPRESSION)
WARNING: rejected rule (EXPRESSIONS -> EXPRESSION) in state 13
WARNING: reduce/reduce conflict in state 15 resolved using rule (ROOT -> FUNCTION)
WARNING: rejected rule (CODE -> FUNCTION) in state 15
WARNING: reduce/reduce conflict in state 18 resolved using rule (ROOT -> INTEGER_DECLARATION)
WARNING: rejected rule (CODE -> INTEGER_DECLARATION) in state 18
WARNING: reduce/reduce conflict in state 18 resolved using rule (ROOT -> INTEGER_DECLARATION)
WARNING: rejected rule (DECLARATIONS -> INTEGER_DECLARATION) in state 18
WARNING: reduce/reduce conflict in state 19 resolved using rule (ROOT -> DECIMAL_DECLARATION)
WARNING: rejected rule (CODE -> DECIMAL_DECLARATION) in state 19
WARNING: reduce/reduce conflict in state 19 resolved using rule (ROOT -> DECIMAL_DECLARATION)
WARNING: rejected rule (DECLARATIONS -> DECIMAL_DECLARATION) in state 19
WARNING: reduce/reduce conflict in state 20 resolved using rule (ROOT -> ASSIGNMENT_DECLARATION)
WARNING: rejected rule (CODE -> ASSIGNMENT_DECLARATION) in state 20
WARNING: reduce/reduce conflict in state 22 resolved using rule (ROOT -> COMENTARIOLEX)
WARNING: rejected rule (CODE -> COMENTARIOLEX) in state 22
WARNING: reduce/reduce conflict in state 25 resolved using rule (ROOT -> OPERATION)
WARNING: rejected rule (OPERATIONS -> OPERATION) in state 25
WARNING: reduce/reduce conflict in state 28 resolved using rule (ROOT -> COMPARISON)
WARNING: rejected rule (COMPARISONS -> COMPARISON) in state 28
WARNING: reduce/reduce conflict in state 29 resolved using rule (ROOT -> COMPARISONS)
WARNING: rejected rule (FUNCTION_ARGUMENTS -> COMPARISONS) in state 29
WARNING: reduce/reduce conflict in state 31 resolved using rule (ROOT -> SENTENCE)
WARNING: rejected rule (SENTENCES -> SENTENCE) in state 31
WARNING: reduce/reduce conflict in state 46 resolved using rule (VARIABLELEX -> VARNAME)
WARNING: rejected rule (SENTENCE -> VARNAME) in state 46
WARNING: reduce/reduce conflict in state 139 resolved using rule (VALUE -> NUMBER)
WARNING: rejected rule (SENTENCE -> NUMBER) in state 139
WARNING: reduce/reduce conflict in state 155 resolved using rule (VALUE -> NUMBER)
WARNING: rejected rule (SENTENCE -> NUMBER) in state 155
WARNING: Rule (PREPROCESOR_DIRECTIVE -> DEFINE) is never reduced
WARNING: Rule (PREPROCESOR_DIRECTIVE -> INCLUDE) is never reduced
