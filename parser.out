Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AUTO
    BACKSLASH
    BACKSPACE
    B_AND
    B_COMPLEMENT
    B_OR
    B_XOR
    CHAR
    CONST
    DO
    DOT
    DOUBLE_APOS
    DOUBLE_QUOTE
    ENUM
    EXTERN
    FF_PAGEBREAK
    FS_CHAR
    FS_DOUBLE
    FS_FLOAT
    FS_HEX
    FS_INT
    FS_LONG
    FS_LONG_DOUBLE
    FS_OCT
    FS_OCT_LONG
    FS_POINTER
    FS_SCI_NOTATION
    FS_STRING
    FS_UNSIGNED_INT
    FS_UNSIGNED_LONG
    GOTO
    HTAB
    IGNORE
    LBRACKET
    NEWLINE
    NULL
    PP_DATE
    PP_DTMACRO
    PP_ERROR
    PP_FILE
    PP_IF
    PP_IFDEF
    PP_IFNDEF
    PP_LINE
    PP_PRAGMA
    PP_STMACRO
    PP_TIME
    PP_TIMESTAMP
    PP_UNDEF
    QUESTIONMARK
    RBRACKET
    REGISTER
    SHIFT_LEFT
    SHIFT_RIGHT
    SIGNED
    SINGLE_APOS
    SINGLE_QUOTE
    SIZEOF
    STATIC
    STRUCT
    TILDE
    TYPEDEF
    UNION
    UNSIGNED
    VOLTILE
    VTAB

Grammar

Rule 0     S' -> ROOT
Rule 1     ROOT -> PREPROCESOR_DIRECTIVE
Rule 2     ROOT -> DEFINE
Rule 3     ROOT -> INCLUDE
Rule 4     ROOT -> VALUE
Rule 5     ROOT -> NUMBER
Rule 6     ROOT -> CONTROL_STRUCTURES
Rule 7     ROOT -> WHILE_STRUCTURE
Rule 8     ROOT -> SWITCH_STRUCTURE
Rule 9     ROOT -> IF_STRUCTURE
Rule 10    ROOT -> FOR_STRUCTURE
Rule 11    ROOT -> CODE
Rule 12    ROOT -> EXPRESSION
Rule 13    ROOT -> EXPRESSIONS
Rule 14    ROOT -> FUNCTION
Rule 15    ROOT -> INTEGER_TYPE
Rule 16    ROOT -> DECIMAL_TYPE
Rule 17    ROOT -> INTEGER_DECLARATION
Rule 18    ROOT -> DECIMAL_DECLARATION
Rule 19    ROOT -> ASSIGNMENT_DECLARATION
Rule 20    ROOT -> ASSIGNMENT_OPERATOR
Rule 21    ROOT -> COMENTARIOLEX
Rule 22    ROOT -> VARIABLELEX
Rule 23    ROOT -> OPERATOR
Rule 24    ROOT -> OPERATION
Rule 25    ROOT -> OPERATIONS
Rule 26    ROOT -> COMPARISON_OPERATOR
Rule 27    ROOT -> COMPARISON
Rule 28    ROOT -> COMPARISONS
Rule 29    ROOT -> LOGICAL_OPERATOR
Rule 30    ROOT -> STATEMENT
Rule 31    ROOT -> SWITCH_BODY
Rule 32    ROOT -> BUCLE
Rule 33    ROOT -> ELSE_STRUCTURE
Rule 34    ROOT -> FUNCTION_ARGUMENTS
Rule 35    ROOT -> DECLARATIONS
Rule 36    ROOT -> FOR_BODY_STRUCTURE
Rule 37    ROOT -> FOR_ARGUMENTS_STRUCTURE
Rule 38    PREPROCESOR_DIRECTIVE -> DEFINE
Rule 39    PREPROCESOR_DIRECTIVE -> INCLUDE
Rule 40    DEFINE -> PP_DEFINE VARIABLELEX VALUE
Rule 41    INCLUDE -> PP_INCLUDE HEADER_LIB
Rule 42    VALUE -> NUMBER
Rule 43    VALUE -> STRING
Rule 44    VALUE -> CHARACTER
Rule 45    NUMBER -> INTEGER
Rule 46    NUMBER -> DECIMAL
Rule 47    CONTROL_STRUCTURES -> IF_STRUCTURE
Rule 48    CONTROL_STRUCTURES -> FOR_STRUCTURE
Rule 49    CONTROL_STRUCTURES -> WHILE_STRUCTURE
Rule 50    CONTROL_STRUCTURES -> SWITCH_STRUCTURE
Rule 51    BODY_STRUCTURE -> EXPRESSIONS
Rule 52    BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON
Rule 53    BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON
Rule 54    WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
Rule 55    SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
Rule 56    SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON
Rule 57    SWITCH_BODY -> SWITCH_CASE
Rule 58    SWITCH_BODY -> SWITCH_DEFAULT
Rule 59    SWITCH_BODY -> SWITCH_CASE SWITCH_BODY
Rule 60    SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
Rule 61    BUCLE -> VARIABLELEX INCREASE
Rule 62    BUCLE -> DECREASE VARIABLELEX
Rule 63    FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
Rule 64    FOR_ARGUMENTS_STRUCTURE -> LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
Rule 65    FOR_BODY_STRUCTURE -> EXPRESSIONS
Rule 66    FOR_BODY_STRUCTURE -> BREAK SEMICOLON
Rule 67    FOR_BODY_STRUCTURE -> CONTINUE SEMICOLON
Rule 68    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 69    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
Rule 70    ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 71    ELSE_STRUCTURE -> ELSE IF_STRUCTURE
Rule 72    DECLARATIONS -> INTEGER_DECLARATION
Rule 73    DECLARATIONS -> DECIMAL_DECLARATION
Rule 74    CODE -> FUNCTION
Rule 75    CODE -> INTEGER_DECLARATION
Rule 76    CODE -> DECIMAL_DECLARATION
Rule 77    CODE -> ASSIGNMENT_DECLARATION
Rule 78    CODE -> COMENTARIOLEX
Rule 79    EXPRESSION -> CODE SEMICOLON
Rule 80    EXPRESSION -> CONTROL_STRUCTURES
Rule 81    EXPRESSIONS -> EXPRESSION
Rule 82    EXPRESSIONS -> EXPRESSION EXPRESSIONS
Rule 83    FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
Rule 84    FUNCTION_ARGUMENTS -> STATEMENTS
Rule 85    FUNCTION_ARGUMENTS -> COMPARISONS
Rule 86    INTEGER_TYPE -> INT
Rule 87    INTEGER_TYPE -> SHORT
Rule 88    INTEGER_TYPE -> LONG
Rule 89    DECIMAL_TYPE -> FLOAT
Rule 90    DECIMAL_TYPE -> DOUBLE
Rule 91    INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER
Rule 92    DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL
Rule 93    ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR STATEMENT
Rule 94    ASSIGNMENT_OPERATOR -> EQUAL
Rule 95    ASSIGNMENT_OPERATOR -> PLUS_EQUAL
Rule 96    ASSIGNMENT_OPERATOR -> MINUS_EQUAL
Rule 97    ASSIGNMENT_OPERATOR -> DIV_EQUAL
Rule 98    ASSIGNMENT_OPERATOR -> TIMES_EQUAL
Rule 99    ASSIGNMENT_OPERATOR -> MOD_EQUAL
Rule 100   ASSIGNMENT_OPERATOR -> AND_EQUAL
Rule 101   ASSIGNMENT_OPERATOR -> OR_EQUAL
Rule 102   ASSIGNMENT_OPERATOR -> XOR_EQUAL
Rule 103   ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL
Rule 104   ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL
Rule 105   ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL
Rule 106   COMENTARIOLEX -> COMMENT
Rule 107   VARIABLELEX -> VARNAME
Rule 108   OPERATOR -> PLUS
Rule 109   OPERATOR -> MINUS
Rule 110   OPERATOR -> TIMES
Rule 111   OPERATOR -> MODULUS
Rule 112   OPERATOR -> DIVIDE
Rule 113   OPERATION -> NUMBER OPERATOR NUMBER
Rule 114   OPERATIONS -> OPERATION
Rule 115   OPERATIONS -> OPERATION OPERATOR OPERATIONS
Rule 116   COMPARISON_OPERATOR -> EQUAL_TO
Rule 117   COMPARISON_OPERATOR -> NOT_EQUAL
Rule 118   COMPARISON_OPERATOR -> GREATER_THAN
Rule 119   COMPARISON_OPERATOR -> LESS_THAN
Rule 120   COMPARISON_OPERATOR -> GREATER_EQUAL
Rule 121   COMPARISON_OPERATOR -> LESS_EQUAL
Rule 122   COMPARISON -> VALUE COMPARISON_OPERATOR VALUE
Rule 123   COMPARISON -> STATEMENT COMPARISON_OPERATOR STATEMENT
Rule 124   COMPARISONS -> COMPARISON
Rule 125   COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS
Rule 126   LOGICAL_OPERATOR -> AND
Rule 127   LOGICAL_OPERATOR -> OR
Rule 128   LOGICAL_OPERATOR -> NOT
Rule 129   STATEMENT -> NUMBER
Rule 130   STATEMENT -> VARNAME
Rule 131   STATEMENTS -> STATEMENT
Rule 132   STATEMENTS -> STATEMENT COMMA STATEMENTS
Rule 133   VALUES -> VALUE
Rule 134   VALUES -> VALUE COMMA VALUES
Rule 135   RETURN_TYPE -> INTEGER_TYPE
Rule 136   RETURN_TYPE -> DECIMAL_TYPE
Rule 137   RETURN_TYPE -> VOID
Rule 138   RETURN_STATEMENT -> RETURN PARAMETERS SEMICOLON
Rule 139   RETURN_STATEMENT -> RETURN VALUES SEMICOLON
Rule 140   PARAMETERS -> VARNAME
Rule 141   PARAMETERS -> VARNAME COMMA PARAMETERS
Rule 142   FUNCTION_PROTOTYPE -> RETURN_TYPE VARNAME LPAREN RPAREN LCURL_BRACE EXPRESSIONS RETURN_STATEMENT RCURL_BRACE
Rule 143   FUNCTION_PROTOTYPE -> RETURN_TYPE VARNAME LPAREN PARAMETERS RPAREN LCURL_BRACE EXPRESSIONS RETURN_STATEMENT RCURL_BRACE

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 126
AND_EQUAL            : 100
AUTO                 : 
BACKSLASH            : 
BACKSPACE            : 
BREAK                : 52 55 56 66
B_AND                : 
B_COMPLEMENT         : 
B_OR                 : 
B_XOR                : 
CASE                 : 55
CHAR                 : 
CHARACTER            : 44
COLON                : 55 56
COMMA                : 132 134 141
COMMENT              : 106
COMPLEMENT_EQUAL     : 103
CONST                : 
CONTINUE             : 53 67
DECIMAL              : 46 92
DECREASE             : 62
DEFAULT              : 56
DIVIDE               : 112
DIV_EQUAL            : 97
DO                   : 
DOT                  : 
DOUBLE               : 90
DOUBLE_APOS          : 
DOUBLE_QUOTE         : 
ELSE                 : 70 71
ENUM                 : 
EQUAL                : 91 92 94
EQUAL_TO             : 116
EXTERN               : 
FF_PAGEBREAK         : 
FLOAT                : 89
FOR                  : 63
FS_CHAR              : 
FS_DOUBLE            : 
FS_FLOAT             : 
FS_HEX               : 
FS_INT               : 
FS_LONG              : 
FS_LONG_DOUBLE       : 
FS_OCT               : 
FS_OCT_LONG          : 
FS_POINTER           : 
FS_SCI_NOTATION      : 
FS_STRING            : 
FS_UNSIGNED_INT      : 
FS_UNSIGNED_LONG     : 
GOTO                 : 
GREATER_EQUAL        : 120
GREATER_THAN         : 118
HEADER_LIB           : 41
HTAB                 : 
IF                   : 68 69
IGNORE               : 
INCREASE             : 61
INT                  : 86
INTEGER              : 45 55 91
LBRACKET             : 
LCURL_BRACE          : 54 60 63 68 69 70 142 143
LESS_EQUAL           : 121
LESS_THAN            : 119
LONG                 : 88
LPAREN               : 54 60 64 68 69 83 142 143
MINUS                : 109
MINUS_EQUAL          : 96
MODULUS              : 111
MOD_EQUAL            : 99
NEWLINE              : 
NOT                  : 128
NOT_EQUAL            : 117
NULL                 : 
OR                   : 127
OR_EQUAL             : 101
PLUS                 : 108
PLUS_EQUAL           : 95
PP_DATE              : 
PP_DEFINE            : 40
PP_DTMACRO           : 
PP_ERROR             : 
PP_FILE              : 
PP_IF                : 
PP_IFDEF             : 
PP_IFNDEF            : 
PP_INCLUDE           : 41
PP_LINE              : 
PP_PRAGMA            : 
PP_STMACRO           : 
PP_TIME              : 
PP_TIMESTAMP         : 
PP_UNDEF             : 
QUESTIONMARK         : 
RBRACKET             : 
RCURL_BRACE          : 54 60 63 68 69 70 142 143
REGISTER             : 
RETURN               : 138 139
RPAREN               : 54 60 64 68 69 83 142 143
SEMICOLON            : 52 53 55 56 64 64 66 67 79 138 139
SHIFTL_EQUAL         : 104
SHIFTR_EQUAL         : 105
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
SHORT                : 87
SIGNED               : 
SINGLE_APOS          : 
SINGLE_QUOTE         : 
SIZEOF               : 
STATIC               : 
STRING               : 43
STRUCT               : 
SWITCH               : 60
TILDE                : 
TIMES                : 110
TIMES_EQUAL          : 98
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VARNAME              : 83 91 92 93 107 130 140 141 142 143
VOID                 : 137
VOLTILE              : 
VTAB                 : 
WHILE                : 54
XOR_EQUAL            : 102
error                : 

Nonterminals, with rules where they appear

ASSIGNMENT_DECLARATION : 19 77
ASSIGNMENT_OPERATOR  : 20 93
BODY_STRUCTURE       : 54
BUCLE                : 32 64
CODE                 : 11 79
COMENTARIOLEX        : 21 78
COMPARISON           : 27 124 125
COMPARISONS          : 28 54 60 64 68 69 85 125
COMPARISON_OPERATOR  : 26 122 123
CONTROL_STRUCTURES   : 6 80
DECIMAL_DECLARATION  : 18 73 76
DECIMAL_TYPE         : 16 92 136
DECLARATIONS         : 35 64
DEFINE               : 2 38
ELSE_STRUCTURE       : 33 69
EXPRESSION           : 12 81 82
EXPRESSIONS          : 13 51 52 53 55 56 65 68 69 70 82 142 143
FOR_ARGUMENTS_STRUCTURE : 37 63
FOR_BODY_STRUCTURE   : 36 63
FOR_STRUCTURE        : 10 48
FUNCTION             : 14 74
FUNCTION_ARGUMENTS   : 34 83
FUNCTION_PROTOTYPE   : 
IF_STRUCTURE         : 9 47 71
INCLUDE              : 3 39
INTEGER_DECLARATION  : 17 72 75
INTEGER_TYPE         : 15 91 135
LOGICAL_OPERATOR     : 29 125
NUMBER               : 5 42 113 113 129
OPERATION            : 24 114 115
OPERATIONS           : 25 115
OPERATOR             : 23 113 115
PARAMETERS           : 138 141 143
PREPROCESOR_DIRECTIVE : 1
RETURN_STATEMENT     : 142 143
RETURN_TYPE          : 142 143
ROOT                 : 0
STATEMENT            : 30 93 123 123 131 132
STATEMENTS           : 84 132
SWITCH_BODY          : 31 59 60
SWITCH_CASE          : 57 59
SWITCH_DEFAULT       : 58
SWITCH_STRUCTURE     : 8 50
VALUE                : 4 40 122 122 133 134
VALUES               : 134 139
VARIABLELEX          : 22 40 61 62
WHILE_STRUCTURE      : 7 49

Parsing method: LALR

state 0

    (0) S' -> . ROOT
    (1) ROOT -> . PREPROCESOR_DIRECTIVE
    (2) ROOT -> . DEFINE
    (3) ROOT -> . INCLUDE
    (4) ROOT -> . VALUE
    (5) ROOT -> . NUMBER
    (6) ROOT -> . CONTROL_STRUCTURES
    (7) ROOT -> . WHILE_STRUCTURE
    (8) ROOT -> . SWITCH_STRUCTURE
    (9) ROOT -> . IF_STRUCTURE
    (10) ROOT -> . FOR_STRUCTURE
    (11) ROOT -> . CODE
    (12) ROOT -> . EXPRESSION
    (13) ROOT -> . EXPRESSIONS
    (14) ROOT -> . FUNCTION
    (15) ROOT -> . INTEGER_TYPE
    (16) ROOT -> . DECIMAL_TYPE
    (17) ROOT -> . INTEGER_DECLARATION
    (18) ROOT -> . DECIMAL_DECLARATION
    (19) ROOT -> . ASSIGNMENT_DECLARATION
    (20) ROOT -> . ASSIGNMENT_OPERATOR
    (21) ROOT -> . COMENTARIOLEX
    (22) ROOT -> . VARIABLELEX
    (23) ROOT -> . OPERATOR
    (24) ROOT -> . OPERATION
    (25) ROOT -> . OPERATIONS
    (26) ROOT -> . COMPARISON_OPERATOR
    (27) ROOT -> . COMPARISON
    (28) ROOT -> . COMPARISONS
    (29) ROOT -> . LOGICAL_OPERATOR
    (30) ROOT -> . STATEMENT
    (31) ROOT -> . SWITCH_BODY
    (32) ROOT -> . BUCLE
    (33) ROOT -> . ELSE_STRUCTURE
    (34) ROOT -> . FUNCTION_ARGUMENTS
    (35) ROOT -> . DECLARATIONS
    (36) ROOT -> . FOR_BODY_STRUCTURE
    (37) ROOT -> . FOR_ARGUMENTS_STRUCTURE
    (38) PREPROCESOR_DIRECTIVE -> . DEFINE
    (39) PREPROCESOR_DIRECTIVE -> . INCLUDE
    (40) DEFINE -> . PP_DEFINE VARIABLELEX VALUE
    (41) INCLUDE -> . PP_INCLUDE HEADER_LIB
    (42) VALUE -> . NUMBER
    (43) VALUE -> . STRING
    (44) VALUE -> . CHARACTER
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL
    (47) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (48) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (49) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (50) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (54) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (60) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (63) FOR_STRUCTURE -> . FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (74) CODE -> . FUNCTION
    (75) CODE -> . INTEGER_DECLARATION
    (76) CODE -> . DECIMAL_DECLARATION
    (77) CODE -> . ASSIGNMENT_DECLARATION
    (78) CODE -> . COMENTARIOLEX
    (79) EXPRESSION -> . CODE SEMICOLON
    (80) EXPRESSION -> . CONTROL_STRUCTURES
    (81) EXPRESSIONS -> . EXPRESSION
    (82) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (83) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (93) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR STATEMENT
    (94) ASSIGNMENT_OPERATOR -> . EQUAL
    (95) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (96) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (97) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (98) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (99) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (100) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (101) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (102) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (103) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (104) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (105) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL
    (106) COMENTARIOLEX -> . COMMENT
    (107) VARIABLELEX -> . VARNAME
    (108) OPERATOR -> . PLUS
    (109) OPERATOR -> . MINUS
    (110) OPERATOR -> . TIMES
    (111) OPERATOR -> . MODULUS
    (112) OPERATOR -> . DIVIDE
    (113) OPERATION -> . NUMBER OPERATOR NUMBER
    (114) OPERATIONS -> . OPERATION
    (115) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (116) COMPARISON_OPERATOR -> . EQUAL_TO
    (117) COMPARISON_OPERATOR -> . NOT_EQUAL
    (118) COMPARISON_OPERATOR -> . GREATER_THAN
    (119) COMPARISON_OPERATOR -> . LESS_THAN
    (120) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (121) COMPARISON_OPERATOR -> . LESS_EQUAL
    (122) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (123) COMPARISON -> . STATEMENT COMPARISON_OPERATOR STATEMENT
    (124) COMPARISONS -> . COMPARISON
    (125) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (126) LOGICAL_OPERATOR -> . AND
    (127) LOGICAL_OPERATOR -> . OR
    (128) LOGICAL_OPERATOR -> . NOT
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (57) SWITCH_BODY -> . SWITCH_CASE
    (58) SWITCH_BODY -> . SWITCH_DEFAULT
    (59) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (61) BUCLE -> . VARIABLELEX INCREASE
    (62) BUCLE -> . DECREASE VARIABLELEX
    (70) ELSE_STRUCTURE -> . ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (71) ELSE_STRUCTURE -> . ELSE IF_STRUCTURE
    (84) FUNCTION_ARGUMENTS -> . STATEMENTS
    (85) FUNCTION_ARGUMENTS -> . COMPARISONS
    (72) DECLARATIONS -> . INTEGER_DECLARATION
    (73) DECLARATIONS -> . DECIMAL_DECLARATION
    (65) FOR_BODY_STRUCTURE -> . EXPRESSIONS
    (66) FOR_BODY_STRUCTURE -> . BREAK SEMICOLON
    (67) FOR_BODY_STRUCTURE -> . CONTINUE SEMICOLON
    (64) FOR_ARGUMENTS_STRUCTURE -> . LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (55) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (56) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON
    (131) STATEMENTS -> . STATEMENT
    (132) STATEMENTS -> . STATEMENT COMMA STATEMENTS

    PP_DEFINE       shift and go to state 39
    PP_INCLUDE      shift and go to state 40
    STRING          shift and go to state 41
    CHARACTER       shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    WHILE           shift and go to state 45
    SWITCH          shift and go to state 47
    IF              shift and go to state 48
    FOR             shift and go to state 49
    VARNAME         shift and go to state 50
    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55
    EQUAL           shift and go to state 56
    PLUS_EQUAL      shift and go to state 57
    MINUS_EQUAL     shift and go to state 58
    DIV_EQUAL       shift and go to state 59
    TIMES_EQUAL     shift and go to state 60
    MOD_EQUAL       shift and go to state 61
    AND_EQUAL       shift and go to state 62
    OR_EQUAL        shift and go to state 63
    XOR_EQUAL       shift and go to state 64
    COMPLEMENT_EQUAL shift and go to state 65
    SHIFTL_EQUAL    shift and go to state 66
    SHIFTR_EQUAL    shift and go to state 67
    COMMENT         shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    MODULUS         shift and go to state 72
    DIVIDE          shift and go to state 73
    EQUAL_TO        shift and go to state 74
    NOT_EQUAL       shift and go to state 75
    GREATER_THAN    shift and go to state 76
    LESS_THAN       shift and go to state 77
    GREATER_EQUAL   shift and go to state 78
    LESS_EQUAL      shift and go to state 79
    AND             shift and go to state 80
    OR              shift and go to state 81
    NOT             shift and go to state 82
    DECREASE        shift and go to state 85
    ELSE            shift and go to state 86
    BREAK           shift and go to state 88
    CONTINUE        shift and go to state 89
    LPAREN          shift and go to state 46
    CASE            shift and go to state 90
    DEFAULT         shift and go to state 91

    ROOT                           shift and go to state 1
    PREPROCESOR_DIRECTIVE          shift and go to state 2
    DEFINE                         shift and go to state 3
    INCLUDE                        shift and go to state 4
    VALUE                          shift and go to state 5
    NUMBER                         shift and go to state 6
    CONTROL_STRUCTURES             shift and go to state 7
    WHILE_STRUCTURE                shift and go to state 8
    SWITCH_STRUCTURE               shift and go to state 9
    IF_STRUCTURE                   shift and go to state 10
    FOR_STRUCTURE                  shift and go to state 11
    CODE                           shift and go to state 12
    EXPRESSION                     shift and go to state 13
    EXPRESSIONS                    shift and go to state 14
    FUNCTION                       shift and go to state 15
    INTEGER_TYPE                   shift and go to state 16
    DECIMAL_TYPE                   shift and go to state 17
    INTEGER_DECLARATION            shift and go to state 18
    DECIMAL_DECLARATION            shift and go to state 19
    ASSIGNMENT_DECLARATION         shift and go to state 20
    ASSIGNMENT_OPERATOR            shift and go to state 21
    COMENTARIOLEX                  shift and go to state 22
    VARIABLELEX                    shift and go to state 23
    OPERATOR                       shift and go to state 24
    OPERATION                      shift and go to state 25
    OPERATIONS                     shift and go to state 26
    COMPARISON_OPERATOR            shift and go to state 27
    COMPARISON                     shift and go to state 28
    COMPARISONS                    shift and go to state 29
    LOGICAL_OPERATOR               shift and go to state 30
    STATEMENT                      shift and go to state 31
    SWITCH_BODY                    shift and go to state 32
    BUCLE                          shift and go to state 33
    ELSE_STRUCTURE                 shift and go to state 34
    FUNCTION_ARGUMENTS             shift and go to state 35
    DECLARATIONS                   shift and go to state 36
    FOR_BODY_STRUCTURE             shift and go to state 37
    FOR_ARGUMENTS_STRUCTURE        shift and go to state 38
    SWITCH_CASE                    shift and go to state 83
    SWITCH_DEFAULT                 shift and go to state 84
    STATEMENTS                     shift and go to state 87

state 1

    (0) S' -> ROOT .



state 2

    (1) ROOT -> PREPROCESOR_DIRECTIVE .

    $end            reduce using rule 1 (ROOT -> PREPROCESOR_DIRECTIVE .)


state 3

    (2) ROOT -> DEFINE .
    (38) PREPROCESOR_DIRECTIVE -> DEFINE .

  ! reduce/reduce conflict for $end resolved using rule 2 (ROOT -> DEFINE .)
    $end            reduce using rule 2 (ROOT -> DEFINE .)

  ! $end            [ reduce using rule 38 (PREPROCESOR_DIRECTIVE -> DEFINE .) ]


state 4

    (3) ROOT -> INCLUDE .
    (39) PREPROCESOR_DIRECTIVE -> INCLUDE .

  ! reduce/reduce conflict for $end resolved using rule 3 (ROOT -> INCLUDE .)
    $end            reduce using rule 3 (ROOT -> INCLUDE .)

  ! $end            [ reduce using rule 39 (PREPROCESOR_DIRECTIVE -> INCLUDE .) ]


state 5

    (4) ROOT -> VALUE .
    (122) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (116) COMPARISON_OPERATOR -> . EQUAL_TO
    (117) COMPARISON_OPERATOR -> . NOT_EQUAL
    (118) COMPARISON_OPERATOR -> . GREATER_THAN
    (119) COMPARISON_OPERATOR -> . LESS_THAN
    (120) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (121) COMPARISON_OPERATOR -> . LESS_EQUAL

    $end            reduce using rule 4 (ROOT -> VALUE .)
    EQUAL_TO        shift and go to state 74
    NOT_EQUAL       shift and go to state 75
    GREATER_THAN    shift and go to state 76
    LESS_THAN       shift and go to state 77
    GREATER_EQUAL   shift and go to state 78
    LESS_EQUAL      shift and go to state 79

    COMPARISON_OPERATOR            shift and go to state 92

state 6

    (5) ROOT -> NUMBER .
    (42) VALUE -> NUMBER .
    (113) OPERATION -> NUMBER . OPERATOR NUMBER
    (129) STATEMENT -> NUMBER .
    (108) OPERATOR -> . PLUS
    (109) OPERATOR -> . MINUS
    (110) OPERATOR -> . TIMES
    (111) OPERATOR -> . MODULUS
    (112) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
    $end            reduce using rule 5 (ROOT -> NUMBER .)
    EQUAL_TO        reduce using rule 42 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 42 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 42 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 42 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 42 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 42 (VALUE -> NUMBER .)
    COMMA           reduce using rule 129 (STATEMENT -> NUMBER .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    MODULUS         shift and go to state 72
    DIVIDE          shift and go to state 73

  ! $end            [ reduce using rule 42 (VALUE -> NUMBER .) ]
  ! EQUAL_TO        [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! GREATER_THAN    [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! LESS_THAN       [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! GREATER_EQUAL   [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! LESS_EQUAL      [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! $end            [ reduce using rule 129 (STATEMENT -> NUMBER .) ]

    OPERATOR                       shift and go to state 93

state 7

    (6) ROOT -> CONTROL_STRUCTURES .
    (80) EXPRESSION -> CONTROL_STRUCTURES .

  ! reduce/reduce conflict for $end resolved using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    $end            reduce using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    VARNAME         reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    FOR             reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)

  ! $end            [ reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .) ]


state 8

    (7) ROOT -> WHILE_STRUCTURE .
    (49) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 7 (ROOT -> WHILE_STRUCTURE .)
    $end            reduce using rule 7 (ROOT -> WHILE_STRUCTURE .)
    VARNAME         reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FOR             reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)

  ! $end            [ reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .) ]


state 9

    (8) ROOT -> SWITCH_STRUCTURE .
    (50) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    $end            reduce using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    VARNAME         reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FOR             reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)

  ! $end            [ reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .) ]


state 10

    (9) ROOT -> IF_STRUCTURE .
    (47) CONTROL_STRUCTURES -> IF_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 9 (ROOT -> IF_STRUCTURE .)
    $end            reduce using rule 9 (ROOT -> IF_STRUCTURE .)
    VARNAME         reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FOR             reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)

  ! $end            [ reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .) ]


state 11

    (10) ROOT -> FOR_STRUCTURE .
    (48) CONTROL_STRUCTURES -> FOR_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 10 (ROOT -> FOR_STRUCTURE .)
    $end            reduce using rule 10 (ROOT -> FOR_STRUCTURE .)
    VARNAME         reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FOR             reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)

  ! $end            [ reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .) ]


state 12

    (11) ROOT -> CODE .
    (79) EXPRESSION -> CODE . SEMICOLON

    $end            reduce using rule 11 (ROOT -> CODE .)
    SEMICOLON       shift and go to state 94


state 13

    (12) ROOT -> EXPRESSION .
    (81) EXPRESSIONS -> EXPRESSION .
    (82) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (81) EXPRESSIONS -> . EXPRESSION
    (82) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (79) EXPRESSION -> . CODE SEMICOLON
    (80) EXPRESSION -> . CONTROL_STRUCTURES
    (74) CODE -> . FUNCTION
    (75) CODE -> . INTEGER_DECLARATION
    (76) CODE -> . DECIMAL_DECLARATION
    (77) CODE -> . ASSIGNMENT_DECLARATION
    (78) CODE -> . COMENTARIOLEX
    (47) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (48) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (49) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (50) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (83) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (93) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR STATEMENT
    (106) COMENTARIOLEX -> . COMMENT
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (63) FOR_STRUCTURE -> . FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (54) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (60) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE

  ! reduce/reduce conflict for $end resolved using rule 12 (ROOT -> EXPRESSION .)
    $end            reduce using rule 12 (ROOT -> EXPRESSION .)
    VARNAME         shift and go to state 108
    COMMENT         shift and go to state 68
    IF              shift and go to state 48
    FOR             shift and go to state 49
    WHILE           shift and go to state 45
    SWITCH          shift and go to state 47
    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55

  ! $end            [ reduce using rule 81 (EXPRESSIONS -> EXPRESSION .) ]

    EXPRESSION                     shift and go to state 95
    EXPRESSIONS                    shift and go to state 96
    CODE                           shift and go to state 97
    CONTROL_STRUCTURES             shift and go to state 98
    FUNCTION                       shift and go to state 99
    INTEGER_DECLARATION            shift and go to state 100
    DECIMAL_DECLARATION            shift and go to state 101
    ASSIGNMENT_DECLARATION         shift and go to state 102
    COMENTARIOLEX                  shift and go to state 103
    IF_STRUCTURE                   shift and go to state 104
    FOR_STRUCTURE                  shift and go to state 105
    WHILE_STRUCTURE                shift and go to state 106
    SWITCH_STRUCTURE               shift and go to state 107
    INTEGER_TYPE                   shift and go to state 109
    DECIMAL_TYPE                   shift and go to state 110

state 14

    (13) ROOT -> EXPRESSIONS .
    (65) FOR_BODY_STRUCTURE -> EXPRESSIONS .

  ! reduce/reduce conflict for $end resolved using rule 13 (ROOT -> EXPRESSIONS .)
    $end            reduce using rule 13 (ROOT -> EXPRESSIONS .)

  ! $end            [ reduce using rule 65 (FOR_BODY_STRUCTURE -> EXPRESSIONS .) ]


state 15

    (14) ROOT -> FUNCTION .
    (74) CODE -> FUNCTION .

  ! reduce/reduce conflict for $end resolved using rule 14 (ROOT -> FUNCTION .)
    $end            reduce using rule 14 (ROOT -> FUNCTION .)
    SEMICOLON       reduce using rule 74 (CODE -> FUNCTION .)

  ! $end            [ reduce using rule 74 (CODE -> FUNCTION .) ]


state 16

    (15) ROOT -> INTEGER_TYPE .
    (91) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    $end            reduce using rule 15 (ROOT -> INTEGER_TYPE .)
    VARNAME         shift and go to state 111


state 17

    (16) ROOT -> DECIMAL_TYPE .
    (92) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    $end            reduce using rule 16 (ROOT -> DECIMAL_TYPE .)
    VARNAME         shift and go to state 112


state 18

    (17) ROOT -> INTEGER_DECLARATION .
    (75) CODE -> INTEGER_DECLARATION .
    (72) DECLARATIONS -> INTEGER_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 17 (ROOT -> INTEGER_DECLARATION .)
  ! reduce/reduce conflict for $end resolved using rule 17 (ROOT -> INTEGER_DECLARATION .)
    $end            reduce using rule 17 (ROOT -> INTEGER_DECLARATION .)
    SEMICOLON       reduce using rule 75 (CODE -> INTEGER_DECLARATION .)

  ! $end            [ reduce using rule 75 (CODE -> INTEGER_DECLARATION .) ]
  ! $end            [ reduce using rule 72 (DECLARATIONS -> INTEGER_DECLARATION .) ]


state 19

    (18) ROOT -> DECIMAL_DECLARATION .
    (76) CODE -> DECIMAL_DECLARATION .
    (73) DECLARATIONS -> DECIMAL_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 18 (ROOT -> DECIMAL_DECLARATION .)
  ! reduce/reduce conflict for $end resolved using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    $end            reduce using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    SEMICOLON       reduce using rule 76 (CODE -> DECIMAL_DECLARATION .)

  ! $end            [ reduce using rule 76 (CODE -> DECIMAL_DECLARATION .) ]
  ! $end            [ reduce using rule 73 (DECLARATIONS -> DECIMAL_DECLARATION .) ]


state 20

    (19) ROOT -> ASSIGNMENT_DECLARATION .
    (77) CODE -> ASSIGNMENT_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    $end            reduce using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    SEMICOLON       reduce using rule 77 (CODE -> ASSIGNMENT_DECLARATION .)

  ! $end            [ reduce using rule 77 (CODE -> ASSIGNMENT_DECLARATION .) ]


state 21

    (20) ROOT -> ASSIGNMENT_OPERATOR .

    $end            reduce using rule 20 (ROOT -> ASSIGNMENT_OPERATOR .)


state 22

    (21) ROOT -> COMENTARIOLEX .
    (78) CODE -> COMENTARIOLEX .

  ! reduce/reduce conflict for $end resolved using rule 21 (ROOT -> COMENTARIOLEX .)
    $end            reduce using rule 21 (ROOT -> COMENTARIOLEX .)
    SEMICOLON       reduce using rule 78 (CODE -> COMENTARIOLEX .)

  ! $end            [ reduce using rule 78 (CODE -> COMENTARIOLEX .) ]


state 23

    (22) ROOT -> VARIABLELEX .
    (61) BUCLE -> VARIABLELEX . INCREASE

    $end            reduce using rule 22 (ROOT -> VARIABLELEX .)
    INCREASE        shift and go to state 113


state 24

    (23) ROOT -> OPERATOR .

    $end            reduce using rule 23 (ROOT -> OPERATOR .)


state 25

    (24) ROOT -> OPERATION .
    (114) OPERATIONS -> OPERATION .
    (115) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (108) OPERATOR -> . PLUS
    (109) OPERATOR -> . MINUS
    (110) OPERATOR -> . TIMES
    (111) OPERATOR -> . MODULUS
    (112) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 24 (ROOT -> OPERATION .)
    $end            reduce using rule 24 (ROOT -> OPERATION .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    MODULUS         shift and go to state 72
    DIVIDE          shift and go to state 73

  ! $end            [ reduce using rule 114 (OPERATIONS -> OPERATION .) ]

    OPERATOR                       shift and go to state 114

state 26

    (25) ROOT -> OPERATIONS .

    $end            reduce using rule 25 (ROOT -> OPERATIONS .)


state 27

    (26) ROOT -> COMPARISON_OPERATOR .

    $end            reduce using rule 26 (ROOT -> COMPARISON_OPERATOR .)


state 28

    (27) ROOT -> COMPARISON .
    (124) COMPARISONS -> COMPARISON .
    (125) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (126) LOGICAL_OPERATOR -> . AND
    (127) LOGICAL_OPERATOR -> . OR
    (128) LOGICAL_OPERATOR -> . NOT

  ! reduce/reduce conflict for $end resolved using rule 27 (ROOT -> COMPARISON .)
    $end            reduce using rule 27 (ROOT -> COMPARISON .)
    AND             shift and go to state 80
    OR              shift and go to state 81
    NOT             shift and go to state 82

  ! $end            [ reduce using rule 124 (COMPARISONS -> COMPARISON .) ]

    LOGICAL_OPERATOR               shift and go to state 115

state 29

    (28) ROOT -> COMPARISONS .
    (85) FUNCTION_ARGUMENTS -> COMPARISONS .

  ! reduce/reduce conflict for $end resolved using rule 28 (ROOT -> COMPARISONS .)
    $end            reduce using rule 28 (ROOT -> COMPARISONS .)

  ! $end            [ reduce using rule 85 (FUNCTION_ARGUMENTS -> COMPARISONS .) ]


state 30

    (29) ROOT -> LOGICAL_OPERATOR .

    $end            reduce using rule 29 (ROOT -> LOGICAL_OPERATOR .)


state 31

    (30) ROOT -> STATEMENT .
    (123) COMPARISON -> STATEMENT . COMPARISON_OPERATOR STATEMENT
    (131) STATEMENTS -> STATEMENT .
    (132) STATEMENTS -> STATEMENT . COMMA STATEMENTS
    (116) COMPARISON_OPERATOR -> . EQUAL_TO
    (117) COMPARISON_OPERATOR -> . NOT_EQUAL
    (118) COMPARISON_OPERATOR -> . GREATER_THAN
    (119) COMPARISON_OPERATOR -> . LESS_THAN
    (120) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (121) COMPARISON_OPERATOR -> . LESS_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 30 (ROOT -> STATEMENT .)
    $end            reduce using rule 30 (ROOT -> STATEMENT .)
    COMMA           shift and go to state 117
    EQUAL_TO        shift and go to state 74
    NOT_EQUAL       shift and go to state 75
    GREATER_THAN    shift and go to state 76
    LESS_THAN       shift and go to state 77
    GREATER_EQUAL   shift and go to state 78
    LESS_EQUAL      shift and go to state 79

  ! $end            [ reduce using rule 131 (STATEMENTS -> STATEMENT .) ]

    COMPARISON_OPERATOR            shift and go to state 116

state 32

    (31) ROOT -> SWITCH_BODY .

    $end            reduce using rule 31 (ROOT -> SWITCH_BODY .)


state 33

    (32) ROOT -> BUCLE .

    $end            reduce using rule 32 (ROOT -> BUCLE .)


state 34

    (33) ROOT -> ELSE_STRUCTURE .

    $end            reduce using rule 33 (ROOT -> ELSE_STRUCTURE .)


state 35

    (34) ROOT -> FUNCTION_ARGUMENTS .

    $end            reduce using rule 34 (ROOT -> FUNCTION_ARGUMENTS .)


state 36

    (35) ROOT -> DECLARATIONS .

    $end            reduce using rule 35 (ROOT -> DECLARATIONS .)


state 37

    (36) ROOT -> FOR_BODY_STRUCTURE .

    $end            reduce using rule 36 (ROOT -> FOR_BODY_STRUCTURE .)


state 38

    (37) ROOT -> FOR_ARGUMENTS_STRUCTURE .

    $end            reduce using rule 37 (ROOT -> FOR_ARGUMENTS_STRUCTURE .)


state 39

    (40) DEFINE -> PP_DEFINE . VARIABLELEX VALUE
    (107) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 119

    VARIABLELEX                    shift and go to state 118

state 40

    (41) INCLUDE -> PP_INCLUDE . HEADER_LIB

    HEADER_LIB      shift and go to state 120


state 41

    (43) VALUE -> STRING .

    EQUAL_TO        reduce using rule 43 (VALUE -> STRING .)
    NOT_EQUAL       reduce using rule 43 (VALUE -> STRING .)
    GREATER_THAN    reduce using rule 43 (VALUE -> STRING .)
    LESS_THAN       reduce using rule 43 (VALUE -> STRING .)
    GREATER_EQUAL   reduce using rule 43 (VALUE -> STRING .)
    LESS_EQUAL      reduce using rule 43 (VALUE -> STRING .)
    $end            reduce using rule 43 (VALUE -> STRING .)
    AND             reduce using rule 43 (VALUE -> STRING .)
    OR              reduce using rule 43 (VALUE -> STRING .)
    NOT             reduce using rule 43 (VALUE -> STRING .)
    RPAREN          reduce using rule 43 (VALUE -> STRING .)
    SEMICOLON       reduce using rule 43 (VALUE -> STRING .)


state 42

    (44) VALUE -> CHARACTER .

    EQUAL_TO        reduce using rule 44 (VALUE -> CHARACTER .)
    NOT_EQUAL       reduce using rule 44 (VALUE -> CHARACTER .)
    GREATER_THAN    reduce using rule 44 (VALUE -> CHARACTER .)
    LESS_THAN       reduce using rule 44 (VALUE -> CHARACTER .)
    GREATER_EQUAL   reduce using rule 44 (VALUE -> CHARACTER .)
    LESS_EQUAL      reduce using rule 44 (VALUE -> CHARACTER .)
    $end            reduce using rule 44 (VALUE -> CHARACTER .)
    AND             reduce using rule 44 (VALUE -> CHARACTER .)
    OR              reduce using rule 44 (VALUE -> CHARACTER .)
    NOT             reduce using rule 44 (VALUE -> CHARACTER .)
    RPAREN          reduce using rule 44 (VALUE -> CHARACTER .)
    SEMICOLON       reduce using rule 44 (VALUE -> CHARACTER .)


state 43

    (45) NUMBER -> INTEGER .

    PLUS            reduce using rule 45 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 45 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 45 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 45 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 45 (NUMBER -> INTEGER .)
    $end            reduce using rule 45 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 45 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 45 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 45 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 45 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 45 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 45 (NUMBER -> INTEGER .)
    COMMA           reduce using rule 45 (NUMBER -> INTEGER .)
    AND             reduce using rule 45 (NUMBER -> INTEGER .)
    OR              reduce using rule 45 (NUMBER -> INTEGER .)
    NOT             reduce using rule 45 (NUMBER -> INTEGER .)
    RPAREN          reduce using rule 45 (NUMBER -> INTEGER .)
    SEMICOLON       reduce using rule 45 (NUMBER -> INTEGER .)


state 44

    (46) NUMBER -> DECIMAL .

    PLUS            reduce using rule 46 (NUMBER -> DECIMAL .)
    MINUS           reduce using rule 46 (NUMBER -> DECIMAL .)
    TIMES           reduce using rule 46 (NUMBER -> DECIMAL .)
    MODULUS         reduce using rule 46 (NUMBER -> DECIMAL .)
    DIVIDE          reduce using rule 46 (NUMBER -> DECIMAL .)
    $end            reduce using rule 46 (NUMBER -> DECIMAL .)
    EQUAL_TO        reduce using rule 46 (NUMBER -> DECIMAL .)
    NOT_EQUAL       reduce using rule 46 (NUMBER -> DECIMAL .)
    GREATER_THAN    reduce using rule 46 (NUMBER -> DECIMAL .)
    LESS_THAN       reduce using rule 46 (NUMBER -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 46 (NUMBER -> DECIMAL .)
    LESS_EQUAL      reduce using rule 46 (NUMBER -> DECIMAL .)
    COMMA           reduce using rule 46 (NUMBER -> DECIMAL .)
    AND             reduce using rule 46 (NUMBER -> DECIMAL .)
    OR              reduce using rule 46 (NUMBER -> DECIMAL .)
    NOT             reduce using rule 46 (NUMBER -> DECIMAL .)
    RPAREN          reduce using rule 46 (NUMBER -> DECIMAL .)
    SEMICOLON       reduce using rule 46 (NUMBER -> DECIMAL .)


state 45

    (54) WHILE_STRUCTURE -> WHILE . LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LPAREN          shift and go to state 121


state 46

    (64) FOR_ARGUMENTS_STRUCTURE -> LPAREN . DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN
    (72) DECLARATIONS -> . INTEGER_DECLARATION
    (73) DECLARATIONS -> . DECIMAL_DECLARATION
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE

    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55

    DECLARATIONS                   shift and go to state 122
    INTEGER_DECLARATION            shift and go to state 123
    DECIMAL_DECLARATION            shift and go to state 124
    INTEGER_TYPE                   shift and go to state 109
    DECIMAL_TYPE                   shift and go to state 110

state 47

    (60) SWITCH_STRUCTURE -> SWITCH . LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LPAREN          shift and go to state 125


state 48

    (68) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LPAREN          shift and go to state 126


state 49

    (63) FOR_STRUCTURE -> FOR . FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (64) FOR_ARGUMENTS_STRUCTURE -> . LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN

    LPAREN          shift and go to state 46

    FOR_ARGUMENTS_STRUCTURE        shift and go to state 127

state 50

    (83) FUNCTION -> VARNAME . LPAREN FUNCTION_ARGUMENTS RPAREN
    (93) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR STATEMENT
    (107) VARIABLELEX -> VARNAME .
    (130) STATEMENT -> VARNAME .
    (94) ASSIGNMENT_OPERATOR -> . EQUAL
    (95) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (96) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (97) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (98) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (99) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (100) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (101) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (102) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (103) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (104) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (105) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 107 (VARIABLELEX -> VARNAME .)
    LPAREN          shift and go to state 128
    INCREASE        reduce using rule 107 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 107 (VARIABLELEX -> VARNAME .)
    COMMA           reduce using rule 130 (STATEMENT -> VARNAME .)
    EQUAL_TO        reduce using rule 130 (STATEMENT -> VARNAME .)
    NOT_EQUAL       reduce using rule 130 (STATEMENT -> VARNAME .)
    GREATER_THAN    reduce using rule 130 (STATEMENT -> VARNAME .)
    LESS_THAN       reduce using rule 130 (STATEMENT -> VARNAME .)
    GREATER_EQUAL   reduce using rule 130 (STATEMENT -> VARNAME .)
    LESS_EQUAL      reduce using rule 130 (STATEMENT -> VARNAME .)
    EQUAL           shift and go to state 56
    PLUS_EQUAL      shift and go to state 57
    MINUS_EQUAL     shift and go to state 58
    DIV_EQUAL       shift and go to state 59
    TIMES_EQUAL     shift and go to state 60
    MOD_EQUAL       shift and go to state 61
    AND_EQUAL       shift and go to state 62
    OR_EQUAL        shift and go to state 63
    XOR_EQUAL       shift and go to state 64
    COMPLEMENT_EQUAL shift and go to state 65
    SHIFTL_EQUAL    shift and go to state 66
    SHIFTR_EQUAL    shift and go to state 67

  ! $end            [ reduce using rule 130 (STATEMENT -> VARNAME .) ]

    ASSIGNMENT_OPERATOR            shift and go to state 129

state 51

    (86) INTEGER_TYPE -> INT .

    VARNAME         reduce using rule 86 (INTEGER_TYPE -> INT .)
    $end            reduce using rule 86 (INTEGER_TYPE -> INT .)


state 52

    (87) INTEGER_TYPE -> SHORT .

    VARNAME         reduce using rule 87 (INTEGER_TYPE -> SHORT .)
    $end            reduce using rule 87 (INTEGER_TYPE -> SHORT .)


state 53

    (88) INTEGER_TYPE -> LONG .

    VARNAME         reduce using rule 88 (INTEGER_TYPE -> LONG .)
    $end            reduce using rule 88 (INTEGER_TYPE -> LONG .)


state 54

    (89) DECIMAL_TYPE -> FLOAT .

    VARNAME         reduce using rule 89 (DECIMAL_TYPE -> FLOAT .)
    $end            reduce using rule 89 (DECIMAL_TYPE -> FLOAT .)


state 55

    (90) DECIMAL_TYPE -> DOUBLE .

    VARNAME         reduce using rule 90 (DECIMAL_TYPE -> DOUBLE .)
    $end            reduce using rule 90 (DECIMAL_TYPE -> DOUBLE .)


state 56

    (94) ASSIGNMENT_OPERATOR -> EQUAL .

    $end            reduce using rule 94 (ASSIGNMENT_OPERATOR -> EQUAL .)
    VARNAME         reduce using rule 94 (ASSIGNMENT_OPERATOR -> EQUAL .)
    INTEGER         reduce using rule 94 (ASSIGNMENT_OPERATOR -> EQUAL .)
    DECIMAL         reduce using rule 94 (ASSIGNMENT_OPERATOR -> EQUAL .)


state 57

    (95) ASSIGNMENT_OPERATOR -> PLUS_EQUAL .

    $end            reduce using rule 95 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    VARNAME         reduce using rule 95 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    INTEGER         reduce using rule 95 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    DECIMAL         reduce using rule 95 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)


state 58

    (96) ASSIGNMENT_OPERATOR -> MINUS_EQUAL .

    $end            reduce using rule 96 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    VARNAME         reduce using rule 96 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    INTEGER         reduce using rule 96 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    DECIMAL         reduce using rule 96 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)


state 59

    (97) ASSIGNMENT_OPERATOR -> DIV_EQUAL .

    $end            reduce using rule 97 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    VARNAME         reduce using rule 97 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    INTEGER         reduce using rule 97 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    DECIMAL         reduce using rule 97 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)


state 60

    (98) ASSIGNMENT_OPERATOR -> TIMES_EQUAL .

    $end            reduce using rule 98 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    VARNAME         reduce using rule 98 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    INTEGER         reduce using rule 98 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    DECIMAL         reduce using rule 98 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)


state 61

    (99) ASSIGNMENT_OPERATOR -> MOD_EQUAL .

    $end            reduce using rule 99 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    VARNAME         reduce using rule 99 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    INTEGER         reduce using rule 99 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    DECIMAL         reduce using rule 99 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)


state 62

    (100) ASSIGNMENT_OPERATOR -> AND_EQUAL .

    $end            reduce using rule 100 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    VARNAME         reduce using rule 100 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    INTEGER         reduce using rule 100 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    DECIMAL         reduce using rule 100 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)


state 63

    (101) ASSIGNMENT_OPERATOR -> OR_EQUAL .

    $end            reduce using rule 101 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    VARNAME         reduce using rule 101 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    INTEGER         reduce using rule 101 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    DECIMAL         reduce using rule 101 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)


state 64

    (102) ASSIGNMENT_OPERATOR -> XOR_EQUAL .

    $end            reduce using rule 102 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    VARNAME         reduce using rule 102 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    INTEGER         reduce using rule 102 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    DECIMAL         reduce using rule 102 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)


state 65

    (103) ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .

    $end            reduce using rule 103 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    VARNAME         reduce using rule 103 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    INTEGER         reduce using rule 103 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    DECIMAL         reduce using rule 103 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)


state 66

    (104) ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .

    $end            reduce using rule 104 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    VARNAME         reduce using rule 104 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    INTEGER         reduce using rule 104 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    DECIMAL         reduce using rule 104 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)


state 67

    (105) ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .

    $end            reduce using rule 105 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    VARNAME         reduce using rule 105 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    INTEGER         reduce using rule 105 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    DECIMAL         reduce using rule 105 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)


state 68

    (106) COMENTARIOLEX -> COMMENT .

    $end            reduce using rule 106 (COMENTARIOLEX -> COMMENT .)
    SEMICOLON       reduce using rule 106 (COMENTARIOLEX -> COMMENT .)


state 69

    (108) OPERATOR -> PLUS .

    $end            reduce using rule 108 (OPERATOR -> PLUS .)
    INTEGER         reduce using rule 108 (OPERATOR -> PLUS .)
    DECIMAL         reduce using rule 108 (OPERATOR -> PLUS .)


state 70

    (109) OPERATOR -> MINUS .

    $end            reduce using rule 109 (OPERATOR -> MINUS .)
    INTEGER         reduce using rule 109 (OPERATOR -> MINUS .)
    DECIMAL         reduce using rule 109 (OPERATOR -> MINUS .)


state 71

    (110) OPERATOR -> TIMES .

    $end            reduce using rule 110 (OPERATOR -> TIMES .)
    INTEGER         reduce using rule 110 (OPERATOR -> TIMES .)
    DECIMAL         reduce using rule 110 (OPERATOR -> TIMES .)


state 72

    (111) OPERATOR -> MODULUS .

    $end            reduce using rule 111 (OPERATOR -> MODULUS .)
    INTEGER         reduce using rule 111 (OPERATOR -> MODULUS .)
    DECIMAL         reduce using rule 111 (OPERATOR -> MODULUS .)


state 73

    (112) OPERATOR -> DIVIDE .

    $end            reduce using rule 112 (OPERATOR -> DIVIDE .)
    INTEGER         reduce using rule 112 (OPERATOR -> DIVIDE .)
    DECIMAL         reduce using rule 112 (OPERATOR -> DIVIDE .)


state 74

    (116) COMPARISON_OPERATOR -> EQUAL_TO .

    $end            reduce using rule 116 (COMPARISON_OPERATOR -> EQUAL_TO .)
    STRING          reduce using rule 116 (COMPARISON_OPERATOR -> EQUAL_TO .)
    CHARACTER       reduce using rule 116 (COMPARISON_OPERATOR -> EQUAL_TO .)
    INTEGER         reduce using rule 116 (COMPARISON_OPERATOR -> EQUAL_TO .)
    DECIMAL         reduce using rule 116 (COMPARISON_OPERATOR -> EQUAL_TO .)
    VARNAME         reduce using rule 116 (COMPARISON_OPERATOR -> EQUAL_TO .)


state 75

    (117) COMPARISON_OPERATOR -> NOT_EQUAL .

    $end            reduce using rule 117 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    STRING          reduce using rule 117 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    CHARACTER       reduce using rule 117 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    INTEGER         reduce using rule 117 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    DECIMAL         reduce using rule 117 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    VARNAME         reduce using rule 117 (COMPARISON_OPERATOR -> NOT_EQUAL .)


state 76

    (118) COMPARISON_OPERATOR -> GREATER_THAN .

    $end            reduce using rule 118 (COMPARISON_OPERATOR -> GREATER_THAN .)
    STRING          reduce using rule 118 (COMPARISON_OPERATOR -> GREATER_THAN .)
    CHARACTER       reduce using rule 118 (COMPARISON_OPERATOR -> GREATER_THAN .)
    INTEGER         reduce using rule 118 (COMPARISON_OPERATOR -> GREATER_THAN .)
    DECIMAL         reduce using rule 118 (COMPARISON_OPERATOR -> GREATER_THAN .)
    VARNAME         reduce using rule 118 (COMPARISON_OPERATOR -> GREATER_THAN .)


state 77

    (119) COMPARISON_OPERATOR -> LESS_THAN .

    $end            reduce using rule 119 (COMPARISON_OPERATOR -> LESS_THAN .)
    STRING          reduce using rule 119 (COMPARISON_OPERATOR -> LESS_THAN .)
    CHARACTER       reduce using rule 119 (COMPARISON_OPERATOR -> LESS_THAN .)
    INTEGER         reduce using rule 119 (COMPARISON_OPERATOR -> LESS_THAN .)
    DECIMAL         reduce using rule 119 (COMPARISON_OPERATOR -> LESS_THAN .)
    VARNAME         reduce using rule 119 (COMPARISON_OPERATOR -> LESS_THAN .)


state 78

    (120) COMPARISON_OPERATOR -> GREATER_EQUAL .

    $end            reduce using rule 120 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    STRING          reduce using rule 120 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    CHARACTER       reduce using rule 120 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    INTEGER         reduce using rule 120 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    DECIMAL         reduce using rule 120 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    VARNAME         reduce using rule 120 (COMPARISON_OPERATOR -> GREATER_EQUAL .)


state 79

    (121) COMPARISON_OPERATOR -> LESS_EQUAL .

    $end            reduce using rule 121 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    STRING          reduce using rule 121 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    CHARACTER       reduce using rule 121 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    INTEGER         reduce using rule 121 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    DECIMAL         reduce using rule 121 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    VARNAME         reduce using rule 121 (COMPARISON_OPERATOR -> LESS_EQUAL .)


state 80

    (126) LOGICAL_OPERATOR -> AND .

    $end            reduce using rule 126 (LOGICAL_OPERATOR -> AND .)
    STRING          reduce using rule 126 (LOGICAL_OPERATOR -> AND .)
    CHARACTER       reduce using rule 126 (LOGICAL_OPERATOR -> AND .)
    VARNAME         reduce using rule 126 (LOGICAL_OPERATOR -> AND .)
    INTEGER         reduce using rule 126 (LOGICAL_OPERATOR -> AND .)
    DECIMAL         reduce using rule 126 (LOGICAL_OPERATOR -> AND .)


state 81

    (127) LOGICAL_OPERATOR -> OR .

    $end            reduce using rule 127 (LOGICAL_OPERATOR -> OR .)
    STRING          reduce using rule 127 (LOGICAL_OPERATOR -> OR .)
    CHARACTER       reduce using rule 127 (LOGICAL_OPERATOR -> OR .)
    VARNAME         reduce using rule 127 (LOGICAL_OPERATOR -> OR .)
    INTEGER         reduce using rule 127 (LOGICAL_OPERATOR -> OR .)
    DECIMAL         reduce using rule 127 (LOGICAL_OPERATOR -> OR .)


state 82

    (128) LOGICAL_OPERATOR -> NOT .

    $end            reduce using rule 128 (LOGICAL_OPERATOR -> NOT .)
    STRING          reduce using rule 128 (LOGICAL_OPERATOR -> NOT .)
    CHARACTER       reduce using rule 128 (LOGICAL_OPERATOR -> NOT .)
    VARNAME         reduce using rule 128 (LOGICAL_OPERATOR -> NOT .)
    INTEGER         reduce using rule 128 (LOGICAL_OPERATOR -> NOT .)
    DECIMAL         reduce using rule 128 (LOGICAL_OPERATOR -> NOT .)


state 83

    (57) SWITCH_BODY -> SWITCH_CASE .
    (59) SWITCH_BODY -> SWITCH_CASE . SWITCH_BODY
    (57) SWITCH_BODY -> . SWITCH_CASE
    (58) SWITCH_BODY -> . SWITCH_DEFAULT
    (59) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (55) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (56) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    $end            reduce using rule 57 (SWITCH_BODY -> SWITCH_CASE .)
    RCURL_BRACE     reduce using rule 57 (SWITCH_BODY -> SWITCH_CASE .)
    CASE            shift and go to state 90
    DEFAULT         shift and go to state 91

    SWITCH_CASE                    shift and go to state 83
    SWITCH_BODY                    shift and go to state 130
    SWITCH_DEFAULT                 shift and go to state 84

state 84

    (58) SWITCH_BODY -> SWITCH_DEFAULT .

    $end            reduce using rule 58 (SWITCH_BODY -> SWITCH_DEFAULT .)
    RCURL_BRACE     reduce using rule 58 (SWITCH_BODY -> SWITCH_DEFAULT .)


state 85

    (62) BUCLE -> DECREASE . VARIABLELEX
    (107) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 119

    VARIABLELEX                    shift and go to state 131

state 86

    (70) ELSE_STRUCTURE -> ELSE . LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (71) ELSE_STRUCTURE -> ELSE . IF_STRUCTURE
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LCURL_BRACE     shift and go to state 132
    IF              shift and go to state 48

    IF_STRUCTURE                   shift and go to state 133

state 87

    (84) FUNCTION_ARGUMENTS -> STATEMENTS .

    $end            reduce using rule 84 (FUNCTION_ARGUMENTS -> STATEMENTS .)
    RPAREN          reduce using rule 84 (FUNCTION_ARGUMENTS -> STATEMENTS .)


state 88

    (66) FOR_BODY_STRUCTURE -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 134


state 89

    (67) FOR_BODY_STRUCTURE -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 135


state 90

    (55) SWITCH_CASE -> CASE . INTEGER COLON EXPRESSIONS BREAK SEMICOLON

    INTEGER         shift and go to state 136


state 91

    (56) SWITCH_DEFAULT -> DEFAULT . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 137


state 92

    (122) COMPARISON -> VALUE COMPARISON_OPERATOR . VALUE
    (42) VALUE -> . NUMBER
    (43) VALUE -> . STRING
    (44) VALUE -> . CHARACTER
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    STRING          shift and go to state 41
    CHARACTER       shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    VALUE                          shift and go to state 138
    NUMBER                         shift and go to state 139

state 93

    (113) OPERATION -> NUMBER OPERATOR . NUMBER
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    NUMBER                         shift and go to state 140

state 94

    (79) EXPRESSION -> CODE SEMICOLON .

    VARNAME         reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    COMMENT         reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    IF              reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    FOR             reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    WHILE           reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    SWITCH          reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    INT             reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    SHORT           reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    LONG            reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    FLOAT           reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    DOUBLE          reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    $end            reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    RCURL_BRACE     reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    BREAK           reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)
    CONTINUE        reduce using rule 79 (EXPRESSION -> CODE SEMICOLON .)


state 95

    (81) EXPRESSIONS -> EXPRESSION .
    (82) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (81) EXPRESSIONS -> . EXPRESSION
    (82) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (79) EXPRESSION -> . CODE SEMICOLON
    (80) EXPRESSION -> . CONTROL_STRUCTURES
    (74) CODE -> . FUNCTION
    (75) CODE -> . INTEGER_DECLARATION
    (76) CODE -> . DECIMAL_DECLARATION
    (77) CODE -> . ASSIGNMENT_DECLARATION
    (78) CODE -> . COMENTARIOLEX
    (47) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (48) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (49) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (50) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (83) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (93) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR STATEMENT
    (106) COMENTARIOLEX -> . COMMENT
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (63) FOR_STRUCTURE -> . FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (54) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (60) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE

    $end            reduce using rule 81 (EXPRESSIONS -> EXPRESSION .)
    RCURL_BRACE     reduce using rule 81 (EXPRESSIONS -> EXPRESSION .)
    BREAK           reduce using rule 81 (EXPRESSIONS -> EXPRESSION .)
    CONTINUE        reduce using rule 81 (EXPRESSIONS -> EXPRESSION .)
    VARNAME         shift and go to state 108
    COMMENT         shift and go to state 68
    IF              shift and go to state 48
    FOR             shift and go to state 49
    WHILE           shift and go to state 45
    SWITCH          shift and go to state 47
    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55

    EXPRESSION                     shift and go to state 95
    EXPRESSIONS                    shift and go to state 96
    CODE                           shift and go to state 97
    CONTROL_STRUCTURES             shift and go to state 98
    FUNCTION                       shift and go to state 99
    INTEGER_DECLARATION            shift and go to state 100
    DECIMAL_DECLARATION            shift and go to state 101
    ASSIGNMENT_DECLARATION         shift and go to state 102
    COMENTARIOLEX                  shift and go to state 103
    IF_STRUCTURE                   shift and go to state 104
    FOR_STRUCTURE                  shift and go to state 105
    WHILE_STRUCTURE                shift and go to state 106
    SWITCH_STRUCTURE               shift and go to state 107
    INTEGER_TYPE                   shift and go to state 109
    DECIMAL_TYPE                   shift and go to state 110

state 96

    (82) EXPRESSIONS -> EXPRESSION EXPRESSIONS .

    $end            reduce using rule 82 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    RCURL_BRACE     reduce using rule 82 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    BREAK           reduce using rule 82 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    CONTINUE        reduce using rule 82 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)


state 97

    (79) EXPRESSION -> CODE . SEMICOLON

    SEMICOLON       shift and go to state 94


state 98

    (80) EXPRESSION -> CONTROL_STRUCTURES .

    VARNAME         reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    FOR             reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    $end            reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    RCURL_BRACE     reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    BREAK           reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)
    CONTINUE        reduce using rule 80 (EXPRESSION -> CONTROL_STRUCTURES .)


state 99

    (74) CODE -> FUNCTION .

    SEMICOLON       reduce using rule 74 (CODE -> FUNCTION .)


state 100

    (75) CODE -> INTEGER_DECLARATION .

    SEMICOLON       reduce using rule 75 (CODE -> INTEGER_DECLARATION .)


state 101

    (76) CODE -> DECIMAL_DECLARATION .

    SEMICOLON       reduce using rule 76 (CODE -> DECIMAL_DECLARATION .)


state 102

    (77) CODE -> ASSIGNMENT_DECLARATION .

    SEMICOLON       reduce using rule 77 (CODE -> ASSIGNMENT_DECLARATION .)


state 103

    (78) CODE -> COMENTARIOLEX .

    SEMICOLON       reduce using rule 78 (CODE -> COMENTARIOLEX .)


state 104

    (47) CONTROL_STRUCTURES -> IF_STRUCTURE .

    VARNAME         reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FOR             reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    $end            reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    RCURL_BRACE     reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    BREAK           reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    CONTINUE        reduce using rule 47 (CONTROL_STRUCTURES -> IF_STRUCTURE .)


state 105

    (48) CONTROL_STRUCTURES -> FOR_STRUCTURE .

    VARNAME         reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FOR             reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    $end            reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    RCURL_BRACE     reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    BREAK           reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    CONTINUE        reduce using rule 48 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)


state 106

    (49) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

    VARNAME         reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FOR             reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    $end            reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    RCURL_BRACE     reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    BREAK           reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    CONTINUE        reduce using rule 49 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)


state 107

    (50) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

    VARNAME         reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FOR             reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    $end            reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    RCURL_BRACE     reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    BREAK           reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    CONTINUE        reduce using rule 50 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)


state 108

    (83) FUNCTION -> VARNAME . LPAREN FUNCTION_ARGUMENTS RPAREN
    (93) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR STATEMENT
    (94) ASSIGNMENT_OPERATOR -> . EQUAL
    (95) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (96) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (97) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (98) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (99) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (100) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (101) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (102) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (103) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (104) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (105) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

    LPAREN          shift and go to state 128
    EQUAL           shift and go to state 56
    PLUS_EQUAL      shift and go to state 57
    MINUS_EQUAL     shift and go to state 58
    DIV_EQUAL       shift and go to state 59
    TIMES_EQUAL     shift and go to state 60
    MOD_EQUAL       shift and go to state 61
    AND_EQUAL       shift and go to state 62
    OR_EQUAL        shift and go to state 63
    XOR_EQUAL       shift and go to state 64
    COMPLEMENT_EQUAL shift and go to state 65
    SHIFTL_EQUAL    shift and go to state 66
    SHIFTR_EQUAL    shift and go to state 67

    ASSIGNMENT_OPERATOR            shift and go to state 129

state 109

    (91) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    VARNAME         shift and go to state 111


state 110

    (92) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    VARNAME         shift and go to state 112


state 111

    (91) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME . EQUAL INTEGER

    EQUAL           shift and go to state 141


state 112

    (92) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME . EQUAL DECIMAL

    EQUAL           shift and go to state 142


state 113

    (61) BUCLE -> VARIABLELEX INCREASE .

    $end            reduce using rule 61 (BUCLE -> VARIABLELEX INCREASE .)
    RPAREN          reduce using rule 61 (BUCLE -> VARIABLELEX INCREASE .)


state 114

    (115) OPERATIONS -> OPERATION OPERATOR . OPERATIONS
    (114) OPERATIONS -> . OPERATION
    (115) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (113) OPERATION -> . NUMBER OPERATOR NUMBER
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    OPERATION                      shift and go to state 143
    OPERATIONS                     shift and go to state 144
    NUMBER                         shift and go to state 145

state 115

    (125) COMPARISONS -> COMPARISON LOGICAL_OPERATOR . COMPARISONS
    (124) COMPARISONS -> . COMPARISON
    (125) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (122) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (123) COMPARISON -> . STATEMENT COMPARISON_OPERATOR STATEMENT
    (42) VALUE -> . NUMBER
    (43) VALUE -> . STRING
    (44) VALUE -> . CHARACTER
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    STRING          shift and go to state 41
    CHARACTER       shift and go to state 42
    VARNAME         shift and go to state 151
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    COMPARISON                     shift and go to state 146
    COMPARISONS                    shift and go to state 147
    VALUE                          shift and go to state 148
    STATEMENT                      shift and go to state 149
    NUMBER                         shift and go to state 150

state 116

    (123) COMPARISON -> STATEMENT COMPARISON_OPERATOR . STATEMENT
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 151
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    STATEMENT                      shift and go to state 152
    NUMBER                         shift and go to state 153

state 117

    (132) STATEMENTS -> STATEMENT COMMA . STATEMENTS
    (131) STATEMENTS -> . STATEMENT
    (132) STATEMENTS -> . STATEMENT COMMA STATEMENTS
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 151
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    STATEMENT                      shift and go to state 154
    STATEMENTS                     shift and go to state 155
    NUMBER                         shift and go to state 153

state 118

    (40) DEFINE -> PP_DEFINE VARIABLELEX . VALUE
    (42) VALUE -> . NUMBER
    (43) VALUE -> . STRING
    (44) VALUE -> . CHARACTER
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    STRING          shift and go to state 41
    CHARACTER       shift and go to state 42
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    VALUE                          shift and go to state 156
    NUMBER                         shift and go to state 139

state 119

    (107) VARIABLELEX -> VARNAME .

    STRING          reduce using rule 107 (VARIABLELEX -> VARNAME .)
    CHARACTER       reduce using rule 107 (VARIABLELEX -> VARNAME .)
    INTEGER         reduce using rule 107 (VARIABLELEX -> VARNAME .)
    DECIMAL         reduce using rule 107 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 107 (VARIABLELEX -> VARNAME .)
    RPAREN          reduce using rule 107 (VARIABLELEX -> VARNAME .)
    INCREASE        reduce using rule 107 (VARIABLELEX -> VARNAME .)


state 120

    (41) INCLUDE -> PP_INCLUDE HEADER_LIB .

    $end            reduce using rule 41 (INCLUDE -> PP_INCLUDE HEADER_LIB .)


state 121

    (54) WHILE_STRUCTURE -> WHILE LPAREN . COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (124) COMPARISONS -> . COMPARISON
    (125) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (122) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (123) COMPARISON -> . STATEMENT COMPARISON_OPERATOR STATEMENT
    (42) VALUE -> . NUMBER
    (43) VALUE -> . STRING
    (44) VALUE -> . CHARACTER
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    STRING          shift and go to state 41
    CHARACTER       shift and go to state 42
    VARNAME         shift and go to state 151
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    COMPARISONS                    shift and go to state 157
    COMPARISON                     shift and go to state 146
    VALUE                          shift and go to state 148
    STATEMENT                      shift and go to state 149
    NUMBER                         shift and go to state 150

state 122

    (64) FOR_ARGUMENTS_STRUCTURE -> LPAREN DECLARATIONS . SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN

    SEMICOLON       shift and go to state 158


state 123

    (72) DECLARATIONS -> INTEGER_DECLARATION .

    SEMICOLON       reduce using rule 72 (DECLARATIONS -> INTEGER_DECLARATION .)


state 124

    (73) DECLARATIONS -> DECIMAL_DECLARATION .

    SEMICOLON       reduce using rule 73 (DECLARATIONS -> DECIMAL_DECLARATION .)


state 125

    (60) SWITCH_STRUCTURE -> SWITCH LPAREN . COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (124) COMPARISONS -> . COMPARISON
    (125) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (122) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (123) COMPARISON -> . STATEMENT COMPARISON_OPERATOR STATEMENT
    (42) VALUE -> . NUMBER
    (43) VALUE -> . STRING
    (44) VALUE -> . CHARACTER
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    STRING          shift and go to state 41
    CHARACTER       shift and go to state 42
    VARNAME         shift and go to state 151
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    COMPARISONS                    shift and go to state 159
    COMPARISON                     shift and go to state 146
    VALUE                          shift and go to state 148
    STATEMENT                      shift and go to state 149
    NUMBER                         shift and go to state 150

state 126

    (68) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (124) COMPARISONS -> . COMPARISON
    (125) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (122) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (123) COMPARISON -> . STATEMENT COMPARISON_OPERATOR STATEMENT
    (42) VALUE -> . NUMBER
    (43) VALUE -> . STRING
    (44) VALUE -> . CHARACTER
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    STRING          shift and go to state 41
    CHARACTER       shift and go to state 42
    VARNAME         shift and go to state 151
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    COMPARISONS                    shift and go to state 160
    COMPARISON                     shift and go to state 146
    VALUE                          shift and go to state 148
    STATEMENT                      shift and go to state 149
    NUMBER                         shift and go to state 150

state 127

    (63) FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE . LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE

    LCURL_BRACE     shift and go to state 161


state 128

    (83) FUNCTION -> VARNAME LPAREN . FUNCTION_ARGUMENTS RPAREN
    (84) FUNCTION_ARGUMENTS -> . STATEMENTS
    (85) FUNCTION_ARGUMENTS -> . COMPARISONS
    (131) STATEMENTS -> . STATEMENT
    (132) STATEMENTS -> . STATEMENT COMMA STATEMENTS
    (124) COMPARISONS -> . COMPARISON
    (125) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (122) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (123) COMPARISON -> . STATEMENT COMPARISON_OPERATOR STATEMENT
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL
    (42) VALUE -> . NUMBER
    (43) VALUE -> . STRING
    (44) VALUE -> . CHARACTER

    VARNAME         shift and go to state 151
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44
    STRING          shift and go to state 41
    CHARACTER       shift and go to state 42

    FUNCTION_ARGUMENTS             shift and go to state 162
    STATEMENTS                     shift and go to state 87
    COMPARISONS                    shift and go to state 163
    STATEMENT                      shift and go to state 164
    COMPARISON                     shift and go to state 146
    NUMBER                         shift and go to state 165
    VALUE                          shift and go to state 148

state 129

    (93) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR . STATEMENT
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 151
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    STATEMENT                      shift and go to state 166
    NUMBER                         shift and go to state 153

state 130

    (59) SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .

    $end            reduce using rule 59 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)
    RCURL_BRACE     reduce using rule 59 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)


state 131

    (62) BUCLE -> DECREASE VARIABLELEX .

    $end            reduce using rule 62 (BUCLE -> DECREASE VARIABLELEX .)
    RPAREN          reduce using rule 62 (BUCLE -> DECREASE VARIABLELEX .)


state 132

    (70) ELSE_STRUCTURE -> ELSE LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (81) EXPRESSIONS -> . EXPRESSION
    (82) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (79) EXPRESSION -> . CODE SEMICOLON
    (80) EXPRESSION -> . CONTROL_STRUCTURES
    (74) CODE -> . FUNCTION
    (75) CODE -> . INTEGER_DECLARATION
    (76) CODE -> . DECIMAL_DECLARATION
    (77) CODE -> . ASSIGNMENT_DECLARATION
    (78) CODE -> . COMENTARIOLEX
    (47) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (48) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (49) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (50) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (83) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (93) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR STATEMENT
    (106) COMENTARIOLEX -> . COMMENT
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (63) FOR_STRUCTURE -> . FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (54) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (60) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 108
    COMMENT         shift and go to state 68
    IF              shift and go to state 48
    FOR             shift and go to state 49
    WHILE           shift and go to state 45
    SWITCH          shift and go to state 47
    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55

    EXPRESSIONS                    shift and go to state 167
    EXPRESSION                     shift and go to state 95
    CODE                           shift and go to state 97
    CONTROL_STRUCTURES             shift and go to state 98
    FUNCTION                       shift and go to state 99
    INTEGER_DECLARATION            shift and go to state 100
    DECIMAL_DECLARATION            shift and go to state 101
    ASSIGNMENT_DECLARATION         shift and go to state 102
    COMENTARIOLEX                  shift and go to state 103
    IF_STRUCTURE                   shift and go to state 104
    FOR_STRUCTURE                  shift and go to state 105
    WHILE_STRUCTURE                shift and go to state 106
    SWITCH_STRUCTURE               shift and go to state 107
    INTEGER_TYPE                   shift and go to state 109
    DECIMAL_TYPE                   shift and go to state 110

state 133

    (71) ELSE_STRUCTURE -> ELSE IF_STRUCTURE .

    $end            reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    VARNAME         reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    COMMENT         reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    IF              reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    FOR             reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    WHILE           reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    SWITCH          reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    INT             reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    SHORT           reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    LONG            reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    FLOAT           reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    DOUBLE          reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    RCURL_BRACE     reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    BREAK           reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    CONTINUE        reduce using rule 71 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)


state 134

    (66) FOR_BODY_STRUCTURE -> BREAK SEMICOLON .

    $end            reduce using rule 66 (FOR_BODY_STRUCTURE -> BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 66 (FOR_BODY_STRUCTURE -> BREAK SEMICOLON .)


state 135

    (67) FOR_BODY_STRUCTURE -> CONTINUE SEMICOLON .

    $end            reduce using rule 67 (FOR_BODY_STRUCTURE -> CONTINUE SEMICOLON .)
    RCURL_BRACE     reduce using rule 67 (FOR_BODY_STRUCTURE -> CONTINUE SEMICOLON .)


state 136

    (55) SWITCH_CASE -> CASE INTEGER . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 168


state 137

    (56) SWITCH_DEFAULT -> DEFAULT COLON . EXPRESSIONS BREAK SEMICOLON
    (81) EXPRESSIONS -> . EXPRESSION
    (82) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (79) EXPRESSION -> . CODE SEMICOLON
    (80) EXPRESSION -> . CONTROL_STRUCTURES
    (74) CODE -> . FUNCTION
    (75) CODE -> . INTEGER_DECLARATION
    (76) CODE -> . DECIMAL_DECLARATION
    (77) CODE -> . ASSIGNMENT_DECLARATION
    (78) CODE -> . COMENTARIOLEX
    (47) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (48) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (49) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (50) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (83) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (93) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR STATEMENT
    (106) COMENTARIOLEX -> . COMMENT
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (63) FOR_STRUCTURE -> . FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (54) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (60) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 108
    COMMENT         shift and go to state 68
    IF              shift and go to state 48
    FOR             shift and go to state 49
    WHILE           shift and go to state 45
    SWITCH          shift and go to state 47
    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55

    EXPRESSIONS                    shift and go to state 169
    EXPRESSION                     shift and go to state 95
    CODE                           shift and go to state 97
    CONTROL_STRUCTURES             shift and go to state 98
    FUNCTION                       shift and go to state 99
    INTEGER_DECLARATION            shift and go to state 100
    DECIMAL_DECLARATION            shift and go to state 101
    ASSIGNMENT_DECLARATION         shift and go to state 102
    COMENTARIOLEX                  shift and go to state 103
    IF_STRUCTURE                   shift and go to state 104
    FOR_STRUCTURE                  shift and go to state 105
    WHILE_STRUCTURE                shift and go to state 106
    SWITCH_STRUCTURE               shift and go to state 107
    INTEGER_TYPE                   shift and go to state 109
    DECIMAL_TYPE                   shift and go to state 110

state 138

    (122) COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .

    AND             reduce using rule 122 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    OR              reduce using rule 122 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    NOT             reduce using rule 122 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    $end            reduce using rule 122 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    RPAREN          reduce using rule 122 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    SEMICOLON       reduce using rule 122 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)


state 139

    (42) VALUE -> NUMBER .

    AND             reduce using rule 42 (VALUE -> NUMBER .)
    OR              reduce using rule 42 (VALUE -> NUMBER .)
    NOT             reduce using rule 42 (VALUE -> NUMBER .)
    $end            reduce using rule 42 (VALUE -> NUMBER .)
    RPAREN          reduce using rule 42 (VALUE -> NUMBER .)
    SEMICOLON       reduce using rule 42 (VALUE -> NUMBER .)


state 140

    (113) OPERATION -> NUMBER OPERATOR NUMBER .

    PLUS            reduce using rule 113 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MINUS           reduce using rule 113 (OPERATION -> NUMBER OPERATOR NUMBER .)
    TIMES           reduce using rule 113 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MODULUS         reduce using rule 113 (OPERATION -> NUMBER OPERATOR NUMBER .)
    DIVIDE          reduce using rule 113 (OPERATION -> NUMBER OPERATOR NUMBER .)
    $end            reduce using rule 113 (OPERATION -> NUMBER OPERATOR NUMBER .)


state 141

    (91) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL . INTEGER

    INTEGER         shift and go to state 170


state 142

    (92) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL . DECIMAL

    DECIMAL         shift and go to state 171


state 143

    (114) OPERATIONS -> OPERATION .
    (115) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (108) OPERATOR -> . PLUS
    (109) OPERATOR -> . MINUS
    (110) OPERATOR -> . TIMES
    (111) OPERATOR -> . MODULUS
    (112) OPERATOR -> . DIVIDE

    $end            reduce using rule 114 (OPERATIONS -> OPERATION .)
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    MODULUS         shift and go to state 72
    DIVIDE          shift and go to state 73

    OPERATOR                       shift and go to state 114

state 144

    (115) OPERATIONS -> OPERATION OPERATOR OPERATIONS .

    $end            reduce using rule 115 (OPERATIONS -> OPERATION OPERATOR OPERATIONS .)


state 145

    (113) OPERATION -> NUMBER . OPERATOR NUMBER
    (108) OPERATOR -> . PLUS
    (109) OPERATOR -> . MINUS
    (110) OPERATOR -> . TIMES
    (111) OPERATOR -> . MODULUS
    (112) OPERATOR -> . DIVIDE

    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    TIMES           shift and go to state 71
    MODULUS         shift and go to state 72
    DIVIDE          shift and go to state 73

    OPERATOR                       shift and go to state 93

state 146

    (124) COMPARISONS -> COMPARISON .
    (125) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (126) LOGICAL_OPERATOR -> . AND
    (127) LOGICAL_OPERATOR -> . OR
    (128) LOGICAL_OPERATOR -> . NOT

    $end            reduce using rule 124 (COMPARISONS -> COMPARISON .)
    RPAREN          reduce using rule 124 (COMPARISONS -> COMPARISON .)
    SEMICOLON       reduce using rule 124 (COMPARISONS -> COMPARISON .)
    AND             shift and go to state 80
    OR              shift and go to state 81
    NOT             shift and go to state 82

    LOGICAL_OPERATOR               shift and go to state 115

state 147

    (125) COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .

    $end            reduce using rule 125 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)
    RPAREN          reduce using rule 125 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)
    SEMICOLON       reduce using rule 125 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)


state 148

    (122) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (116) COMPARISON_OPERATOR -> . EQUAL_TO
    (117) COMPARISON_OPERATOR -> . NOT_EQUAL
    (118) COMPARISON_OPERATOR -> . GREATER_THAN
    (119) COMPARISON_OPERATOR -> . LESS_THAN
    (120) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (121) COMPARISON_OPERATOR -> . LESS_EQUAL

    EQUAL_TO        shift and go to state 74
    NOT_EQUAL       shift and go to state 75
    GREATER_THAN    shift and go to state 76
    LESS_THAN       shift and go to state 77
    GREATER_EQUAL   shift and go to state 78
    LESS_EQUAL      shift and go to state 79

    COMPARISON_OPERATOR            shift and go to state 92

state 149

    (123) COMPARISON -> STATEMENT . COMPARISON_OPERATOR STATEMENT
    (116) COMPARISON_OPERATOR -> . EQUAL_TO
    (117) COMPARISON_OPERATOR -> . NOT_EQUAL
    (118) COMPARISON_OPERATOR -> . GREATER_THAN
    (119) COMPARISON_OPERATOR -> . LESS_THAN
    (120) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (121) COMPARISON_OPERATOR -> . LESS_EQUAL

    EQUAL_TO        shift and go to state 74
    NOT_EQUAL       shift and go to state 75
    GREATER_THAN    shift and go to state 76
    LESS_THAN       shift and go to state 77
    GREATER_EQUAL   shift and go to state 78
    LESS_EQUAL      shift and go to state 79

    COMPARISON_OPERATOR            shift and go to state 116

state 150

    (42) VALUE -> NUMBER .
    (129) STATEMENT -> NUMBER .

  ! reduce/reduce conflict for EQUAL_TO resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 42 (VALUE -> NUMBER .)
    EQUAL_TO        reduce using rule 42 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 42 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 42 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 42 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 42 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 42 (VALUE -> NUMBER .)

  ! EQUAL_TO        [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! GREATER_THAN    [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! LESS_THAN       [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! GREATER_EQUAL   [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! LESS_EQUAL      [ reduce using rule 129 (STATEMENT -> NUMBER .) ]


state 151

    (130) STATEMENT -> VARNAME .

    EQUAL_TO        reduce using rule 130 (STATEMENT -> VARNAME .)
    NOT_EQUAL       reduce using rule 130 (STATEMENT -> VARNAME .)
    GREATER_THAN    reduce using rule 130 (STATEMENT -> VARNAME .)
    LESS_THAN       reduce using rule 130 (STATEMENT -> VARNAME .)
    GREATER_EQUAL   reduce using rule 130 (STATEMENT -> VARNAME .)
    LESS_EQUAL      reduce using rule 130 (STATEMENT -> VARNAME .)
    AND             reduce using rule 130 (STATEMENT -> VARNAME .)
    OR              reduce using rule 130 (STATEMENT -> VARNAME .)
    NOT             reduce using rule 130 (STATEMENT -> VARNAME .)
    $end            reduce using rule 130 (STATEMENT -> VARNAME .)
    RPAREN          reduce using rule 130 (STATEMENT -> VARNAME .)
    SEMICOLON       reduce using rule 130 (STATEMENT -> VARNAME .)
    COMMA           reduce using rule 130 (STATEMENT -> VARNAME .)


state 152

    (123) COMPARISON -> STATEMENT COMPARISON_OPERATOR STATEMENT .

    AND             reduce using rule 123 (COMPARISON -> STATEMENT COMPARISON_OPERATOR STATEMENT .)
    OR              reduce using rule 123 (COMPARISON -> STATEMENT COMPARISON_OPERATOR STATEMENT .)
    NOT             reduce using rule 123 (COMPARISON -> STATEMENT COMPARISON_OPERATOR STATEMENT .)
    $end            reduce using rule 123 (COMPARISON -> STATEMENT COMPARISON_OPERATOR STATEMENT .)
    RPAREN          reduce using rule 123 (COMPARISON -> STATEMENT COMPARISON_OPERATOR STATEMENT .)
    SEMICOLON       reduce using rule 123 (COMPARISON -> STATEMENT COMPARISON_OPERATOR STATEMENT .)


state 153

    (129) STATEMENT -> NUMBER .

    AND             reduce using rule 129 (STATEMENT -> NUMBER .)
    OR              reduce using rule 129 (STATEMENT -> NUMBER .)
    NOT             reduce using rule 129 (STATEMENT -> NUMBER .)
    $end            reduce using rule 129 (STATEMENT -> NUMBER .)
    RPAREN          reduce using rule 129 (STATEMENT -> NUMBER .)
    SEMICOLON       reduce using rule 129 (STATEMENT -> NUMBER .)
    COMMA           reduce using rule 129 (STATEMENT -> NUMBER .)


state 154

    (131) STATEMENTS -> STATEMENT .
    (132) STATEMENTS -> STATEMENT . COMMA STATEMENTS

    $end            reduce using rule 131 (STATEMENTS -> STATEMENT .)
    RPAREN          reduce using rule 131 (STATEMENTS -> STATEMENT .)
    COMMA           shift and go to state 117


state 155

    (132) STATEMENTS -> STATEMENT COMMA STATEMENTS .

    $end            reduce using rule 132 (STATEMENTS -> STATEMENT COMMA STATEMENTS .)
    RPAREN          reduce using rule 132 (STATEMENTS -> STATEMENT COMMA STATEMENTS .)


state 156

    (40) DEFINE -> PP_DEFINE VARIABLELEX VALUE .

    $end            reduce using rule 40 (DEFINE -> PP_DEFINE VARIABLELEX VALUE .)


state 157

    (54) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS . RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    RPAREN          shift and go to state 172


state 158

    (64) FOR_ARGUMENTS_STRUCTURE -> LPAREN DECLARATIONS SEMICOLON . COMPARISONS SEMICOLON BUCLE RPAREN
    (124) COMPARISONS -> . COMPARISON
    (125) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (122) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (123) COMPARISON -> . STATEMENT COMPARISON_OPERATOR STATEMENT
    (42) VALUE -> . NUMBER
    (43) VALUE -> . STRING
    (44) VALUE -> . CHARACTER
    (129) STATEMENT -> . NUMBER
    (130) STATEMENT -> . VARNAME
    (45) NUMBER -> . INTEGER
    (46) NUMBER -> . DECIMAL

    STRING          shift and go to state 41
    CHARACTER       shift and go to state 42
    VARNAME         shift and go to state 151
    INTEGER         shift and go to state 43
    DECIMAL         shift and go to state 44

    COMPARISONS                    shift and go to state 173
    COMPARISON                     shift and go to state 146
    VALUE                          shift and go to state 148
    STATEMENT                      shift and go to state 149
    NUMBER                         shift and go to state 150

state 159

    (60) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS . RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    RPAREN          shift and go to state 174


state 160

    (68) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    RPAREN          shift and go to state 175


state 161

    (63) FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE . FOR_BODY_STRUCTURE RCURL_BRACE
    (65) FOR_BODY_STRUCTURE -> . EXPRESSIONS
    (66) FOR_BODY_STRUCTURE -> . BREAK SEMICOLON
    (67) FOR_BODY_STRUCTURE -> . CONTINUE SEMICOLON
    (81) EXPRESSIONS -> . EXPRESSION
    (82) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (79) EXPRESSION -> . CODE SEMICOLON
    (80) EXPRESSION -> . CONTROL_STRUCTURES
    (74) CODE -> . FUNCTION
    (75) CODE -> . INTEGER_DECLARATION
    (76) CODE -> . DECIMAL_DECLARATION
    (77) CODE -> . ASSIGNMENT_DECLARATION
    (78) CODE -> . COMENTARIOLEX
    (47) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (48) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (49) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (50) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (83) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (93) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR STATEMENT
    (106) COMENTARIOLEX -> . COMMENT
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (63) FOR_STRUCTURE -> . FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (54) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (60) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE

    BREAK           shift and go to state 88
    CONTINUE        shift and go to state 89
    VARNAME         shift and go to state 108
    COMMENT         shift and go to state 68
    IF              shift and go to state 48
    FOR             shift and go to state 49
    WHILE           shift and go to state 45
    SWITCH          shift and go to state 47
    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55

    FOR_BODY_STRUCTURE             shift and go to state 176
    EXPRESSIONS                    shift and go to state 177
    EXPRESSION                     shift and go to state 95
    CODE                           shift and go to state 97
    CONTROL_STRUCTURES             shift and go to state 98
    FUNCTION                       shift and go to state 99
    INTEGER_DECLARATION            shift and go to state 100
    DECIMAL_DECLARATION            shift and go to state 101
    ASSIGNMENT_DECLARATION         shift and go to state 102
    COMENTARIOLEX                  shift and go to state 103
    IF_STRUCTURE                   shift and go to state 104
    FOR_STRUCTURE                  shift and go to state 105
    WHILE_STRUCTURE                shift and go to state 106
    SWITCH_STRUCTURE               shift and go to state 107
    INTEGER_TYPE                   shift and go to state 109
    DECIMAL_TYPE                   shift and go to state 110

state 162

    (83) FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS . RPAREN

    RPAREN          shift and go to state 178


state 163

    (85) FUNCTION_ARGUMENTS -> COMPARISONS .

    RPAREN          reduce using rule 85 (FUNCTION_ARGUMENTS -> COMPARISONS .)


state 164

    (131) STATEMENTS -> STATEMENT .
    (132) STATEMENTS -> STATEMENT . COMMA STATEMENTS
    (123) COMPARISON -> STATEMENT . COMPARISON_OPERATOR STATEMENT
    (116) COMPARISON_OPERATOR -> . EQUAL_TO
    (117) COMPARISON_OPERATOR -> . NOT_EQUAL
    (118) COMPARISON_OPERATOR -> . GREATER_THAN
    (119) COMPARISON_OPERATOR -> . LESS_THAN
    (120) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (121) COMPARISON_OPERATOR -> . LESS_EQUAL

    RPAREN          reduce using rule 131 (STATEMENTS -> STATEMENT .)
    COMMA           shift and go to state 117
    EQUAL_TO        shift and go to state 74
    NOT_EQUAL       shift and go to state 75
    GREATER_THAN    shift and go to state 76
    LESS_THAN       shift and go to state 77
    GREATER_EQUAL   shift and go to state 78
    LESS_EQUAL      shift and go to state 79

    COMPARISON_OPERATOR            shift and go to state 116

state 165

    (129) STATEMENT -> NUMBER .
    (42) VALUE -> NUMBER .

  ! reduce/reduce conflict for EQUAL_TO resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 42 (VALUE -> NUMBER .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 42 (VALUE -> NUMBER .)
    COMMA           reduce using rule 129 (STATEMENT -> NUMBER .)
    RPAREN          reduce using rule 129 (STATEMENT -> NUMBER .)
    EQUAL_TO        reduce using rule 42 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 42 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 42 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 42 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 42 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 42 (VALUE -> NUMBER .)

  ! EQUAL_TO        [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! GREATER_THAN    [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! LESS_THAN       [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! GREATER_EQUAL   [ reduce using rule 129 (STATEMENT -> NUMBER .) ]
  ! LESS_EQUAL      [ reduce using rule 129 (STATEMENT -> NUMBER .) ]


state 166

    (93) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR STATEMENT .

    $end            reduce using rule 93 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR STATEMENT .)
    SEMICOLON       reduce using rule 93 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR STATEMENT .)


state 167

    (70) ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS . RCURL_BRACE

    RCURL_BRACE     shift and go to state 179


state 168

    (55) SWITCH_CASE -> CASE INTEGER COLON . EXPRESSIONS BREAK SEMICOLON
    (81) EXPRESSIONS -> . EXPRESSION
    (82) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (79) EXPRESSION -> . CODE SEMICOLON
    (80) EXPRESSION -> . CONTROL_STRUCTURES
    (74) CODE -> . FUNCTION
    (75) CODE -> . INTEGER_DECLARATION
    (76) CODE -> . DECIMAL_DECLARATION
    (77) CODE -> . ASSIGNMENT_DECLARATION
    (78) CODE -> . COMENTARIOLEX
    (47) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (48) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (49) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (50) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (83) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (93) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR STATEMENT
    (106) COMENTARIOLEX -> . COMMENT
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (63) FOR_STRUCTURE -> . FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (54) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (60) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 108
    COMMENT         shift and go to state 68
    IF              shift and go to state 48
    FOR             shift and go to state 49
    WHILE           shift and go to state 45
    SWITCH          shift and go to state 47
    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55

    EXPRESSIONS                    shift and go to state 180
    EXPRESSION                     shift and go to state 95
    CODE                           shift and go to state 97
    CONTROL_STRUCTURES             shift and go to state 98
    FUNCTION                       shift and go to state 99
    INTEGER_DECLARATION            shift and go to state 100
    DECIMAL_DECLARATION            shift and go to state 101
    ASSIGNMENT_DECLARATION         shift and go to state 102
    COMENTARIOLEX                  shift and go to state 103
    IF_STRUCTURE                   shift and go to state 104
    FOR_STRUCTURE                  shift and go to state 105
    WHILE_STRUCTURE                shift and go to state 106
    SWITCH_STRUCTURE               shift and go to state 107
    INTEGER_TYPE                   shift and go to state 109
    DECIMAL_TYPE                   shift and go to state 110

state 169

    (56) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 181


state 170

    (91) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .

    $end            reduce using rule 91 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)
    SEMICOLON       reduce using rule 91 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)


state 171

    (92) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .

    $end            reduce using rule 92 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)
    SEMICOLON       reduce using rule 92 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)


state 172

    (54) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN . LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LCURL_BRACE     shift and go to state 182


state 173

    (64) FOR_ARGUMENTS_STRUCTURE -> LPAREN DECLARATIONS SEMICOLON COMPARISONS . SEMICOLON BUCLE RPAREN

    SEMICOLON       shift and go to state 183


state 174

    (60) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN . LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LCURL_BRACE     shift and go to state 184


state 175

    (68) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LCURL_BRACE     shift and go to state 185


state 176

    (63) FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE . RCURL_BRACE

    RCURL_BRACE     shift and go to state 186


state 177

    (65) FOR_BODY_STRUCTURE -> EXPRESSIONS .

    RCURL_BRACE     reduce using rule 65 (FOR_BODY_STRUCTURE -> EXPRESSIONS .)


state 178

    (83) FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN .

    $end            reduce using rule 83 (FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN .)
    SEMICOLON       reduce using rule 83 (FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN .)


state 179

    (70) ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .

    $end            reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    VARNAME         reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    COMMENT         reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    IF              reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FOR             reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    WHILE           reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SWITCH          reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INT             reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SHORT           reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    LONG            reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FLOAT           reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    DOUBLE          reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    BREAK           reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    CONTINUE        reduce using rule 70 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)


state 180

    (55) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 187


state 181

    (56) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 188


state 182

    (54) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE . BODY_STRUCTURE RCURL_BRACE
    (51) BODY_STRUCTURE -> . EXPRESSIONS
    (52) BODY_STRUCTURE -> . EXPRESSIONS BREAK SEMICOLON
    (53) BODY_STRUCTURE -> . EXPRESSIONS CONTINUE SEMICOLON
    (81) EXPRESSIONS -> . EXPRESSION
    (82) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (79) EXPRESSION -> . CODE SEMICOLON
    (80) EXPRESSION -> . CONTROL_STRUCTURES
    (74) CODE -> . FUNCTION
    (75) CODE -> . INTEGER_DECLARATION
    (76) CODE -> . DECIMAL_DECLARATION
    (77) CODE -> . ASSIGNMENT_DECLARATION
    (78) CODE -> . COMENTARIOLEX
    (47) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (48) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (49) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (50) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (83) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (93) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR STATEMENT
    (106) COMENTARIOLEX -> . COMMENT
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (63) FOR_STRUCTURE -> . FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (54) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (60) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 108
    COMMENT         shift and go to state 68
    IF              shift and go to state 48
    FOR             shift and go to state 49
    WHILE           shift and go to state 45
    SWITCH          shift and go to state 47
    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55

    BODY_STRUCTURE                 shift and go to state 189
    EXPRESSIONS                    shift and go to state 190
    EXPRESSION                     shift and go to state 95
    CODE                           shift and go to state 97
    CONTROL_STRUCTURES             shift and go to state 98
    FUNCTION                       shift and go to state 99
    INTEGER_DECLARATION            shift and go to state 100
    DECIMAL_DECLARATION            shift and go to state 101
    ASSIGNMENT_DECLARATION         shift and go to state 102
    COMENTARIOLEX                  shift and go to state 103
    IF_STRUCTURE                   shift and go to state 104
    FOR_STRUCTURE                  shift and go to state 105
    WHILE_STRUCTURE                shift and go to state 106
    SWITCH_STRUCTURE               shift and go to state 107
    INTEGER_TYPE                   shift and go to state 109
    DECIMAL_TYPE                   shift and go to state 110

state 183

    (64) FOR_ARGUMENTS_STRUCTURE -> LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON . BUCLE RPAREN
    (61) BUCLE -> . VARIABLELEX INCREASE
    (62) BUCLE -> . DECREASE VARIABLELEX
    (107) VARIABLELEX -> . VARNAME

    DECREASE        shift and go to state 85
    VARNAME         shift and go to state 119

    BUCLE                          shift and go to state 191
    VARIABLELEX                    shift and go to state 192

state 184

    (60) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE . SWITCH_BODY RCURL_BRACE
    (57) SWITCH_BODY -> . SWITCH_CASE
    (58) SWITCH_BODY -> . SWITCH_DEFAULT
    (59) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (55) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (56) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    CASE            shift and go to state 90
    DEFAULT         shift and go to state 91

    SWITCH_BODY                    shift and go to state 193
    SWITCH_CASE                    shift and go to state 83
    SWITCH_DEFAULT                 shift and go to state 84

state 185

    (68) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (81) EXPRESSIONS -> . EXPRESSION
    (82) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (79) EXPRESSION -> . CODE SEMICOLON
    (80) EXPRESSION -> . CONTROL_STRUCTURES
    (74) CODE -> . FUNCTION
    (75) CODE -> . INTEGER_DECLARATION
    (76) CODE -> . DECIMAL_DECLARATION
    (77) CODE -> . ASSIGNMENT_DECLARATION
    (78) CODE -> . COMENTARIOLEX
    (47) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (48) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (49) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (50) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (83) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (91) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (92) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (93) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR STATEMENT
    (106) COMENTARIOLEX -> . COMMENT
    (68) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (69) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (63) FOR_STRUCTURE -> . FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE
    (54) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (60) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (86) INTEGER_TYPE -> . INT
    (87) INTEGER_TYPE -> . SHORT
    (88) INTEGER_TYPE -> . LONG
    (89) DECIMAL_TYPE -> . FLOAT
    (90) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 108
    COMMENT         shift and go to state 68
    IF              shift and go to state 48
    FOR             shift and go to state 49
    WHILE           shift and go to state 45
    SWITCH          shift and go to state 47
    INT             shift and go to state 51
    SHORT           shift and go to state 52
    LONG            shift and go to state 53
    FLOAT           shift and go to state 54
    DOUBLE          shift and go to state 55

    EXPRESSIONS                    shift and go to state 194
    EXPRESSION                     shift and go to state 95
    CODE                           shift and go to state 97
    CONTROL_STRUCTURES             shift and go to state 98
    FUNCTION                       shift and go to state 99
    INTEGER_DECLARATION            shift and go to state 100
    DECIMAL_DECLARATION            shift and go to state 101
    ASSIGNMENT_DECLARATION         shift and go to state 102
    COMENTARIOLEX                  shift and go to state 103
    IF_STRUCTURE                   shift and go to state 104
    FOR_STRUCTURE                  shift and go to state 105
    WHILE_STRUCTURE                shift and go to state 106
    SWITCH_STRUCTURE               shift and go to state 107
    INTEGER_TYPE                   shift and go to state 109
    DECIMAL_TYPE                   shift and go to state 110

state 186

    (63) FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .

    $end            reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    VARNAME         reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    COMMENT         reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    IF              reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    FOR             reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    WHILE           reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    SWITCH          reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    INT             reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    SHORT           reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    LONG            reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    FLOAT           reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    DOUBLE          reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    BREAK           reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)
    CONTINUE        reduce using rule 63 (FOR_STRUCTURE -> FOR FOR_ARGUMENTS_STRUCTURE LCURL_BRACE FOR_BODY_STRUCTURE RCURL_BRACE .)


state 187

    (55) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 195


state 188

    (56) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .

    $end            reduce using rule 56 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 56 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)


state 189

    (54) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE . RCURL_BRACE

    RCURL_BRACE     shift and go to state 196


state 190

    (51) BODY_STRUCTURE -> EXPRESSIONS .
    (52) BODY_STRUCTURE -> EXPRESSIONS . BREAK SEMICOLON
    (53) BODY_STRUCTURE -> EXPRESSIONS . CONTINUE SEMICOLON

    RCURL_BRACE     reduce using rule 51 (BODY_STRUCTURE -> EXPRESSIONS .)
    BREAK           shift and go to state 197
    CONTINUE        shift and go to state 198


state 191

    (64) FOR_ARGUMENTS_STRUCTURE -> LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE . RPAREN

    RPAREN          shift and go to state 199


state 192

    (61) BUCLE -> VARIABLELEX . INCREASE

    INCREASE        shift and go to state 113


state 193

    (60) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY . RCURL_BRACE

    RCURL_BRACE     shift and go to state 200


state 194

    (68) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE
    (69) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE ELSE_STRUCTURE

    RCURL_BRACE     shift and go to state 201


state 195

    (55) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .

    CASE            reduce using rule 55 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    DEFAULT         reduce using rule 55 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    $end            reduce using rule 55 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 55 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)


state 196

    (54) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .

    $end            reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    VARNAME         reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    COMMENT         reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    IF              reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    FOR             reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    WHILE           reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SWITCH          reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    INT             reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SHORT           reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    LONG            reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    FLOAT           reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    DOUBLE          reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    BREAK           reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    CONTINUE        reduce using rule 54 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)


state 197

    (52) BODY_STRUCTURE -> EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 202


state 198

    (53) BODY_STRUCTURE -> EXPRESSIONS CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 203


state 199

    (64) FOR_ARGUMENTS_STRUCTURE -> LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .

    $end            reduce using rule 64 (FOR_ARGUMENTS_STRUCTURE -> LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)
    LCURL_BRACE     reduce using rule 64 (FOR_ARGUMENTS_STRUCTURE -> LPAREN DECLARATIONS SEMICOLON COMPARISONS SEMICOLON BUCLE RPAREN .)


state 200

    (60) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .

    $end            reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    VARNAME         reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    COMMENT         reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    IF              reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    FOR             reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    WHILE           reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SWITCH          reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    INT             reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SHORT           reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    LONG            reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    FLOAT           reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    DOUBLE          reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    BREAK           reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    CONTINUE        reduce using rule 60 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)


state 201

    (68) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .
    (69) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE . ELSE_STRUCTURE
    (70) ELSE_STRUCTURE -> . ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (71) ELSE_STRUCTURE -> . ELSE IF_STRUCTURE

    $end            reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    VARNAME         reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    COMMENT         reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    IF              reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FOR             reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    WHILE           reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SWITCH          reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INT             reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SHORT           reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    LONG            reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FLOAT           reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    DOUBLE          reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    BREAK           reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    CONTINUE        reduce using rule 68 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    ELSE            shift and go to state 86

    ELSE_STRUCTURE                 shift and go to state 204

state 202

    (52) BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .

    RCURL_BRACE     reduce using rule 52 (BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .)


state 203

    (53) BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .

    RCURL_BRACE     reduce using rule 53 (BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .)


state 204

    (69) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .

    $end            reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    VARNAME         reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    COMMENT         reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    IF              reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    FOR             reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    WHILE           reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    SWITCH          reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    INT             reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    SHORT           reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    LONG            reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    FLOAT           reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    DOUBLE          reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    RCURL_BRACE     reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    BREAK           reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    CONTINUE        reduce using rule 69 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (ROOT -> DEFINE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> DEFINE) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (ROOT -> INCLUDE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> INCLUDE) in state 4
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (VALUE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (VALUE -> NUMBER)
WARNING: rejected rule (STATEMENT -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (STATEMENT -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (ROOT -> CONTROL_STRUCTURES)
WARNING: rejected rule (EXPRESSION -> CONTROL_STRUCTURES) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (ROOT -> WHILE_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> WHILE_STRUCTURE) in state 8
WARNING: reduce/reduce conflict in state 9 resolved using rule (ROOT -> SWITCH_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> SWITCH_STRUCTURE) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (ROOT -> IF_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> IF_STRUCTURE) in state 10
WARNING: reduce/reduce conflict in state 11 resolved using rule (ROOT -> FOR_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> FOR_STRUCTURE) in state 11
WARNING: reduce/reduce conflict in state 13 resolved using rule (ROOT -> EXPRESSION)
WARNING: rejected rule (EXPRESSIONS -> EXPRESSION) in state 13
WARNING: reduce/reduce conflict in state 14 resolved using rule (ROOT -> EXPRESSIONS)
WARNING: rejected rule (FOR_BODY_STRUCTURE -> EXPRESSIONS) in state 14
WARNING: reduce/reduce conflict in state 15 resolved using rule (ROOT -> FUNCTION)
WARNING: rejected rule (CODE -> FUNCTION) in state 15
WARNING: reduce/reduce conflict in state 18 resolved using rule (ROOT -> INTEGER_DECLARATION)
WARNING: rejected rule (CODE -> INTEGER_DECLARATION) in state 18
WARNING: reduce/reduce conflict in state 18 resolved using rule (ROOT -> INTEGER_DECLARATION)
WARNING: rejected rule (DECLARATIONS -> INTEGER_DECLARATION) in state 18
WARNING: reduce/reduce conflict in state 19 resolved using rule (ROOT -> DECIMAL_DECLARATION)
WARNING: rejected rule (CODE -> DECIMAL_DECLARATION) in state 19
WARNING: reduce/reduce conflict in state 19 resolved using rule (ROOT -> DECIMAL_DECLARATION)
WARNING: rejected rule (DECLARATIONS -> DECIMAL_DECLARATION) in state 19
WARNING: reduce/reduce conflict in state 20 resolved using rule (ROOT -> ASSIGNMENT_DECLARATION)
WARNING: rejected rule (CODE -> ASSIGNMENT_DECLARATION) in state 20
WARNING: reduce/reduce conflict in state 22 resolved using rule (ROOT -> COMENTARIOLEX)
WARNING: rejected rule (CODE -> COMENTARIOLEX) in state 22
WARNING: reduce/reduce conflict in state 25 resolved using rule (ROOT -> OPERATION)
WARNING: rejected rule (OPERATIONS -> OPERATION) in state 25
WARNING: reduce/reduce conflict in state 28 resolved using rule (ROOT -> COMPARISON)
WARNING: rejected rule (COMPARISONS -> COMPARISON) in state 28
WARNING: reduce/reduce conflict in state 29 resolved using rule (ROOT -> COMPARISONS)
WARNING: rejected rule (FUNCTION_ARGUMENTS -> COMPARISONS) in state 29
WARNING: reduce/reduce conflict in state 31 resolved using rule (ROOT -> STATEMENT)
WARNING: rejected rule (STATEMENTS -> STATEMENT) in state 31
WARNING: reduce/reduce conflict in state 50 resolved using rule (VARIABLELEX -> VARNAME)
WARNING: rejected rule (STATEMENT -> VARNAME) in state 50
WARNING: reduce/reduce conflict in state 150 resolved using rule (VALUE -> NUMBER)
WARNING: rejected rule (STATEMENT -> NUMBER) in state 150
WARNING: reduce/reduce conflict in state 165 resolved using rule (VALUE -> NUMBER)
WARNING: rejected rule (STATEMENT -> NUMBER) in state 165
WARNING: Rule (PREPROCESOR_DIRECTIVE -> DEFINE) is never reduced
WARNING: Rule (PREPROCESOR_DIRECTIVE -> INCLUDE) is never reduced
