Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AUTO
    BACKSLASH
    BACKSPACE
    B_AND
    B_COMPLEMENT
    B_OR
    B_XOR
    CHAR
    CHARACTER
    CONST
    DO
    DOT
    DOUBLE_APOS
    DOUBLE_QUOTE
    ENUM
    EXTERN
    FF_PAGEBREAK
    FOR
    FS_CHAR
    FS_DOUBLE
    FS_FLOAT
    FS_HEX
    FS_INT
    FS_LONG
    FS_LONG_DOUBLE
    FS_OCT
    FS_OCT_LONG
    FS_POINTER
    FS_SCI_NOTATION
    FS_STRING
    FS_UNSIGNED_INT
    FS_UNSIGNED_LONG
    GOTO
    HTAB
    IGNORE
    LBRACKET
    NEWLINE
    NULL
    PP_DATE
    PP_DTMACRO
    PP_ERROR
    PP_FILE
    PP_IF
    PP_IFDEF
    PP_IFNDEF
    PP_LINE
    PP_PRAGMA
    PP_STMACRO
    PP_TIME
    PP_TIMESTAMP
    PP_UNDEF
    QUESTIONMARK
    RBRACKET
    REGISTER
    RETURN
    SHIFT_LEFT
    SHIFT_RIGHT
    SIGNED
    SINGLE_APOS
    SINGLE_QUOTE
    SIZEOF
    STATIC
    STRUCT
    TILDE
    TYPEDEF
    UNION
    UNSIGNED
    VOID
    VOLTILE
    VTAB

Grammar

Rule 0     S' -> ROOT
Rule 1     ROOT -> PREPROCESOR_DIRECTIVE
Rule 2     ROOT -> DEFINE
Rule 3     ROOT -> INCLUDE
Rule 4     ROOT -> VALUE
Rule 5     ROOT -> NUMBER
Rule 6     ROOT -> CONTROL_STRUCTURES
Rule 7     ROOT -> WHILE_STRUCTURE
Rule 8     ROOT -> SWITCH_STRUCTURE
Rule 9     ROOT -> IF_STRUCTURE
Rule 10    ROOT -> FOR_STRUCTURE
Rule 11    ROOT -> CODE
Rule 12    ROOT -> EXPRESSION
Rule 13    ROOT -> EXPRESSIONS
Rule 14    ROOT -> FUNCTION
Rule 15    ROOT -> INTEGER_TYPE
Rule 16    ROOT -> DECIMAL_TYPE
Rule 17    ROOT -> INTEGER_DECLARATION
Rule 18    ROOT -> DECIMAL_DECLARATION
Rule 19    ROOT -> ASSIGNMENT_DECLARATION
Rule 20    ROOT -> ASSIGNMENT_OPERATOR
Rule 21    ROOT -> COMENTARIOLEX
Rule 22    ROOT -> VARIABLELEX
Rule 23    ROOT -> OPERATOR
Rule 24    ROOT -> OPERATION
Rule 25    ROOT -> OPERATIONS
Rule 26    ROOT -> COMPARISON_OPERATOR
Rule 27    ROOT -> COMPARISON
Rule 28    ROOT -> COMPARISONS
Rule 29    ROOT -> LOGICAL_OPERATOR
Rule 30    ROOT -> SENTENCE
Rule 31    ROOT -> SWITCH_BODY
Rule 32    ROOT -> BUCLE
Rule 33    ROOT -> ELSE_STRUCTURE
Rule 34    ROOT -> FUNCTION_ARGUMENTS
Rule 35    PREPROCESOR_DIRECTIVE -> DEFINE
Rule 36    PREPROCESOR_DIRECTIVE -> INCLUDE
Rule 37    DEFINE -> PP_DEFINE VARIABLELEX VALUE
Rule 38    INCLUDE -> PP_INCLUDE HEADER_LIB
Rule 39    VALUE -> NUMBER
Rule 40    VALUE -> STRING
Rule 41    NUMBER -> INTEGER
Rule 42    NUMBER -> DECIMAL
Rule 43    CONTROL_STRUCTURES -> IF_STRUCTURE
Rule 44    CONTROL_STRUCTURES -> FOR_STRUCTURE
Rule 45    CONTROL_STRUCTURES -> WHILE_STRUCTURE
Rule 46    CONTROL_STRUCTURES -> SWITCH_STRUCTURE
Rule 47    BODY_STRUCTURE -> EXPRESSIONS
Rule 48    BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON
Rule 49    BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON
Rule 50    WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
Rule 51    SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
Rule 52    SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON
Rule 53    SWITCH_BODY -> SWITCH_CASE
Rule 54    SWITCH_BODY -> SWITCH_DEFAULT
Rule 55    SWITCH_BODY -> SWITCH_CASE SWITCH_BODY
Rule 56    SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
Rule 57    BUCLE -> VARIABLELEX INCREASE
Rule 58    BUCLE -> DECREASE VARIABLELEX
Rule 59    FOR_STRUCTURE -> INTEGER
Rule 60    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 61    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
Rule 62    ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 63    ELSE_STRUCTURE -> ELSE IF_STRUCTURE
Rule 64    CODE -> FUNCTION
Rule 65    CODE -> INTEGER_DECLARATION
Rule 66    CODE -> DECIMAL_DECLARATION
Rule 67    CODE -> ASSIGNMENT_DECLARATION
Rule 68    CODE -> COMENTARIOLEX
Rule 69    EXPRESSION -> CODE SEMICOLON
Rule 70    EXPRESSION -> CONTROL_STRUCTURES
Rule 71    EXPRESSIONS -> EXPRESSION
Rule 72    EXPRESSIONS -> EXPRESSION EXPRESSIONS
Rule 73    FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
Rule 74    FUNCTION_ARGUMENTS -> SENTENCES
Rule 75    FUNCTION_ARGUMENTS -> COMPARISONS
Rule 76    INTEGER_TYPE -> INT
Rule 77    INTEGER_TYPE -> SHORT
Rule 78    INTEGER_TYPE -> LONG
Rule 79    DECIMAL_TYPE -> FLOAT
Rule 80    DECIMAL_TYPE -> DOUBLE
Rule 81    INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER
Rule 82    DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL
Rule 83    ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE
Rule 84    ASSIGNMENT_OPERATOR -> EQUAL
Rule 85    ASSIGNMENT_OPERATOR -> PLUS_EQUAL
Rule 86    ASSIGNMENT_OPERATOR -> MINUS_EQUAL
Rule 87    ASSIGNMENT_OPERATOR -> DIV_EQUAL
Rule 88    ASSIGNMENT_OPERATOR -> TIMES_EQUAL
Rule 89    ASSIGNMENT_OPERATOR -> MOD_EQUAL
Rule 90    ASSIGNMENT_OPERATOR -> AND_EQUAL
Rule 91    ASSIGNMENT_OPERATOR -> OR_EQUAL
Rule 92    ASSIGNMENT_OPERATOR -> XOR_EQUAL
Rule 93    ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL
Rule 94    ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL
Rule 95    ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL
Rule 96    COMENTARIOLEX -> COMMENT
Rule 97    VARIABLELEX -> VARNAME
Rule 98    OPERATOR -> PLUS
Rule 99    OPERATOR -> MINUS
Rule 100   OPERATOR -> TIMES
Rule 101   OPERATOR -> MODULUS
Rule 102   OPERATOR -> DIVIDE
Rule 103   OPERATION -> NUMBER OPERATOR NUMBER
Rule 104   OPERATIONS -> OPERATION
Rule 105   OPERATIONS -> OPERATION OPERATOR OPERATIONS
Rule 106   COMPARISON_OPERATOR -> EQUAL_TO
Rule 107   COMPARISON_OPERATOR -> NOT_EQUAL
Rule 108   COMPARISON_OPERATOR -> GREATER_THAN
Rule 109   COMPARISON_OPERATOR -> LESS_THAN
Rule 110   COMPARISON_OPERATOR -> GREATER_EQUAL
Rule 111   COMPARISON_OPERATOR -> LESS_EQUAL
Rule 112   COMPARISON -> VALUE COMPARISON_OPERATOR VALUE
Rule 113   COMPARISONS -> COMPARISON
Rule 114   COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS
Rule 115   LOGICAL_OPERATOR -> AND
Rule 116   LOGICAL_OPERATOR -> OR
Rule 117   LOGICAL_OPERATOR -> NOT
Rule 118   SENTENCE -> NUMBER
Rule 119   SENTENCE -> VARNAME
Rule 120   SENTENCES -> SENTENCE
Rule 121   SENTENCES -> SENTENCE COMMA SENTENCES

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 115
AND_EQUAL            : 90
AUTO                 : 
BACKSLASH            : 
BACKSPACE            : 
BREAK                : 48 51 52
B_AND                : 
B_COMPLEMENT         : 
B_OR                 : 
B_XOR                : 
CASE                 : 51
CHAR                 : 
CHARACTER            : 
COLON                : 51 52
COMMA                : 121
COMMENT              : 96
COMPLEMENT_EQUAL     : 93
CONST                : 
CONTINUE             : 49
DECIMAL              : 42 82
DECREASE             : 58
DEFAULT              : 52
DIVIDE               : 102
DIV_EQUAL            : 87
DO                   : 
DOT                  : 
DOUBLE               : 80
DOUBLE_APOS          : 
DOUBLE_QUOTE         : 
ELSE                 : 62 63
ENUM                 : 
EQUAL                : 81 82 84
EQUAL_TO             : 106
EXTERN               : 
FF_PAGEBREAK         : 
FLOAT                : 79
FOR                  : 
FS_CHAR              : 
FS_DOUBLE            : 
FS_FLOAT             : 
FS_HEX               : 
FS_INT               : 
FS_LONG              : 
FS_LONG_DOUBLE       : 
FS_OCT               : 
FS_OCT_LONG          : 
FS_POINTER           : 
FS_SCI_NOTATION      : 
FS_STRING            : 
FS_UNSIGNED_INT      : 
FS_UNSIGNED_LONG     : 
GOTO                 : 
GREATER_EQUAL        : 110
GREATER_THAN         : 108
HEADER_LIB           : 38
HTAB                 : 
IF                   : 60 61
IGNORE               : 
INCREASE             : 57
INT                  : 76
INTEGER              : 41 51 59 81
LBRACKET             : 
LCURL_BRACE          : 50 56 60 61 62
LESS_EQUAL           : 111
LESS_THAN            : 109
LONG                 : 78
LPAREN               : 50 56 60 61 73
MINUS                : 99
MINUS_EQUAL          : 86
MODULUS              : 101
MOD_EQUAL            : 89
NEWLINE              : 
NOT                  : 117
NOT_EQUAL            : 107
NULL                 : 
OR                   : 116
OR_EQUAL             : 91
PLUS                 : 98
PLUS_EQUAL           : 85
PP_DATE              : 
PP_DEFINE            : 37
PP_DTMACRO           : 
PP_ERROR             : 
PP_FILE              : 
PP_IF                : 
PP_IFDEF             : 
PP_IFNDEF            : 
PP_INCLUDE           : 38
PP_LINE              : 
PP_PRAGMA            : 
PP_STMACRO           : 
PP_TIME              : 
PP_TIMESTAMP         : 
PP_UNDEF             : 
QUESTIONMARK         : 
RBRACKET             : 
RCURL_BRACE          : 50 56 60 61 62
REGISTER             : 
RETURN               : 
RPAREN               : 50 56 60 61 73
SEMICOLON            : 48 49 51 52 69
SHIFTL_EQUAL         : 94
SHIFTR_EQUAL         : 95
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
SHORT                : 77
SIGNED               : 
SINGLE_APOS          : 
SINGLE_QUOTE         : 
SIZEOF               : 
STATIC               : 
STRING               : 40
STRUCT               : 
SWITCH               : 56
TILDE                : 
TIMES                : 100
TIMES_EQUAL          : 88
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VARNAME              : 73 81 82 83 97 119
VOID                 : 
VOLTILE              : 
VTAB                 : 
WHILE                : 50
XOR_EQUAL            : 92
error                : 

Nonterminals, with rules where they appear

ASSIGNMENT_DECLARATION : 19 67
ASSIGNMENT_OPERATOR  : 20 83
BODY_STRUCTURE       : 50
BUCLE                : 32
CODE                 : 11 69
COMENTARIOLEX        : 21 68
COMPARISON           : 27 113 114
COMPARISONS          : 28 50 56 60 61 75 114
COMPARISON_OPERATOR  : 26 112
CONTROL_STRUCTURES   : 6 70
DECIMAL_DECLARATION  : 18 66
DECIMAL_TYPE         : 16 82
DEFINE               : 2 35
ELSE_STRUCTURE       : 33 61
EXPRESSION           : 12 71 72
EXPRESSIONS          : 13 47 48 49 51 52 60 61 62 72
FOR_STRUCTURE        : 10 44
FUNCTION             : 14 64
FUNCTION_ARGUMENTS   : 34 73
IF_STRUCTURE         : 9 43 63
INCLUDE              : 3 36
INTEGER_DECLARATION  : 17 65
INTEGER_TYPE         : 15 81
LOGICAL_OPERATOR     : 29 114
NUMBER               : 5 39 103 103 118
OPERATION            : 24 104 105
OPERATIONS           : 25 105
OPERATOR             : 23 103 105
PREPROCESOR_DIRECTIVE : 1
ROOT                 : 0
SENTENCE             : 30 83 120 121
SENTENCES            : 74 121
SWITCH_BODY          : 31 55 56
SWITCH_CASE          : 53 55
SWITCH_DEFAULT       : 54
SWITCH_STRUCTURE     : 8 46
VALUE                : 4 37 112 112
VARIABLELEX          : 22 37 57 58
WHILE_STRUCTURE      : 7 45

Parsing method: LALR

state 0

    (0) S' -> . ROOT
    (1) ROOT -> . PREPROCESOR_DIRECTIVE
    (2) ROOT -> . DEFINE
    (3) ROOT -> . INCLUDE
    (4) ROOT -> . VALUE
    (5) ROOT -> . NUMBER
    (6) ROOT -> . CONTROL_STRUCTURES
    (7) ROOT -> . WHILE_STRUCTURE
    (8) ROOT -> . SWITCH_STRUCTURE
    (9) ROOT -> . IF_STRUCTURE
    (10) ROOT -> . FOR_STRUCTURE
    (11) ROOT -> . CODE
    (12) ROOT -> . EXPRESSION
    (13) ROOT -> . EXPRESSIONS
    (14) ROOT -> . FUNCTION
    (15) ROOT -> . INTEGER_TYPE
    (16) ROOT -> . DECIMAL_TYPE
    (17) ROOT -> . INTEGER_DECLARATION
    (18) ROOT -> . DECIMAL_DECLARATION
    (19) ROOT -> . ASSIGNMENT_DECLARATION
    (20) ROOT -> . ASSIGNMENT_OPERATOR
    (21) ROOT -> . COMENTARIOLEX
    (22) ROOT -> . VARIABLELEX
    (23) ROOT -> . OPERATOR
    (24) ROOT -> . OPERATION
    (25) ROOT -> . OPERATIONS
    (26) ROOT -> . COMPARISON_OPERATOR
    (27) ROOT -> . COMPARISON
    (28) ROOT -> . COMPARISONS
    (29) ROOT -> . LOGICAL_OPERATOR
    (30) ROOT -> . SENTENCE
    (31) ROOT -> . SWITCH_BODY
    (32) ROOT -> . BUCLE
    (33) ROOT -> . ELSE_STRUCTURE
    (34) ROOT -> . FUNCTION_ARGUMENTS
    (35) PREPROCESOR_DIRECTIVE -> . DEFINE
    (36) PREPROCESOR_DIRECTIVE -> . INCLUDE
    (37) DEFINE -> . PP_DEFINE VARIABLELEX VALUE
    (38) INCLUDE -> . PP_INCLUDE HEADER_LIB
    (39) VALUE -> . NUMBER
    (40) VALUE -> . STRING
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL
    (43) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (44) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (45) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (46) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (50) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (56) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (59) FOR_STRUCTURE -> . INTEGER
    (64) CODE -> . FUNCTION
    (65) CODE -> . INTEGER_DECLARATION
    (66) CODE -> . DECIMAL_DECLARATION
    (67) CODE -> . ASSIGNMENT_DECLARATION
    (68) CODE -> . COMENTARIOLEX
    (69) EXPRESSION -> . CODE SEMICOLON
    (70) EXPRESSION -> . CONTROL_STRUCTURES
    (71) EXPRESSIONS -> . EXPRESSION
    (72) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (73) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (76) INTEGER_TYPE -> . INT
    (77) INTEGER_TYPE -> . SHORT
    (78) INTEGER_TYPE -> . LONG
    (79) DECIMAL_TYPE -> . FLOAT
    (80) DECIMAL_TYPE -> . DOUBLE
    (81) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (82) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (83) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (84) ASSIGNMENT_OPERATOR -> . EQUAL
    (85) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (86) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (87) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (88) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (89) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (90) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (91) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (92) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (93) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (94) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (95) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL
    (96) COMENTARIOLEX -> . COMMENT
    (97) VARIABLELEX -> . VARNAME
    (98) OPERATOR -> . PLUS
    (99) OPERATOR -> . MINUS
    (100) OPERATOR -> . TIMES
    (101) OPERATOR -> . MODULUS
    (102) OPERATOR -> . DIVIDE
    (103) OPERATION -> . NUMBER OPERATOR NUMBER
    (104) OPERATIONS -> . OPERATION
    (105) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (106) COMPARISON_OPERATOR -> . EQUAL_TO
    (107) COMPARISON_OPERATOR -> . NOT_EQUAL
    (108) COMPARISON_OPERATOR -> . GREATER_THAN
    (109) COMPARISON_OPERATOR -> . LESS_THAN
    (110) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (111) COMPARISON_OPERATOR -> . LESS_EQUAL
    (112) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (113) COMPARISONS -> . COMPARISON
    (114) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (115) LOGICAL_OPERATOR -> . AND
    (116) LOGICAL_OPERATOR -> . OR
    (117) LOGICAL_OPERATOR -> . NOT
    (118) SENTENCE -> . NUMBER
    (119) SENTENCE -> . VARNAME
    (53) SWITCH_BODY -> . SWITCH_CASE
    (54) SWITCH_BODY -> . SWITCH_DEFAULT
    (55) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (57) BUCLE -> . VARIABLELEX INCREASE
    (58) BUCLE -> . DECREASE VARIABLELEX
    (62) ELSE_STRUCTURE -> . ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (63) ELSE_STRUCTURE -> . ELSE IF_STRUCTURE
    (74) FUNCTION_ARGUMENTS -> . SENTENCES
    (75) FUNCTION_ARGUMENTS -> . COMPARISONS
    (51) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (52) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON
    (120) SENTENCES -> . SENTENCE
    (121) SENTENCES -> . SENTENCE COMMA SENTENCES

    PP_DEFINE       shift and go to state 36
    PP_INCLUDE      shift and go to state 37
    STRING          shift and go to state 38
    INTEGER         shift and go to state 39
    DECIMAL         shift and go to state 40
    WHILE           shift and go to state 41
    SWITCH          shift and go to state 42
    IF              shift and go to state 43
    VARNAME         shift and go to state 44
    INT             shift and go to state 45
    SHORT           shift and go to state 46
    LONG            shift and go to state 47
    FLOAT           shift and go to state 48
    DOUBLE          shift and go to state 49
    EQUAL           shift and go to state 50
    PLUS_EQUAL      shift and go to state 51
    MINUS_EQUAL     shift and go to state 52
    DIV_EQUAL       shift and go to state 53
    TIMES_EQUAL     shift and go to state 54
    MOD_EQUAL       shift and go to state 55
    AND_EQUAL       shift and go to state 56
    OR_EQUAL        shift and go to state 57
    XOR_EQUAL       shift and go to state 58
    COMPLEMENT_EQUAL shift and go to state 59
    SHIFTL_EQUAL    shift and go to state 60
    SHIFTR_EQUAL    shift and go to state 61
    COMMENT         shift and go to state 62
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    MODULUS         shift and go to state 66
    DIVIDE          shift and go to state 67
    EQUAL_TO        shift and go to state 68
    NOT_EQUAL       shift and go to state 69
    GREATER_THAN    shift and go to state 70
    LESS_THAN       shift and go to state 71
    GREATER_EQUAL   shift and go to state 72
    LESS_EQUAL      shift and go to state 73
    AND             shift and go to state 74
    OR              shift and go to state 75
    NOT             shift and go to state 76
    DECREASE        shift and go to state 79
    ELSE            shift and go to state 80
    CASE            shift and go to state 82
    DEFAULT         shift and go to state 83

    ROOT                           shift and go to state 1
    PREPROCESOR_DIRECTIVE          shift and go to state 2
    DEFINE                         shift and go to state 3
    INCLUDE                        shift and go to state 4
    VALUE                          shift and go to state 5
    NUMBER                         shift and go to state 6
    CONTROL_STRUCTURES             shift and go to state 7
    WHILE_STRUCTURE                shift and go to state 8
    SWITCH_STRUCTURE               shift and go to state 9
    IF_STRUCTURE                   shift and go to state 10
    FOR_STRUCTURE                  shift and go to state 11
    CODE                           shift and go to state 12
    EXPRESSION                     shift and go to state 13
    EXPRESSIONS                    shift and go to state 14
    FUNCTION                       shift and go to state 15
    INTEGER_TYPE                   shift and go to state 16
    DECIMAL_TYPE                   shift and go to state 17
    INTEGER_DECLARATION            shift and go to state 18
    DECIMAL_DECLARATION            shift and go to state 19
    ASSIGNMENT_DECLARATION         shift and go to state 20
    ASSIGNMENT_OPERATOR            shift and go to state 21
    COMENTARIOLEX                  shift and go to state 22
    VARIABLELEX                    shift and go to state 23
    OPERATOR                       shift and go to state 24
    OPERATION                      shift and go to state 25
    OPERATIONS                     shift and go to state 26
    COMPARISON_OPERATOR            shift and go to state 27
    COMPARISON                     shift and go to state 28
    COMPARISONS                    shift and go to state 29
    LOGICAL_OPERATOR               shift and go to state 30
    SENTENCE                       shift and go to state 31
    SWITCH_BODY                    shift and go to state 32
    BUCLE                          shift and go to state 33
    ELSE_STRUCTURE                 shift and go to state 34
    FUNCTION_ARGUMENTS             shift and go to state 35
    SWITCH_CASE                    shift and go to state 77
    SWITCH_DEFAULT                 shift and go to state 78
    SENTENCES                      shift and go to state 81

state 1

    (0) S' -> ROOT .



state 2

    (1) ROOT -> PREPROCESOR_DIRECTIVE .

    $end            reduce using rule 1 (ROOT -> PREPROCESOR_DIRECTIVE .)


state 3

    (2) ROOT -> DEFINE .
    (35) PREPROCESOR_DIRECTIVE -> DEFINE .

  ! reduce/reduce conflict for $end resolved using rule 2 (ROOT -> DEFINE .)
    $end            reduce using rule 2 (ROOT -> DEFINE .)

  ! $end            [ reduce using rule 35 (PREPROCESOR_DIRECTIVE -> DEFINE .) ]


state 4

    (3) ROOT -> INCLUDE .
    (36) PREPROCESOR_DIRECTIVE -> INCLUDE .

  ! reduce/reduce conflict for $end resolved using rule 3 (ROOT -> INCLUDE .)
    $end            reduce using rule 3 (ROOT -> INCLUDE .)

  ! $end            [ reduce using rule 36 (PREPROCESOR_DIRECTIVE -> INCLUDE .) ]


state 5

    (4) ROOT -> VALUE .
    (112) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (106) COMPARISON_OPERATOR -> . EQUAL_TO
    (107) COMPARISON_OPERATOR -> . NOT_EQUAL
    (108) COMPARISON_OPERATOR -> . GREATER_THAN
    (109) COMPARISON_OPERATOR -> . LESS_THAN
    (110) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (111) COMPARISON_OPERATOR -> . LESS_EQUAL

    $end            reduce using rule 4 (ROOT -> VALUE .)
    EQUAL_TO        shift and go to state 68
    NOT_EQUAL       shift and go to state 69
    GREATER_THAN    shift and go to state 70
    LESS_THAN       shift and go to state 71
    GREATER_EQUAL   shift and go to state 72
    LESS_EQUAL      shift and go to state 73

    COMPARISON_OPERATOR            shift and go to state 84

state 6

    (5) ROOT -> NUMBER .
    (39) VALUE -> NUMBER .
    (103) OPERATION -> NUMBER . OPERATOR NUMBER
    (118) SENTENCE -> NUMBER .
    (98) OPERATOR -> . PLUS
    (99) OPERATOR -> . MINUS
    (100) OPERATOR -> . TIMES
    (101) OPERATOR -> . MODULUS
    (102) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
    $end            reduce using rule 5 (ROOT -> NUMBER .)
    EQUAL_TO        reduce using rule 39 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 39 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 39 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 39 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 39 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 39 (VALUE -> NUMBER .)
    COMMA           reduce using rule 118 (SENTENCE -> NUMBER .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    MODULUS         shift and go to state 66
    DIVIDE          shift and go to state 67

  ! $end            [ reduce using rule 39 (VALUE -> NUMBER .) ]
  ! $end            [ reduce using rule 118 (SENTENCE -> NUMBER .) ]

    OPERATOR                       shift and go to state 85

state 7

    (6) ROOT -> CONTROL_STRUCTURES .
    (70) EXPRESSION -> CONTROL_STRUCTURES .

  ! reduce/reduce conflict for $end resolved using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    $end            reduce using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    VARNAME         reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    INTEGER         reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)

  ! $end            [ reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .) ]


state 8

    (7) ROOT -> WHILE_STRUCTURE .
    (45) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 7 (ROOT -> WHILE_STRUCTURE .)
    $end            reduce using rule 7 (ROOT -> WHILE_STRUCTURE .)
    VARNAME         reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INTEGER         reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)

  ! $end            [ reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .) ]


state 9

    (8) ROOT -> SWITCH_STRUCTURE .
    (46) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    $end            reduce using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    VARNAME         reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INTEGER         reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)

  ! $end            [ reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .) ]


state 10

    (9) ROOT -> IF_STRUCTURE .
    (43) CONTROL_STRUCTURES -> IF_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 9 (ROOT -> IF_STRUCTURE .)
    $end            reduce using rule 9 (ROOT -> IF_STRUCTURE .)
    VARNAME         reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INTEGER         reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)

  ! $end            [ reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .) ]


state 11

    (10) ROOT -> FOR_STRUCTURE .
    (44) CONTROL_STRUCTURES -> FOR_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 10 (ROOT -> FOR_STRUCTURE .)
    $end            reduce using rule 10 (ROOT -> FOR_STRUCTURE .)
    VARNAME         reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INTEGER         reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)

  ! $end            [ reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .) ]


state 12

    (11) ROOT -> CODE .
    (69) EXPRESSION -> CODE . SEMICOLON

    $end            reduce using rule 11 (ROOT -> CODE .)
    SEMICOLON       shift and go to state 86


state 13

    (12) ROOT -> EXPRESSION .
    (71) EXPRESSIONS -> EXPRESSION .
    (72) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (71) EXPRESSIONS -> . EXPRESSION
    (72) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (69) EXPRESSION -> . CODE SEMICOLON
    (70) EXPRESSION -> . CONTROL_STRUCTURES
    (64) CODE -> . FUNCTION
    (65) CODE -> . INTEGER_DECLARATION
    (66) CODE -> . DECIMAL_DECLARATION
    (67) CODE -> . ASSIGNMENT_DECLARATION
    (68) CODE -> . COMENTARIOLEX
    (43) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (44) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (45) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (46) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (73) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (81) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (82) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (83) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (96) COMENTARIOLEX -> . COMMENT
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (59) FOR_STRUCTURE -> . INTEGER
    (50) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (56) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (76) INTEGER_TYPE -> . INT
    (77) INTEGER_TYPE -> . SHORT
    (78) INTEGER_TYPE -> . LONG
    (79) DECIMAL_TYPE -> . FLOAT
    (80) DECIMAL_TYPE -> . DOUBLE

  ! reduce/reduce conflict for $end resolved using rule 12 (ROOT -> EXPRESSION .)
    $end            reduce using rule 12 (ROOT -> EXPRESSION .)
    VARNAME         shift and go to state 100
    COMMENT         shift and go to state 62
    IF              shift and go to state 43
    INTEGER         shift and go to state 102
    WHILE           shift and go to state 41
    SWITCH          shift and go to state 42
    INT             shift and go to state 45
    SHORT           shift and go to state 46
    LONG            shift and go to state 47
    FLOAT           shift and go to state 48
    DOUBLE          shift and go to state 49

  ! $end            [ reduce using rule 71 (EXPRESSIONS -> EXPRESSION .) ]

    EXPRESSION                     shift and go to state 87
    EXPRESSIONS                    shift and go to state 88
    CODE                           shift and go to state 89
    CONTROL_STRUCTURES             shift and go to state 90
    FUNCTION                       shift and go to state 91
    INTEGER_DECLARATION            shift and go to state 92
    DECIMAL_DECLARATION            shift and go to state 93
    ASSIGNMENT_DECLARATION         shift and go to state 94
    COMENTARIOLEX                  shift and go to state 95
    IF_STRUCTURE                   shift and go to state 96
    FOR_STRUCTURE                  shift and go to state 97
    WHILE_STRUCTURE                shift and go to state 98
    SWITCH_STRUCTURE               shift and go to state 99
    INTEGER_TYPE                   shift and go to state 101
    DECIMAL_TYPE                   shift and go to state 103

state 14

    (13) ROOT -> EXPRESSIONS .

    $end            reduce using rule 13 (ROOT -> EXPRESSIONS .)


state 15

    (14) ROOT -> FUNCTION .
    (64) CODE -> FUNCTION .

  ! reduce/reduce conflict for $end resolved using rule 14 (ROOT -> FUNCTION .)
    $end            reduce using rule 14 (ROOT -> FUNCTION .)
    SEMICOLON       reduce using rule 64 (CODE -> FUNCTION .)

  ! $end            [ reduce using rule 64 (CODE -> FUNCTION .) ]


state 16

    (15) ROOT -> INTEGER_TYPE .
    (81) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    $end            reduce using rule 15 (ROOT -> INTEGER_TYPE .)
    VARNAME         shift and go to state 104


state 17

    (16) ROOT -> DECIMAL_TYPE .
    (82) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    $end            reduce using rule 16 (ROOT -> DECIMAL_TYPE .)
    VARNAME         shift and go to state 105


state 18

    (17) ROOT -> INTEGER_DECLARATION .
    (65) CODE -> INTEGER_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 17 (ROOT -> INTEGER_DECLARATION .)
    $end            reduce using rule 17 (ROOT -> INTEGER_DECLARATION .)
    SEMICOLON       reduce using rule 65 (CODE -> INTEGER_DECLARATION .)

  ! $end            [ reduce using rule 65 (CODE -> INTEGER_DECLARATION .) ]


state 19

    (18) ROOT -> DECIMAL_DECLARATION .
    (66) CODE -> DECIMAL_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    $end            reduce using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    SEMICOLON       reduce using rule 66 (CODE -> DECIMAL_DECLARATION .)

  ! $end            [ reduce using rule 66 (CODE -> DECIMAL_DECLARATION .) ]


state 20

    (19) ROOT -> ASSIGNMENT_DECLARATION .
    (67) CODE -> ASSIGNMENT_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    $end            reduce using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    SEMICOLON       reduce using rule 67 (CODE -> ASSIGNMENT_DECLARATION .)

  ! $end            [ reduce using rule 67 (CODE -> ASSIGNMENT_DECLARATION .) ]


state 21

    (20) ROOT -> ASSIGNMENT_OPERATOR .

    $end            reduce using rule 20 (ROOT -> ASSIGNMENT_OPERATOR .)


state 22

    (21) ROOT -> COMENTARIOLEX .
    (68) CODE -> COMENTARIOLEX .

  ! reduce/reduce conflict for $end resolved using rule 21 (ROOT -> COMENTARIOLEX .)
    $end            reduce using rule 21 (ROOT -> COMENTARIOLEX .)
    SEMICOLON       reduce using rule 68 (CODE -> COMENTARIOLEX .)

  ! $end            [ reduce using rule 68 (CODE -> COMENTARIOLEX .) ]


state 23

    (22) ROOT -> VARIABLELEX .
    (57) BUCLE -> VARIABLELEX . INCREASE

    $end            reduce using rule 22 (ROOT -> VARIABLELEX .)
    INCREASE        shift and go to state 106


state 24

    (23) ROOT -> OPERATOR .

    $end            reduce using rule 23 (ROOT -> OPERATOR .)


state 25

    (24) ROOT -> OPERATION .
    (104) OPERATIONS -> OPERATION .
    (105) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (98) OPERATOR -> . PLUS
    (99) OPERATOR -> . MINUS
    (100) OPERATOR -> . TIMES
    (101) OPERATOR -> . MODULUS
    (102) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 24 (ROOT -> OPERATION .)
    $end            reduce using rule 24 (ROOT -> OPERATION .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    MODULUS         shift and go to state 66
    DIVIDE          shift and go to state 67

  ! $end            [ reduce using rule 104 (OPERATIONS -> OPERATION .) ]

    OPERATOR                       shift and go to state 107

state 26

    (25) ROOT -> OPERATIONS .

    $end            reduce using rule 25 (ROOT -> OPERATIONS .)


state 27

    (26) ROOT -> COMPARISON_OPERATOR .

    $end            reduce using rule 26 (ROOT -> COMPARISON_OPERATOR .)


state 28

    (27) ROOT -> COMPARISON .
    (113) COMPARISONS -> COMPARISON .
    (114) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (115) LOGICAL_OPERATOR -> . AND
    (116) LOGICAL_OPERATOR -> . OR
    (117) LOGICAL_OPERATOR -> . NOT

  ! reduce/reduce conflict for $end resolved using rule 27 (ROOT -> COMPARISON .)
    $end            reduce using rule 27 (ROOT -> COMPARISON .)
    AND             shift and go to state 74
    OR              shift and go to state 75
    NOT             shift and go to state 76

  ! $end            [ reduce using rule 113 (COMPARISONS -> COMPARISON .) ]

    LOGICAL_OPERATOR               shift and go to state 108

state 29

    (28) ROOT -> COMPARISONS .
    (75) FUNCTION_ARGUMENTS -> COMPARISONS .

  ! reduce/reduce conflict for $end resolved using rule 28 (ROOT -> COMPARISONS .)
    $end            reduce using rule 28 (ROOT -> COMPARISONS .)

  ! $end            [ reduce using rule 75 (FUNCTION_ARGUMENTS -> COMPARISONS .) ]


state 30

    (29) ROOT -> LOGICAL_OPERATOR .

    $end            reduce using rule 29 (ROOT -> LOGICAL_OPERATOR .)


state 31

    (30) ROOT -> SENTENCE .
    (120) SENTENCES -> SENTENCE .
    (121) SENTENCES -> SENTENCE . COMMA SENTENCES

  ! reduce/reduce conflict for $end resolved using rule 30 (ROOT -> SENTENCE .)
    $end            reduce using rule 30 (ROOT -> SENTENCE .)
    COMMA           shift and go to state 109

  ! $end            [ reduce using rule 120 (SENTENCES -> SENTENCE .) ]


state 32

    (31) ROOT -> SWITCH_BODY .

    $end            reduce using rule 31 (ROOT -> SWITCH_BODY .)


state 33

    (32) ROOT -> BUCLE .

    $end            reduce using rule 32 (ROOT -> BUCLE .)


state 34

    (33) ROOT -> ELSE_STRUCTURE .

    $end            reduce using rule 33 (ROOT -> ELSE_STRUCTURE .)


state 35

    (34) ROOT -> FUNCTION_ARGUMENTS .

    $end            reduce using rule 34 (ROOT -> FUNCTION_ARGUMENTS .)


state 36

    (37) DEFINE -> PP_DEFINE . VARIABLELEX VALUE
    (97) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 111

    VARIABLELEX                    shift and go to state 110

state 37

    (38) INCLUDE -> PP_INCLUDE . HEADER_LIB

    HEADER_LIB      shift and go to state 112


state 38

    (40) VALUE -> STRING .

    EQUAL_TO        reduce using rule 40 (VALUE -> STRING .)
    NOT_EQUAL       reduce using rule 40 (VALUE -> STRING .)
    GREATER_THAN    reduce using rule 40 (VALUE -> STRING .)
    LESS_THAN       reduce using rule 40 (VALUE -> STRING .)
    GREATER_EQUAL   reduce using rule 40 (VALUE -> STRING .)
    LESS_EQUAL      reduce using rule 40 (VALUE -> STRING .)
    $end            reduce using rule 40 (VALUE -> STRING .)
    AND             reduce using rule 40 (VALUE -> STRING .)
    OR              reduce using rule 40 (VALUE -> STRING .)
    NOT             reduce using rule 40 (VALUE -> STRING .)
    RPAREN          reduce using rule 40 (VALUE -> STRING .)


state 39

    (41) NUMBER -> INTEGER .
    (59) FOR_STRUCTURE -> INTEGER .

  ! reduce/reduce conflict for $end resolved using rule 41 (NUMBER -> INTEGER .)
    PLUS            reduce using rule 41 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 41 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 41 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 41 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 41 (NUMBER -> INTEGER .)
    $end            reduce using rule 41 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 41 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 41 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 41 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 41 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 41 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 41 (NUMBER -> INTEGER .)
    COMMA           reduce using rule 41 (NUMBER -> INTEGER .)
    VARNAME         reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    COMMENT         reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    IF              reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    INTEGER         reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    WHILE           reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    SWITCH          reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    INT             reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    SHORT           reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    LONG            reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    FLOAT           reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    DOUBLE          reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)

  ! $end            [ reduce using rule 59 (FOR_STRUCTURE -> INTEGER .) ]


state 40

    (42) NUMBER -> DECIMAL .

    PLUS            reduce using rule 42 (NUMBER -> DECIMAL .)
    MINUS           reduce using rule 42 (NUMBER -> DECIMAL .)
    TIMES           reduce using rule 42 (NUMBER -> DECIMAL .)
    MODULUS         reduce using rule 42 (NUMBER -> DECIMAL .)
    DIVIDE          reduce using rule 42 (NUMBER -> DECIMAL .)
    $end            reduce using rule 42 (NUMBER -> DECIMAL .)
    EQUAL_TO        reduce using rule 42 (NUMBER -> DECIMAL .)
    NOT_EQUAL       reduce using rule 42 (NUMBER -> DECIMAL .)
    GREATER_THAN    reduce using rule 42 (NUMBER -> DECIMAL .)
    LESS_THAN       reduce using rule 42 (NUMBER -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 42 (NUMBER -> DECIMAL .)
    LESS_EQUAL      reduce using rule 42 (NUMBER -> DECIMAL .)
    COMMA           reduce using rule 42 (NUMBER -> DECIMAL .)
    AND             reduce using rule 42 (NUMBER -> DECIMAL .)
    OR              reduce using rule 42 (NUMBER -> DECIMAL .)
    NOT             reduce using rule 42 (NUMBER -> DECIMAL .)
    RPAREN          reduce using rule 42 (NUMBER -> DECIMAL .)
    SEMICOLON       reduce using rule 42 (NUMBER -> DECIMAL .)


state 41

    (50) WHILE_STRUCTURE -> WHILE . LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LPAREN          shift and go to state 113


state 42

    (56) SWITCH_STRUCTURE -> SWITCH . LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LPAREN          shift and go to state 114


state 43

    (60) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LPAREN          shift and go to state 115


state 44

    (73) FUNCTION -> VARNAME . LPAREN FUNCTION_ARGUMENTS RPAREN
    (83) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (97) VARIABLELEX -> VARNAME .
    (119) SENTENCE -> VARNAME .
    (84) ASSIGNMENT_OPERATOR -> . EQUAL
    (85) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (86) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (87) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (88) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (89) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (90) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (91) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (92) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (93) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (94) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (95) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 97 (VARIABLELEX -> VARNAME .)
    LPAREN          shift and go to state 116
    INCREASE        reduce using rule 97 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 97 (VARIABLELEX -> VARNAME .)
    COMMA           reduce using rule 119 (SENTENCE -> VARNAME .)
    EQUAL           shift and go to state 50
    PLUS_EQUAL      shift and go to state 51
    MINUS_EQUAL     shift and go to state 52
    DIV_EQUAL       shift and go to state 53
    TIMES_EQUAL     shift and go to state 54
    MOD_EQUAL       shift and go to state 55
    AND_EQUAL       shift and go to state 56
    OR_EQUAL        shift and go to state 57
    XOR_EQUAL       shift and go to state 58
    COMPLEMENT_EQUAL shift and go to state 59
    SHIFTL_EQUAL    shift and go to state 60
    SHIFTR_EQUAL    shift and go to state 61

  ! $end            [ reduce using rule 119 (SENTENCE -> VARNAME .) ]

    ASSIGNMENT_OPERATOR            shift and go to state 117

state 45

    (76) INTEGER_TYPE -> INT .

    VARNAME         reduce using rule 76 (INTEGER_TYPE -> INT .)
    $end            reduce using rule 76 (INTEGER_TYPE -> INT .)


state 46

    (77) INTEGER_TYPE -> SHORT .

    VARNAME         reduce using rule 77 (INTEGER_TYPE -> SHORT .)
    $end            reduce using rule 77 (INTEGER_TYPE -> SHORT .)


state 47

    (78) INTEGER_TYPE -> LONG .

    VARNAME         reduce using rule 78 (INTEGER_TYPE -> LONG .)
    $end            reduce using rule 78 (INTEGER_TYPE -> LONG .)


state 48

    (79) DECIMAL_TYPE -> FLOAT .

    VARNAME         reduce using rule 79 (DECIMAL_TYPE -> FLOAT .)
    $end            reduce using rule 79 (DECIMAL_TYPE -> FLOAT .)


state 49

    (80) DECIMAL_TYPE -> DOUBLE .

    VARNAME         reduce using rule 80 (DECIMAL_TYPE -> DOUBLE .)
    $end            reduce using rule 80 (DECIMAL_TYPE -> DOUBLE .)


state 50

    (84) ASSIGNMENT_OPERATOR -> EQUAL .

    $end            reduce using rule 84 (ASSIGNMENT_OPERATOR -> EQUAL .)
    VARNAME         reduce using rule 84 (ASSIGNMENT_OPERATOR -> EQUAL .)
    INTEGER         reduce using rule 84 (ASSIGNMENT_OPERATOR -> EQUAL .)
    DECIMAL         reduce using rule 84 (ASSIGNMENT_OPERATOR -> EQUAL .)


state 51

    (85) ASSIGNMENT_OPERATOR -> PLUS_EQUAL .

    $end            reduce using rule 85 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    VARNAME         reduce using rule 85 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    INTEGER         reduce using rule 85 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    DECIMAL         reduce using rule 85 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)


state 52

    (86) ASSIGNMENT_OPERATOR -> MINUS_EQUAL .

    $end            reduce using rule 86 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    VARNAME         reduce using rule 86 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    INTEGER         reduce using rule 86 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    DECIMAL         reduce using rule 86 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)


state 53

    (87) ASSIGNMENT_OPERATOR -> DIV_EQUAL .

    $end            reduce using rule 87 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    VARNAME         reduce using rule 87 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    INTEGER         reduce using rule 87 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    DECIMAL         reduce using rule 87 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)


state 54

    (88) ASSIGNMENT_OPERATOR -> TIMES_EQUAL .

    $end            reduce using rule 88 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    VARNAME         reduce using rule 88 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    INTEGER         reduce using rule 88 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    DECIMAL         reduce using rule 88 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)


state 55

    (89) ASSIGNMENT_OPERATOR -> MOD_EQUAL .

    $end            reduce using rule 89 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    VARNAME         reduce using rule 89 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    INTEGER         reduce using rule 89 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    DECIMAL         reduce using rule 89 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)


state 56

    (90) ASSIGNMENT_OPERATOR -> AND_EQUAL .

    $end            reduce using rule 90 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    VARNAME         reduce using rule 90 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    INTEGER         reduce using rule 90 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    DECIMAL         reduce using rule 90 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)


state 57

    (91) ASSIGNMENT_OPERATOR -> OR_EQUAL .

    $end            reduce using rule 91 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    VARNAME         reduce using rule 91 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    INTEGER         reduce using rule 91 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    DECIMAL         reduce using rule 91 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)


state 58

    (92) ASSIGNMENT_OPERATOR -> XOR_EQUAL .

    $end            reduce using rule 92 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    VARNAME         reduce using rule 92 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    INTEGER         reduce using rule 92 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    DECIMAL         reduce using rule 92 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)


state 59

    (93) ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .

    $end            reduce using rule 93 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    VARNAME         reduce using rule 93 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    INTEGER         reduce using rule 93 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    DECIMAL         reduce using rule 93 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)


state 60

    (94) ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .

    $end            reduce using rule 94 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    VARNAME         reduce using rule 94 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    INTEGER         reduce using rule 94 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    DECIMAL         reduce using rule 94 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)


state 61

    (95) ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .

    $end            reduce using rule 95 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    VARNAME         reduce using rule 95 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    INTEGER         reduce using rule 95 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    DECIMAL         reduce using rule 95 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)


state 62

    (96) COMENTARIOLEX -> COMMENT .

    $end            reduce using rule 96 (COMENTARIOLEX -> COMMENT .)
    SEMICOLON       reduce using rule 96 (COMENTARIOLEX -> COMMENT .)


state 63

    (98) OPERATOR -> PLUS .

    $end            reduce using rule 98 (OPERATOR -> PLUS .)
    INTEGER         reduce using rule 98 (OPERATOR -> PLUS .)
    DECIMAL         reduce using rule 98 (OPERATOR -> PLUS .)


state 64

    (99) OPERATOR -> MINUS .

    $end            reduce using rule 99 (OPERATOR -> MINUS .)
    INTEGER         reduce using rule 99 (OPERATOR -> MINUS .)
    DECIMAL         reduce using rule 99 (OPERATOR -> MINUS .)


state 65

    (100) OPERATOR -> TIMES .

    $end            reduce using rule 100 (OPERATOR -> TIMES .)
    INTEGER         reduce using rule 100 (OPERATOR -> TIMES .)
    DECIMAL         reduce using rule 100 (OPERATOR -> TIMES .)


state 66

    (101) OPERATOR -> MODULUS .

    $end            reduce using rule 101 (OPERATOR -> MODULUS .)
    INTEGER         reduce using rule 101 (OPERATOR -> MODULUS .)
    DECIMAL         reduce using rule 101 (OPERATOR -> MODULUS .)


state 67

    (102) OPERATOR -> DIVIDE .

    $end            reduce using rule 102 (OPERATOR -> DIVIDE .)
    INTEGER         reduce using rule 102 (OPERATOR -> DIVIDE .)
    DECIMAL         reduce using rule 102 (OPERATOR -> DIVIDE .)


state 68

    (106) COMPARISON_OPERATOR -> EQUAL_TO .

    $end            reduce using rule 106 (COMPARISON_OPERATOR -> EQUAL_TO .)
    STRING          reduce using rule 106 (COMPARISON_OPERATOR -> EQUAL_TO .)
    INTEGER         reduce using rule 106 (COMPARISON_OPERATOR -> EQUAL_TO .)
    DECIMAL         reduce using rule 106 (COMPARISON_OPERATOR -> EQUAL_TO .)


state 69

    (107) COMPARISON_OPERATOR -> NOT_EQUAL .

    $end            reduce using rule 107 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    STRING          reduce using rule 107 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    INTEGER         reduce using rule 107 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    DECIMAL         reduce using rule 107 (COMPARISON_OPERATOR -> NOT_EQUAL .)


state 70

    (108) COMPARISON_OPERATOR -> GREATER_THAN .

    $end            reduce using rule 108 (COMPARISON_OPERATOR -> GREATER_THAN .)
    STRING          reduce using rule 108 (COMPARISON_OPERATOR -> GREATER_THAN .)
    INTEGER         reduce using rule 108 (COMPARISON_OPERATOR -> GREATER_THAN .)
    DECIMAL         reduce using rule 108 (COMPARISON_OPERATOR -> GREATER_THAN .)


state 71

    (109) COMPARISON_OPERATOR -> LESS_THAN .

    $end            reduce using rule 109 (COMPARISON_OPERATOR -> LESS_THAN .)
    STRING          reduce using rule 109 (COMPARISON_OPERATOR -> LESS_THAN .)
    INTEGER         reduce using rule 109 (COMPARISON_OPERATOR -> LESS_THAN .)
    DECIMAL         reduce using rule 109 (COMPARISON_OPERATOR -> LESS_THAN .)


state 72

    (110) COMPARISON_OPERATOR -> GREATER_EQUAL .

    $end            reduce using rule 110 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    STRING          reduce using rule 110 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    INTEGER         reduce using rule 110 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    DECIMAL         reduce using rule 110 (COMPARISON_OPERATOR -> GREATER_EQUAL .)


state 73

    (111) COMPARISON_OPERATOR -> LESS_EQUAL .

    $end            reduce using rule 111 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    STRING          reduce using rule 111 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    INTEGER         reduce using rule 111 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    DECIMAL         reduce using rule 111 (COMPARISON_OPERATOR -> LESS_EQUAL .)


state 74

    (115) LOGICAL_OPERATOR -> AND .

    $end            reduce using rule 115 (LOGICAL_OPERATOR -> AND .)
    STRING          reduce using rule 115 (LOGICAL_OPERATOR -> AND .)
    INTEGER         reduce using rule 115 (LOGICAL_OPERATOR -> AND .)
    DECIMAL         reduce using rule 115 (LOGICAL_OPERATOR -> AND .)


state 75

    (116) LOGICAL_OPERATOR -> OR .

    $end            reduce using rule 116 (LOGICAL_OPERATOR -> OR .)
    STRING          reduce using rule 116 (LOGICAL_OPERATOR -> OR .)
    INTEGER         reduce using rule 116 (LOGICAL_OPERATOR -> OR .)
    DECIMAL         reduce using rule 116 (LOGICAL_OPERATOR -> OR .)


state 76

    (117) LOGICAL_OPERATOR -> NOT .

    $end            reduce using rule 117 (LOGICAL_OPERATOR -> NOT .)
    STRING          reduce using rule 117 (LOGICAL_OPERATOR -> NOT .)
    INTEGER         reduce using rule 117 (LOGICAL_OPERATOR -> NOT .)
    DECIMAL         reduce using rule 117 (LOGICAL_OPERATOR -> NOT .)


state 77

    (53) SWITCH_BODY -> SWITCH_CASE .
    (55) SWITCH_BODY -> SWITCH_CASE . SWITCH_BODY
    (53) SWITCH_BODY -> . SWITCH_CASE
    (54) SWITCH_BODY -> . SWITCH_DEFAULT
    (55) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (51) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (52) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    $end            reduce using rule 53 (SWITCH_BODY -> SWITCH_CASE .)
    RCURL_BRACE     reduce using rule 53 (SWITCH_BODY -> SWITCH_CASE .)
    CASE            shift and go to state 82
    DEFAULT         shift and go to state 83

    SWITCH_CASE                    shift and go to state 77
    SWITCH_BODY                    shift and go to state 118
    SWITCH_DEFAULT                 shift and go to state 78

state 78

    (54) SWITCH_BODY -> SWITCH_DEFAULT .

    $end            reduce using rule 54 (SWITCH_BODY -> SWITCH_DEFAULT .)
    RCURL_BRACE     reduce using rule 54 (SWITCH_BODY -> SWITCH_DEFAULT .)


state 79

    (58) BUCLE -> DECREASE . VARIABLELEX
    (97) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 111

    VARIABLELEX                    shift and go to state 119

state 80

    (62) ELSE_STRUCTURE -> ELSE . LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (63) ELSE_STRUCTURE -> ELSE . IF_STRUCTURE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LCURL_BRACE     shift and go to state 120
    IF              shift and go to state 43

    IF_STRUCTURE                   shift and go to state 121

state 81

    (74) FUNCTION_ARGUMENTS -> SENTENCES .

    $end            reduce using rule 74 (FUNCTION_ARGUMENTS -> SENTENCES .)
    RPAREN          reduce using rule 74 (FUNCTION_ARGUMENTS -> SENTENCES .)


state 82

    (51) SWITCH_CASE -> CASE . INTEGER COLON EXPRESSIONS BREAK SEMICOLON

    INTEGER         shift and go to state 122


state 83

    (52) SWITCH_DEFAULT -> DEFAULT . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 123


state 84

    (112) COMPARISON -> VALUE COMPARISON_OPERATOR . VALUE
    (39) VALUE -> . NUMBER
    (40) VALUE -> . STRING
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    STRING          shift and go to state 38
    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    VALUE                          shift and go to state 124
    NUMBER                         shift and go to state 125

state 85

    (103) OPERATION -> NUMBER OPERATOR . NUMBER
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    NUMBER                         shift and go to state 127

state 86

    (69) EXPRESSION -> CODE SEMICOLON .

    VARNAME         reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    COMMENT         reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    IF              reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    INTEGER         reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    WHILE           reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    SWITCH          reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    INT             reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    SHORT           reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    LONG            reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    FLOAT           reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    DOUBLE          reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    $end            reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    RCURL_BRACE     reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    BREAK           reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)
    CONTINUE        reduce using rule 69 (EXPRESSION -> CODE SEMICOLON .)


state 87

    (71) EXPRESSIONS -> EXPRESSION .
    (72) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (71) EXPRESSIONS -> . EXPRESSION
    (72) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (69) EXPRESSION -> . CODE SEMICOLON
    (70) EXPRESSION -> . CONTROL_STRUCTURES
    (64) CODE -> . FUNCTION
    (65) CODE -> . INTEGER_DECLARATION
    (66) CODE -> . DECIMAL_DECLARATION
    (67) CODE -> . ASSIGNMENT_DECLARATION
    (68) CODE -> . COMENTARIOLEX
    (43) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (44) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (45) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (46) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (73) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (81) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (82) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (83) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (96) COMENTARIOLEX -> . COMMENT
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (59) FOR_STRUCTURE -> . INTEGER
    (50) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (56) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (76) INTEGER_TYPE -> . INT
    (77) INTEGER_TYPE -> . SHORT
    (78) INTEGER_TYPE -> . LONG
    (79) DECIMAL_TYPE -> . FLOAT
    (80) DECIMAL_TYPE -> . DOUBLE

    $end            reduce using rule 71 (EXPRESSIONS -> EXPRESSION .)
    RCURL_BRACE     reduce using rule 71 (EXPRESSIONS -> EXPRESSION .)
    BREAK           reduce using rule 71 (EXPRESSIONS -> EXPRESSION .)
    CONTINUE        reduce using rule 71 (EXPRESSIONS -> EXPRESSION .)
    VARNAME         shift and go to state 100
    COMMENT         shift and go to state 62
    IF              shift and go to state 43
    INTEGER         shift and go to state 102
    WHILE           shift and go to state 41
    SWITCH          shift and go to state 42
    INT             shift and go to state 45
    SHORT           shift and go to state 46
    LONG            shift and go to state 47
    FLOAT           shift and go to state 48
    DOUBLE          shift and go to state 49

    EXPRESSION                     shift and go to state 87
    EXPRESSIONS                    shift and go to state 88
    CODE                           shift and go to state 89
    CONTROL_STRUCTURES             shift and go to state 90
    FUNCTION                       shift and go to state 91
    INTEGER_DECLARATION            shift and go to state 92
    DECIMAL_DECLARATION            shift and go to state 93
    ASSIGNMENT_DECLARATION         shift and go to state 94
    COMENTARIOLEX                  shift and go to state 95
    IF_STRUCTURE                   shift and go to state 96
    FOR_STRUCTURE                  shift and go to state 97
    WHILE_STRUCTURE                shift and go to state 98
    SWITCH_STRUCTURE               shift and go to state 99
    INTEGER_TYPE                   shift and go to state 101
    DECIMAL_TYPE                   shift and go to state 103

state 88

    (72) EXPRESSIONS -> EXPRESSION EXPRESSIONS .

    $end            reduce using rule 72 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    RCURL_BRACE     reduce using rule 72 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    BREAK           reduce using rule 72 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    CONTINUE        reduce using rule 72 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)


state 89

    (69) EXPRESSION -> CODE . SEMICOLON

    SEMICOLON       shift and go to state 86


state 90

    (70) EXPRESSION -> CONTROL_STRUCTURES .

    VARNAME         reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    INTEGER         reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    $end            reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    RCURL_BRACE     reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    BREAK           reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)
    CONTINUE        reduce using rule 70 (EXPRESSION -> CONTROL_STRUCTURES .)


state 91

    (64) CODE -> FUNCTION .

    SEMICOLON       reduce using rule 64 (CODE -> FUNCTION .)


state 92

    (65) CODE -> INTEGER_DECLARATION .

    SEMICOLON       reduce using rule 65 (CODE -> INTEGER_DECLARATION .)


state 93

    (66) CODE -> DECIMAL_DECLARATION .

    SEMICOLON       reduce using rule 66 (CODE -> DECIMAL_DECLARATION .)


state 94

    (67) CODE -> ASSIGNMENT_DECLARATION .

    SEMICOLON       reduce using rule 67 (CODE -> ASSIGNMENT_DECLARATION .)


state 95

    (68) CODE -> COMENTARIOLEX .

    SEMICOLON       reduce using rule 68 (CODE -> COMENTARIOLEX .)


state 96

    (43) CONTROL_STRUCTURES -> IF_STRUCTURE .

    VARNAME         reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INTEGER         reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    $end            reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    RCURL_BRACE     reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    BREAK           reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    CONTINUE        reduce using rule 43 (CONTROL_STRUCTURES -> IF_STRUCTURE .)


state 97

    (44) CONTROL_STRUCTURES -> FOR_STRUCTURE .

    VARNAME         reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INTEGER         reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    $end            reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    RCURL_BRACE     reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    BREAK           reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    CONTINUE        reduce using rule 44 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)


state 98

    (45) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

    VARNAME         reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INTEGER         reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    $end            reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    RCURL_BRACE     reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    BREAK           reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    CONTINUE        reduce using rule 45 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)


state 99

    (46) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

    VARNAME         reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INTEGER         reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    $end            reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    RCURL_BRACE     reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    BREAK           reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    CONTINUE        reduce using rule 46 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)


state 100

    (73) FUNCTION -> VARNAME . LPAREN FUNCTION_ARGUMENTS RPAREN
    (83) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (84) ASSIGNMENT_OPERATOR -> . EQUAL
    (85) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (86) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (87) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (88) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (89) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (90) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (91) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (92) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (93) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (94) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (95) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

    LPAREN          shift and go to state 116
    EQUAL           shift and go to state 50
    PLUS_EQUAL      shift and go to state 51
    MINUS_EQUAL     shift and go to state 52
    DIV_EQUAL       shift and go to state 53
    TIMES_EQUAL     shift and go to state 54
    MOD_EQUAL       shift and go to state 55
    AND_EQUAL       shift and go to state 56
    OR_EQUAL        shift and go to state 57
    XOR_EQUAL       shift and go to state 58
    COMPLEMENT_EQUAL shift and go to state 59
    SHIFTL_EQUAL    shift and go to state 60
    SHIFTR_EQUAL    shift and go to state 61

    ASSIGNMENT_OPERATOR            shift and go to state 117

state 101

    (81) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    VARNAME         shift and go to state 104


state 102

    (59) FOR_STRUCTURE -> INTEGER .

    VARNAME         reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    COMMENT         reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    IF              reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    INTEGER         reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    WHILE           reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    SWITCH          reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    INT             reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    SHORT           reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    LONG            reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    FLOAT           reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    DOUBLE          reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    $end            reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    RCURL_BRACE     reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    BREAK           reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)
    CONTINUE        reduce using rule 59 (FOR_STRUCTURE -> INTEGER .)


state 103

    (82) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    VARNAME         shift and go to state 105


state 104

    (81) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME . EQUAL INTEGER

    EQUAL           shift and go to state 128


state 105

    (82) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME . EQUAL DECIMAL

    EQUAL           shift and go to state 129


state 106

    (57) BUCLE -> VARIABLELEX INCREASE .

    $end            reduce using rule 57 (BUCLE -> VARIABLELEX INCREASE .)


state 107

    (105) OPERATIONS -> OPERATION OPERATOR . OPERATIONS
    (104) OPERATIONS -> . OPERATION
    (105) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (103) OPERATION -> . NUMBER OPERATOR NUMBER
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    OPERATION                      shift and go to state 130
    OPERATIONS                     shift and go to state 131
    NUMBER                         shift and go to state 132

state 108

    (114) COMPARISONS -> COMPARISON LOGICAL_OPERATOR . COMPARISONS
    (113) COMPARISONS -> . COMPARISON
    (114) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (112) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (39) VALUE -> . NUMBER
    (40) VALUE -> . STRING
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    STRING          shift and go to state 38
    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    COMPARISON                     shift and go to state 133
    COMPARISONS                    shift and go to state 134
    VALUE                          shift and go to state 135
    NUMBER                         shift and go to state 125

state 109

    (121) SENTENCES -> SENTENCE COMMA . SENTENCES
    (120) SENTENCES -> . SENTENCE
    (121) SENTENCES -> . SENTENCE COMMA SENTENCES
    (118) SENTENCE -> . NUMBER
    (119) SENTENCE -> . VARNAME
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 139
    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    SENTENCE                       shift and go to state 136
    SENTENCES                      shift and go to state 137
    NUMBER                         shift and go to state 138

state 110

    (37) DEFINE -> PP_DEFINE VARIABLELEX . VALUE
    (39) VALUE -> . NUMBER
    (40) VALUE -> . STRING
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    STRING          shift and go to state 38
    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    VALUE                          shift and go to state 140
    NUMBER                         shift and go to state 125

state 111

    (97) VARIABLELEX -> VARNAME .

    STRING          reduce using rule 97 (VARIABLELEX -> VARNAME .)
    INTEGER         reduce using rule 97 (VARIABLELEX -> VARNAME .)
    DECIMAL         reduce using rule 97 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 97 (VARIABLELEX -> VARNAME .)


state 112

    (38) INCLUDE -> PP_INCLUDE HEADER_LIB .

    $end            reduce using rule 38 (INCLUDE -> PP_INCLUDE HEADER_LIB .)


state 113

    (50) WHILE_STRUCTURE -> WHILE LPAREN . COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (113) COMPARISONS -> . COMPARISON
    (114) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (112) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (39) VALUE -> . NUMBER
    (40) VALUE -> . STRING
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    STRING          shift and go to state 38
    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    COMPARISONS                    shift and go to state 141
    COMPARISON                     shift and go to state 133
    VALUE                          shift and go to state 135
    NUMBER                         shift and go to state 125

state 114

    (56) SWITCH_STRUCTURE -> SWITCH LPAREN . COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (113) COMPARISONS -> . COMPARISON
    (114) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (112) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (39) VALUE -> . NUMBER
    (40) VALUE -> . STRING
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    STRING          shift and go to state 38
    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    COMPARISONS                    shift and go to state 142
    COMPARISON                     shift and go to state 133
    VALUE                          shift and go to state 135
    NUMBER                         shift and go to state 125

state 115

    (60) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (113) COMPARISONS -> . COMPARISON
    (114) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (112) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (39) VALUE -> . NUMBER
    (40) VALUE -> . STRING
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    STRING          shift and go to state 38
    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    COMPARISONS                    shift and go to state 143
    COMPARISON                     shift and go to state 133
    VALUE                          shift and go to state 135
    NUMBER                         shift and go to state 125

state 116

    (73) FUNCTION -> VARNAME LPAREN . FUNCTION_ARGUMENTS RPAREN
    (74) FUNCTION_ARGUMENTS -> . SENTENCES
    (75) FUNCTION_ARGUMENTS -> . COMPARISONS
    (120) SENTENCES -> . SENTENCE
    (121) SENTENCES -> . SENTENCE COMMA SENTENCES
    (113) COMPARISONS -> . COMPARISON
    (114) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (118) SENTENCE -> . NUMBER
    (119) SENTENCE -> . VARNAME
    (112) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL
    (39) VALUE -> . NUMBER
    (40) VALUE -> . STRING

    VARNAME         shift and go to state 139
    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40
    STRING          shift and go to state 38

    FUNCTION_ARGUMENTS             shift and go to state 144
    SENTENCES                      shift and go to state 81
    COMPARISONS                    shift and go to state 145
    SENTENCE                       shift and go to state 136
    COMPARISON                     shift and go to state 133
    NUMBER                         shift and go to state 146
    VALUE                          shift and go to state 135

state 117

    (83) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR . SENTENCE
    (118) SENTENCE -> . NUMBER
    (119) SENTENCE -> . VARNAME
    (41) NUMBER -> . INTEGER
    (42) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 139
    INTEGER         shift and go to state 126
    DECIMAL         shift and go to state 40

    SENTENCE                       shift and go to state 147
    NUMBER                         shift and go to state 138

state 118

    (55) SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .

    $end            reduce using rule 55 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)
    RCURL_BRACE     reduce using rule 55 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)


state 119

    (58) BUCLE -> DECREASE VARIABLELEX .

    $end            reduce using rule 58 (BUCLE -> DECREASE VARIABLELEX .)


state 120

    (62) ELSE_STRUCTURE -> ELSE LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (71) EXPRESSIONS -> . EXPRESSION
    (72) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (69) EXPRESSION -> . CODE SEMICOLON
    (70) EXPRESSION -> . CONTROL_STRUCTURES
    (64) CODE -> . FUNCTION
    (65) CODE -> . INTEGER_DECLARATION
    (66) CODE -> . DECIMAL_DECLARATION
    (67) CODE -> . ASSIGNMENT_DECLARATION
    (68) CODE -> . COMENTARIOLEX
    (43) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (44) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (45) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (46) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (73) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (81) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (82) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (83) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (96) COMENTARIOLEX -> . COMMENT
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (59) FOR_STRUCTURE -> . INTEGER
    (50) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (56) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (76) INTEGER_TYPE -> . INT
    (77) INTEGER_TYPE -> . SHORT
    (78) INTEGER_TYPE -> . LONG
    (79) DECIMAL_TYPE -> . FLOAT
    (80) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 100
    COMMENT         shift and go to state 62
    IF              shift and go to state 43
    INTEGER         shift and go to state 102
    WHILE           shift and go to state 41
    SWITCH          shift and go to state 42
    INT             shift and go to state 45
    SHORT           shift and go to state 46
    LONG            shift and go to state 47
    FLOAT           shift and go to state 48
    DOUBLE          shift and go to state 49

    EXPRESSIONS                    shift and go to state 148
    EXPRESSION                     shift and go to state 87
    CODE                           shift and go to state 89
    CONTROL_STRUCTURES             shift and go to state 90
    FUNCTION                       shift and go to state 91
    INTEGER_DECLARATION            shift and go to state 92
    DECIMAL_DECLARATION            shift and go to state 93
    ASSIGNMENT_DECLARATION         shift and go to state 94
    COMENTARIOLEX                  shift and go to state 95
    IF_STRUCTURE                   shift and go to state 96
    FOR_STRUCTURE                  shift and go to state 97
    WHILE_STRUCTURE                shift and go to state 98
    SWITCH_STRUCTURE               shift and go to state 99
    INTEGER_TYPE                   shift and go to state 101
    DECIMAL_TYPE                   shift and go to state 103

state 121

    (63) ELSE_STRUCTURE -> ELSE IF_STRUCTURE .

    $end            reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    VARNAME         reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    COMMENT         reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    IF              reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    INTEGER         reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    WHILE           reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    SWITCH          reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    INT             reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    SHORT           reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    LONG            reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    FLOAT           reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    DOUBLE          reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    RCURL_BRACE     reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    BREAK           reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    CONTINUE        reduce using rule 63 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)


state 122

    (51) SWITCH_CASE -> CASE INTEGER . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 149


state 123

    (52) SWITCH_DEFAULT -> DEFAULT COLON . EXPRESSIONS BREAK SEMICOLON
    (71) EXPRESSIONS -> . EXPRESSION
    (72) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (69) EXPRESSION -> . CODE SEMICOLON
    (70) EXPRESSION -> . CONTROL_STRUCTURES
    (64) CODE -> . FUNCTION
    (65) CODE -> . INTEGER_DECLARATION
    (66) CODE -> . DECIMAL_DECLARATION
    (67) CODE -> . ASSIGNMENT_DECLARATION
    (68) CODE -> . COMENTARIOLEX
    (43) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (44) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (45) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (46) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (73) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (81) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (82) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (83) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (96) COMENTARIOLEX -> . COMMENT
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (59) FOR_STRUCTURE -> . INTEGER
    (50) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (56) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (76) INTEGER_TYPE -> . INT
    (77) INTEGER_TYPE -> . SHORT
    (78) INTEGER_TYPE -> . LONG
    (79) DECIMAL_TYPE -> . FLOAT
    (80) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 100
    COMMENT         shift and go to state 62
    IF              shift and go to state 43
    INTEGER         shift and go to state 102
    WHILE           shift and go to state 41
    SWITCH          shift and go to state 42
    INT             shift and go to state 45
    SHORT           shift and go to state 46
    LONG            shift and go to state 47
    FLOAT           shift and go to state 48
    DOUBLE          shift and go to state 49

    EXPRESSIONS                    shift and go to state 150
    EXPRESSION                     shift and go to state 87
    CODE                           shift and go to state 89
    CONTROL_STRUCTURES             shift and go to state 90
    FUNCTION                       shift and go to state 91
    INTEGER_DECLARATION            shift and go to state 92
    DECIMAL_DECLARATION            shift and go to state 93
    ASSIGNMENT_DECLARATION         shift and go to state 94
    COMENTARIOLEX                  shift and go to state 95
    IF_STRUCTURE                   shift and go to state 96
    FOR_STRUCTURE                  shift and go to state 97
    WHILE_STRUCTURE                shift and go to state 98
    SWITCH_STRUCTURE               shift and go to state 99
    INTEGER_TYPE                   shift and go to state 101
    DECIMAL_TYPE                   shift and go to state 103

state 124

    (112) COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .

    AND             reduce using rule 112 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    OR              reduce using rule 112 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    NOT             reduce using rule 112 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    $end            reduce using rule 112 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    RPAREN          reduce using rule 112 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)


state 125

    (39) VALUE -> NUMBER .

    AND             reduce using rule 39 (VALUE -> NUMBER .)
    OR              reduce using rule 39 (VALUE -> NUMBER .)
    NOT             reduce using rule 39 (VALUE -> NUMBER .)
    $end            reduce using rule 39 (VALUE -> NUMBER .)
    RPAREN          reduce using rule 39 (VALUE -> NUMBER .)
    EQUAL_TO        reduce using rule 39 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 39 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 39 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 39 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 39 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 39 (VALUE -> NUMBER .)


state 126

    (41) NUMBER -> INTEGER .

    AND             reduce using rule 41 (NUMBER -> INTEGER .)
    OR              reduce using rule 41 (NUMBER -> INTEGER .)
    NOT             reduce using rule 41 (NUMBER -> INTEGER .)
    $end            reduce using rule 41 (NUMBER -> INTEGER .)
    RPAREN          reduce using rule 41 (NUMBER -> INTEGER .)
    PLUS            reduce using rule 41 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 41 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 41 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 41 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 41 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 41 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 41 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 41 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 41 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 41 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 41 (NUMBER -> INTEGER .)
    COMMA           reduce using rule 41 (NUMBER -> INTEGER .)
    SEMICOLON       reduce using rule 41 (NUMBER -> INTEGER .)


state 127

    (103) OPERATION -> NUMBER OPERATOR NUMBER .

    PLUS            reduce using rule 103 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MINUS           reduce using rule 103 (OPERATION -> NUMBER OPERATOR NUMBER .)
    TIMES           reduce using rule 103 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MODULUS         reduce using rule 103 (OPERATION -> NUMBER OPERATOR NUMBER .)
    DIVIDE          reduce using rule 103 (OPERATION -> NUMBER OPERATOR NUMBER .)
    $end            reduce using rule 103 (OPERATION -> NUMBER OPERATOR NUMBER .)


state 128

    (81) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL . INTEGER

    INTEGER         shift and go to state 151


state 129

    (82) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL . DECIMAL

    DECIMAL         shift and go to state 152


state 130

    (104) OPERATIONS -> OPERATION .
    (105) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (98) OPERATOR -> . PLUS
    (99) OPERATOR -> . MINUS
    (100) OPERATOR -> . TIMES
    (101) OPERATOR -> . MODULUS
    (102) OPERATOR -> . DIVIDE

    $end            reduce using rule 104 (OPERATIONS -> OPERATION .)
    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    MODULUS         shift and go to state 66
    DIVIDE          shift and go to state 67

    OPERATOR                       shift and go to state 107

state 131

    (105) OPERATIONS -> OPERATION OPERATOR OPERATIONS .

    $end            reduce using rule 105 (OPERATIONS -> OPERATION OPERATOR OPERATIONS .)


state 132

    (103) OPERATION -> NUMBER . OPERATOR NUMBER
    (98) OPERATOR -> . PLUS
    (99) OPERATOR -> . MINUS
    (100) OPERATOR -> . TIMES
    (101) OPERATOR -> . MODULUS
    (102) OPERATOR -> . DIVIDE

    PLUS            shift and go to state 63
    MINUS           shift and go to state 64
    TIMES           shift and go to state 65
    MODULUS         shift and go to state 66
    DIVIDE          shift and go to state 67

    OPERATOR                       shift and go to state 85

state 133

    (113) COMPARISONS -> COMPARISON .
    (114) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (115) LOGICAL_OPERATOR -> . AND
    (116) LOGICAL_OPERATOR -> . OR
    (117) LOGICAL_OPERATOR -> . NOT

    $end            reduce using rule 113 (COMPARISONS -> COMPARISON .)
    RPAREN          reduce using rule 113 (COMPARISONS -> COMPARISON .)
    AND             shift and go to state 74
    OR              shift and go to state 75
    NOT             shift and go to state 76

    LOGICAL_OPERATOR               shift and go to state 108

state 134

    (114) COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .

    $end            reduce using rule 114 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)
    RPAREN          reduce using rule 114 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)


state 135

    (112) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (106) COMPARISON_OPERATOR -> . EQUAL_TO
    (107) COMPARISON_OPERATOR -> . NOT_EQUAL
    (108) COMPARISON_OPERATOR -> . GREATER_THAN
    (109) COMPARISON_OPERATOR -> . LESS_THAN
    (110) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (111) COMPARISON_OPERATOR -> . LESS_EQUAL

    EQUAL_TO        shift and go to state 68
    NOT_EQUAL       shift and go to state 69
    GREATER_THAN    shift and go to state 70
    LESS_THAN       shift and go to state 71
    GREATER_EQUAL   shift and go to state 72
    LESS_EQUAL      shift and go to state 73

    COMPARISON_OPERATOR            shift and go to state 84

state 136

    (120) SENTENCES -> SENTENCE .
    (121) SENTENCES -> SENTENCE . COMMA SENTENCES

    $end            reduce using rule 120 (SENTENCES -> SENTENCE .)
    RPAREN          reduce using rule 120 (SENTENCES -> SENTENCE .)
    COMMA           shift and go to state 109


state 137

    (121) SENTENCES -> SENTENCE COMMA SENTENCES .

    $end            reduce using rule 121 (SENTENCES -> SENTENCE COMMA SENTENCES .)
    RPAREN          reduce using rule 121 (SENTENCES -> SENTENCE COMMA SENTENCES .)


state 138

    (118) SENTENCE -> NUMBER .

    COMMA           reduce using rule 118 (SENTENCE -> NUMBER .)
    $end            reduce using rule 118 (SENTENCE -> NUMBER .)
    RPAREN          reduce using rule 118 (SENTENCE -> NUMBER .)
    SEMICOLON       reduce using rule 118 (SENTENCE -> NUMBER .)


state 139

    (119) SENTENCE -> VARNAME .

    COMMA           reduce using rule 119 (SENTENCE -> VARNAME .)
    $end            reduce using rule 119 (SENTENCE -> VARNAME .)
    RPAREN          reduce using rule 119 (SENTENCE -> VARNAME .)
    SEMICOLON       reduce using rule 119 (SENTENCE -> VARNAME .)


state 140

    (37) DEFINE -> PP_DEFINE VARIABLELEX VALUE .

    $end            reduce using rule 37 (DEFINE -> PP_DEFINE VARIABLELEX VALUE .)


state 141

    (50) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS . RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    RPAREN          shift and go to state 153


state 142

    (56) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS . RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    RPAREN          shift and go to state 154


state 143

    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    RPAREN          shift and go to state 155


state 144

    (73) FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS . RPAREN

    RPAREN          shift and go to state 156


state 145

    (75) FUNCTION_ARGUMENTS -> COMPARISONS .

    RPAREN          reduce using rule 75 (FUNCTION_ARGUMENTS -> COMPARISONS .)


state 146

    (118) SENTENCE -> NUMBER .
    (39) VALUE -> NUMBER .

    COMMA           reduce using rule 118 (SENTENCE -> NUMBER .)
    RPAREN          reduce using rule 118 (SENTENCE -> NUMBER .)
    EQUAL_TO        reduce using rule 39 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 39 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 39 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 39 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 39 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 39 (VALUE -> NUMBER .)


state 147

    (83) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .

    $end            reduce using rule 83 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)
    SEMICOLON       reduce using rule 83 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)


state 148

    (62) ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS . RCURL_BRACE

    RCURL_BRACE     shift and go to state 157


state 149

    (51) SWITCH_CASE -> CASE INTEGER COLON . EXPRESSIONS BREAK SEMICOLON
    (71) EXPRESSIONS -> . EXPRESSION
    (72) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (69) EXPRESSION -> . CODE SEMICOLON
    (70) EXPRESSION -> . CONTROL_STRUCTURES
    (64) CODE -> . FUNCTION
    (65) CODE -> . INTEGER_DECLARATION
    (66) CODE -> . DECIMAL_DECLARATION
    (67) CODE -> . ASSIGNMENT_DECLARATION
    (68) CODE -> . COMENTARIOLEX
    (43) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (44) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (45) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (46) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (73) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (81) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (82) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (83) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (96) COMENTARIOLEX -> . COMMENT
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (59) FOR_STRUCTURE -> . INTEGER
    (50) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (56) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (76) INTEGER_TYPE -> . INT
    (77) INTEGER_TYPE -> . SHORT
    (78) INTEGER_TYPE -> . LONG
    (79) DECIMAL_TYPE -> . FLOAT
    (80) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 100
    COMMENT         shift and go to state 62
    IF              shift and go to state 43
    INTEGER         shift and go to state 102
    WHILE           shift and go to state 41
    SWITCH          shift and go to state 42
    INT             shift and go to state 45
    SHORT           shift and go to state 46
    LONG            shift and go to state 47
    FLOAT           shift and go to state 48
    DOUBLE          shift and go to state 49

    EXPRESSIONS                    shift and go to state 158
    EXPRESSION                     shift and go to state 87
    CODE                           shift and go to state 89
    CONTROL_STRUCTURES             shift and go to state 90
    FUNCTION                       shift and go to state 91
    INTEGER_DECLARATION            shift and go to state 92
    DECIMAL_DECLARATION            shift and go to state 93
    ASSIGNMENT_DECLARATION         shift and go to state 94
    COMENTARIOLEX                  shift and go to state 95
    IF_STRUCTURE                   shift and go to state 96
    FOR_STRUCTURE                  shift and go to state 97
    WHILE_STRUCTURE                shift and go to state 98
    SWITCH_STRUCTURE               shift and go to state 99
    INTEGER_TYPE                   shift and go to state 101
    DECIMAL_TYPE                   shift and go to state 103

state 150

    (52) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 159


state 151

    (81) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .

    $end            reduce using rule 81 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)
    SEMICOLON       reduce using rule 81 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)


state 152

    (82) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .

    $end            reduce using rule 82 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)
    SEMICOLON       reduce using rule 82 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)


state 153

    (50) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN . LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LCURL_BRACE     shift and go to state 160


state 154

    (56) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN . LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LCURL_BRACE     shift and go to state 161


state 155

    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LCURL_BRACE     shift and go to state 162


state 156

    (73) FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN .

    $end            reduce using rule 73 (FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN .)
    SEMICOLON       reduce using rule 73 (FUNCTION -> VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN .)


state 157

    (62) ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .

    $end            reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    VARNAME         reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    COMMENT         reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    IF              reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INTEGER         reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    WHILE           reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SWITCH          reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INT             reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SHORT           reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    LONG            reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FLOAT           reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    DOUBLE          reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    BREAK           reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    CONTINUE        reduce using rule 62 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)


state 158

    (51) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 163


state 159

    (52) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 164


state 160

    (50) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE . BODY_STRUCTURE RCURL_BRACE
    (47) BODY_STRUCTURE -> . EXPRESSIONS
    (48) BODY_STRUCTURE -> . EXPRESSIONS BREAK SEMICOLON
    (49) BODY_STRUCTURE -> . EXPRESSIONS CONTINUE SEMICOLON
    (71) EXPRESSIONS -> . EXPRESSION
    (72) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (69) EXPRESSION -> . CODE SEMICOLON
    (70) EXPRESSION -> . CONTROL_STRUCTURES
    (64) CODE -> . FUNCTION
    (65) CODE -> . INTEGER_DECLARATION
    (66) CODE -> . DECIMAL_DECLARATION
    (67) CODE -> . ASSIGNMENT_DECLARATION
    (68) CODE -> . COMENTARIOLEX
    (43) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (44) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (45) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (46) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (73) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (81) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (82) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (83) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (96) COMENTARIOLEX -> . COMMENT
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (59) FOR_STRUCTURE -> . INTEGER
    (50) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (56) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (76) INTEGER_TYPE -> . INT
    (77) INTEGER_TYPE -> . SHORT
    (78) INTEGER_TYPE -> . LONG
    (79) DECIMAL_TYPE -> . FLOAT
    (80) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 100
    COMMENT         shift and go to state 62
    IF              shift and go to state 43
    INTEGER         shift and go to state 102
    WHILE           shift and go to state 41
    SWITCH          shift and go to state 42
    INT             shift and go to state 45
    SHORT           shift and go to state 46
    LONG            shift and go to state 47
    FLOAT           shift and go to state 48
    DOUBLE          shift and go to state 49

    BODY_STRUCTURE                 shift and go to state 165
    EXPRESSIONS                    shift and go to state 166
    EXPRESSION                     shift and go to state 87
    CODE                           shift and go to state 89
    CONTROL_STRUCTURES             shift and go to state 90
    FUNCTION                       shift and go to state 91
    INTEGER_DECLARATION            shift and go to state 92
    DECIMAL_DECLARATION            shift and go to state 93
    ASSIGNMENT_DECLARATION         shift and go to state 94
    COMENTARIOLEX                  shift and go to state 95
    IF_STRUCTURE                   shift and go to state 96
    FOR_STRUCTURE                  shift and go to state 97
    WHILE_STRUCTURE                shift and go to state 98
    SWITCH_STRUCTURE               shift and go to state 99
    INTEGER_TYPE                   shift and go to state 101
    DECIMAL_TYPE                   shift and go to state 103

state 161

    (56) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE . SWITCH_BODY RCURL_BRACE
    (53) SWITCH_BODY -> . SWITCH_CASE
    (54) SWITCH_BODY -> . SWITCH_DEFAULT
    (55) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (51) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (52) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    CASE            shift and go to state 82
    DEFAULT         shift and go to state 83

    SWITCH_BODY                    shift and go to state 167
    SWITCH_CASE                    shift and go to state 77
    SWITCH_DEFAULT                 shift and go to state 78

state 162

    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (71) EXPRESSIONS -> . EXPRESSION
    (72) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (69) EXPRESSION -> . CODE SEMICOLON
    (70) EXPRESSION -> . CONTROL_STRUCTURES
    (64) CODE -> . FUNCTION
    (65) CODE -> . INTEGER_DECLARATION
    (66) CODE -> . DECIMAL_DECLARATION
    (67) CODE -> . ASSIGNMENT_DECLARATION
    (68) CODE -> . COMENTARIOLEX
    (43) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (44) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (45) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (46) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (73) FUNCTION -> . VARNAME LPAREN FUNCTION_ARGUMENTS RPAREN
    (81) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (82) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (83) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (96) COMENTARIOLEX -> . COMMENT
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (61) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (59) FOR_STRUCTURE -> . INTEGER
    (50) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (56) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (76) INTEGER_TYPE -> . INT
    (77) INTEGER_TYPE -> . SHORT
    (78) INTEGER_TYPE -> . LONG
    (79) DECIMAL_TYPE -> . FLOAT
    (80) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 100
    COMMENT         shift and go to state 62
    IF              shift and go to state 43
    INTEGER         shift and go to state 102
    WHILE           shift and go to state 41
    SWITCH          shift and go to state 42
    INT             shift and go to state 45
    SHORT           shift and go to state 46
    LONG            shift and go to state 47
    FLOAT           shift and go to state 48
    DOUBLE          shift and go to state 49

    EXPRESSIONS                    shift and go to state 168
    EXPRESSION                     shift and go to state 87
    CODE                           shift and go to state 89
    CONTROL_STRUCTURES             shift and go to state 90
    FUNCTION                       shift and go to state 91
    INTEGER_DECLARATION            shift and go to state 92
    DECIMAL_DECLARATION            shift and go to state 93
    ASSIGNMENT_DECLARATION         shift and go to state 94
    COMENTARIOLEX                  shift and go to state 95
    IF_STRUCTURE                   shift and go to state 96
    FOR_STRUCTURE                  shift and go to state 97
    WHILE_STRUCTURE                shift and go to state 98
    SWITCH_STRUCTURE               shift and go to state 99
    INTEGER_TYPE                   shift and go to state 101
    DECIMAL_TYPE                   shift and go to state 103

state 163

    (51) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 169


state 164

    (52) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .

    $end            reduce using rule 52 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 52 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)


state 165

    (50) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE . RCURL_BRACE

    RCURL_BRACE     shift and go to state 170


state 166

    (47) BODY_STRUCTURE -> EXPRESSIONS .
    (48) BODY_STRUCTURE -> EXPRESSIONS . BREAK SEMICOLON
    (49) BODY_STRUCTURE -> EXPRESSIONS . CONTINUE SEMICOLON

    RCURL_BRACE     reduce using rule 47 (BODY_STRUCTURE -> EXPRESSIONS .)
    BREAK           shift and go to state 171
    CONTINUE        shift and go to state 172


state 167

    (56) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY . RCURL_BRACE

    RCURL_BRACE     shift and go to state 173


state 168

    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE
    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE ELSE_STRUCTURE

    RCURL_BRACE     shift and go to state 174


state 169

    (51) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .

    CASE            reduce using rule 51 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    DEFAULT         reduce using rule 51 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    $end            reduce using rule 51 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 51 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)


state 170

    (50) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .

    $end            reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    VARNAME         reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    COMMENT         reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    IF              reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    INTEGER         reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    WHILE           reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SWITCH          reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    INT             reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SHORT           reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    LONG            reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    FLOAT           reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    DOUBLE          reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    BREAK           reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    CONTINUE        reduce using rule 50 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)


state 171

    (48) BODY_STRUCTURE -> EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 175


state 172

    (49) BODY_STRUCTURE -> EXPRESSIONS CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 176


state 173

    (56) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .

    $end            reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    VARNAME         reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    COMMENT         reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    IF              reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    INTEGER         reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    WHILE           reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SWITCH          reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    INT             reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SHORT           reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    LONG            reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    FLOAT           reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    DOUBLE          reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    BREAK           reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    CONTINUE        reduce using rule 56 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)


state 174

    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .
    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE . ELSE_STRUCTURE
    (62) ELSE_STRUCTURE -> . ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (63) ELSE_STRUCTURE -> . ELSE IF_STRUCTURE

    $end            reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    VARNAME         reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    COMMENT         reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    IF              reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INTEGER         reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    WHILE           reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SWITCH          reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INT             reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SHORT           reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    LONG            reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FLOAT           reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    DOUBLE          reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    BREAK           reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    CONTINUE        reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    ELSE            shift and go to state 80

    ELSE_STRUCTURE                 shift and go to state 177

state 175

    (48) BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .

    RCURL_BRACE     reduce using rule 48 (BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .)


state 176

    (49) BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .

    RCURL_BRACE     reduce using rule 49 (BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .)


state 177

    (61) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .

    $end            reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    VARNAME         reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    COMMENT         reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    IF              reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    INTEGER         reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    WHILE           reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    SWITCH          reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    INT             reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    SHORT           reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    LONG            reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    FLOAT           reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    DOUBLE          reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    RCURL_BRACE     reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    BREAK           reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    CONTINUE        reduce using rule 61 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (ROOT -> DEFINE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> DEFINE) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (ROOT -> INCLUDE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> INCLUDE) in state 4
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (VALUE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (SENTENCE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (ROOT -> CONTROL_STRUCTURES)
WARNING: rejected rule (EXPRESSION -> CONTROL_STRUCTURES) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (ROOT -> WHILE_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> WHILE_STRUCTURE) in state 8
WARNING: reduce/reduce conflict in state 9 resolved using rule (ROOT -> SWITCH_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> SWITCH_STRUCTURE) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (ROOT -> IF_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> IF_STRUCTURE) in state 10
WARNING: reduce/reduce conflict in state 11 resolved using rule (ROOT -> FOR_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> FOR_STRUCTURE) in state 11
WARNING: reduce/reduce conflict in state 13 resolved using rule (ROOT -> EXPRESSION)
WARNING: rejected rule (EXPRESSIONS -> EXPRESSION) in state 13
WARNING: reduce/reduce conflict in state 15 resolved using rule (ROOT -> FUNCTION)
WARNING: rejected rule (CODE -> FUNCTION) in state 15
WARNING: reduce/reduce conflict in state 18 resolved using rule (ROOT -> INTEGER_DECLARATION)
WARNING: rejected rule (CODE -> INTEGER_DECLARATION) in state 18
WARNING: reduce/reduce conflict in state 19 resolved using rule (ROOT -> DECIMAL_DECLARATION)
WARNING: rejected rule (CODE -> DECIMAL_DECLARATION) in state 19
WARNING: reduce/reduce conflict in state 20 resolved using rule (ROOT -> ASSIGNMENT_DECLARATION)
WARNING: rejected rule (CODE -> ASSIGNMENT_DECLARATION) in state 20
WARNING: reduce/reduce conflict in state 22 resolved using rule (ROOT -> COMENTARIOLEX)
WARNING: rejected rule (CODE -> COMENTARIOLEX) in state 22
WARNING: reduce/reduce conflict in state 25 resolved using rule (ROOT -> OPERATION)
WARNING: rejected rule (OPERATIONS -> OPERATION) in state 25
WARNING: reduce/reduce conflict in state 28 resolved using rule (ROOT -> COMPARISON)
WARNING: rejected rule (COMPARISONS -> COMPARISON) in state 28
WARNING: reduce/reduce conflict in state 29 resolved using rule (ROOT -> COMPARISONS)
WARNING: rejected rule (FUNCTION_ARGUMENTS -> COMPARISONS) in state 29
WARNING: reduce/reduce conflict in state 31 resolved using rule (ROOT -> SENTENCE)
WARNING: rejected rule (SENTENCES -> SENTENCE) in state 31
WARNING: reduce/reduce conflict in state 39 resolved using rule (NUMBER -> INTEGER)
WARNING: rejected rule (FOR_STRUCTURE -> INTEGER) in state 39
WARNING: reduce/reduce conflict in state 44 resolved using rule (VARIABLELEX -> VARNAME)
WARNING: rejected rule (SENTENCE -> VARNAME) in state 44
WARNING: Rule (PREPROCESOR_DIRECTIVE -> DEFINE) is never reduced
WARNING: Rule (PREPROCESOR_DIRECTIVE -> INCLUDE) is never reduced
