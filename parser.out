Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AUTO
    BACKSLASH
    BACKSPACE
    B_AND
    B_COMPLEMENT
    B_OR
    B_XOR
    CHAR
    CHARACTER
    COMMA
    CONST
    DO
    DOT
    DOUBLE_APOS
    DOUBLE_QUOTE
    ENUM
    EXTERN
    FF_PAGEBREAK
    FOR
    FS_CHAR
    FS_DOUBLE
    FS_FLOAT
    FS_HEX
    FS_INT
    FS_LONG
    FS_LONG_DOUBLE
    FS_OCT
    FS_OCT_LONG
    FS_POINTER
    FS_SCI_NOTATION
    FS_STRING
    FS_UNSIGNED_INT
    FS_UNSIGNED_LONG
    GOTO
    HTAB
    IGNORE
    LBRACKET
    NEWLINE
    NULL
    PP_DATE
    PP_DTMACRO
    PP_ERROR
    PP_FILE
    PP_IF
    PP_IFDEF
    PP_IFNDEF
    PP_LINE
    PP_PRAGMA
    PP_STMACRO
    PP_TIME
    PP_TIMESTAMP
    PP_UNDEF
    QUESTIONMARK
    RBRACKET
    REGISTER
    RETURN
    SHIFT_LEFT
    SHIFT_RIGHT
    SIGNED
    SINGLE_APOS
    SINGLE_QUOTE
    SIZEOF
    STATIC
    STRUCT
    TILDE
    TYPEDEF
    UNION
    UNSIGNED
    VOID
    VOLTILE
    VTAB

Grammar

Rule 0     S' -> ROOT
Rule 1     ROOT -> PREPROCESOR_DIRECTIVE
Rule 2     ROOT -> DEFINE
Rule 3     ROOT -> INCLUDE
Rule 4     ROOT -> VALUE
Rule 5     ROOT -> NUMBER
Rule 6     ROOT -> CONTROL_STRUCTURES
Rule 7     ROOT -> WHILE_STRUCTURE
Rule 8     ROOT -> SWITCH_STRUCTURE
Rule 9     ROOT -> IF_STRUCTURE
Rule 10    ROOT -> FOR_STRUCTURE
Rule 11    ROOT -> CODE
Rule 12    ROOT -> EXPRESSION
Rule 13    ROOT -> EXPRESSIONS
Rule 14    ROOT -> FUNCTION
Rule 15    ROOT -> INTEGER_TYPE
Rule 16    ROOT -> DECIMAL_TYPE
Rule 17    ROOT -> INTEGER_DECLARATION
Rule 18    ROOT -> DECIMAL_DECLARATION
Rule 19    ROOT -> ASSIGNMENT_DECLARATION
Rule 20    ROOT -> ASSIGNMENT_OPERATOR
Rule 21    ROOT -> COMENTARIOLEX
Rule 22    ROOT -> VARIABLELEX
Rule 23    ROOT -> OPERATOR
Rule 24    ROOT -> OPERATION
Rule 25    ROOT -> OPERATIONS
Rule 26    ROOT -> COMPARISON_OPERATOR
Rule 27    ROOT -> COMPARISON
Rule 28    ROOT -> COMPARISONS
Rule 29    ROOT -> LOGICAL_OPERATOR
Rule 30    ROOT -> SENTENCE
Rule 31    ROOT -> SWITCH_BODY
Rule 32    ROOT -> BUCLE
Rule 33    ROOT -> ELSE_STRUCTURE
Rule 34    PREPROCESOR_DIRECTIVE -> DEFINE
Rule 35    PREPROCESOR_DIRECTIVE -> INCLUDE
Rule 36    DEFINE -> PP_DEFINE VARIABLELEX VALUE
Rule 37    INCLUDE -> PP_INCLUDE HEADER_LIB
Rule 38    VALUE -> NUMBER
Rule 39    VALUE -> STRING
Rule 40    NUMBER -> INTEGER
Rule 41    NUMBER -> DECIMAL
Rule 42    CONTROL_STRUCTURES -> IF_STRUCTURE
Rule 43    CONTROL_STRUCTURES -> FOR_STRUCTURE
Rule 44    CONTROL_STRUCTURES -> WHILE_STRUCTURE
Rule 45    CONTROL_STRUCTURES -> SWITCH_STRUCTURE
Rule 46    BODY_STRUCTURE -> EXPRESSIONS
Rule 47    BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON
Rule 48    BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON
Rule 49    WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
Rule 50    SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
Rule 51    SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON
Rule 52    SWITCH_BODY -> SWITCH_CASE
Rule 53    SWITCH_BODY -> SWITCH_DEFAULT
Rule 54    SWITCH_BODY -> SWITCH_CASE SWITCH_BODY
Rule 55    SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
Rule 56    BUCLE -> VARIABLELEX INCREASE
Rule 57    BUCLE -> DECREASE VARIABLELEX
Rule 58    FOR_STRUCTURE -> INTEGER
Rule 59    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 60    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
Rule 61    ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 62    ELSE_STRUCTURE -> ELSE IF_STRUCTURE
Rule 63    CODE -> FUNCTION
Rule 64    CODE -> INTEGER_DECLARATION
Rule 65    CODE -> DECIMAL_DECLARATION
Rule 66    CODE -> ASSIGNMENT_DECLARATION
Rule 67    CODE -> COMENTARIOLEX
Rule 68    EXPRESSION -> CODE SEMICOLON
Rule 69    EXPRESSION -> CONTROL_STRUCTURES
Rule 70    EXPRESSIONS -> EXPRESSION
Rule 71    EXPRESSIONS -> EXPRESSION EXPRESSIONS
Rule 72    FUNCTION -> VARNAME LPAREN RPAREN
Rule 73    INTEGER_TYPE -> INT
Rule 74    INTEGER_TYPE -> SHORT
Rule 75    INTEGER_TYPE -> LONG
Rule 76    DECIMAL_TYPE -> FLOAT
Rule 77    DECIMAL_TYPE -> DOUBLE
Rule 78    INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER
Rule 79    DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL
Rule 80    ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE
Rule 81    ASSIGNMENT_OPERATOR -> EQUAL
Rule 82    ASSIGNMENT_OPERATOR -> PLUS_EQUAL
Rule 83    ASSIGNMENT_OPERATOR -> MINUS_EQUAL
Rule 84    ASSIGNMENT_OPERATOR -> DIV_EQUAL
Rule 85    ASSIGNMENT_OPERATOR -> TIMES_EQUAL
Rule 86    ASSIGNMENT_OPERATOR -> MOD_EQUAL
Rule 87    ASSIGNMENT_OPERATOR -> AND_EQUAL
Rule 88    ASSIGNMENT_OPERATOR -> OR_EQUAL
Rule 89    ASSIGNMENT_OPERATOR -> XOR_EQUAL
Rule 90    ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL
Rule 91    ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL
Rule 92    ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL
Rule 93    COMENTARIOLEX -> COMMENT
Rule 94    VARIABLELEX -> VARNAME
Rule 95    OPERATOR -> PLUS
Rule 96    OPERATOR -> MINUS
Rule 97    OPERATOR -> TIMES
Rule 98    OPERATOR -> MODULUS
Rule 99    OPERATOR -> DIVIDE
Rule 100   OPERATION -> NUMBER OPERATOR NUMBER
Rule 101   OPERATIONS -> OPERATION
Rule 102   OPERATIONS -> OPERATION OPERATOR OPERATIONS
Rule 103   COMPARISON_OPERATOR -> EQUAL_TO
Rule 104   COMPARISON_OPERATOR -> NOT_EQUAL
Rule 105   COMPARISON_OPERATOR -> GREATER_THAN
Rule 106   COMPARISON_OPERATOR -> LESS_THAN
Rule 107   COMPARISON_OPERATOR -> GREATER_EQUAL
Rule 108   COMPARISON_OPERATOR -> LESS_EQUAL
Rule 109   COMPARISON -> VALUE COMPARISON_OPERATOR VALUE
Rule 110   COMPARISONS -> COMPARISON
Rule 111   COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS
Rule 112   LOGICAL_OPERATOR -> AND
Rule 113   LOGICAL_OPERATOR -> OR
Rule 114   LOGICAL_OPERATOR -> NOT
Rule 115   SENTENCE -> NUMBER
Rule 116   SENTENCE -> VARNAME

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 112
AND_EQUAL            : 87
AUTO                 : 
BACKSLASH            : 
BACKSPACE            : 
BREAK                : 47 50 51
B_AND                : 
B_COMPLEMENT         : 
B_OR                 : 
B_XOR                : 
CASE                 : 50
CHAR                 : 
CHARACTER            : 
COLON                : 50 51
COMMA                : 
COMMENT              : 93
COMPLEMENT_EQUAL     : 90
CONST                : 
CONTINUE             : 48
DECIMAL              : 41 79
DECREASE             : 57
DEFAULT              : 51
DIVIDE               : 99
DIV_EQUAL            : 84
DO                   : 
DOT                  : 
DOUBLE               : 77
DOUBLE_APOS          : 
DOUBLE_QUOTE         : 
ELSE                 : 61 62
ENUM                 : 
EQUAL                : 78 79 81
EQUAL_TO             : 103
EXTERN               : 
FF_PAGEBREAK         : 
FLOAT                : 76
FOR                  : 
FS_CHAR              : 
FS_DOUBLE            : 
FS_FLOAT             : 
FS_HEX               : 
FS_INT               : 
FS_LONG              : 
FS_LONG_DOUBLE       : 
FS_OCT               : 
FS_OCT_LONG          : 
FS_POINTER           : 
FS_SCI_NOTATION      : 
FS_STRING            : 
FS_UNSIGNED_INT      : 
FS_UNSIGNED_LONG     : 
GOTO                 : 
GREATER_EQUAL        : 107
GREATER_THAN         : 105
HEADER_LIB           : 37
HTAB                 : 
IF                   : 59 60
IGNORE               : 
INCREASE             : 56
INT                  : 73
INTEGER              : 40 50 58 78
LBRACKET             : 
LCURL_BRACE          : 49 55 59 60 61
LESS_EQUAL           : 108
LESS_THAN            : 106
LONG                 : 75
LPAREN               : 49 55 59 60 72
MINUS                : 96
MINUS_EQUAL          : 83
MODULUS              : 98
MOD_EQUAL            : 86
NEWLINE              : 
NOT                  : 114
NOT_EQUAL            : 104
NULL                 : 
OR                   : 113
OR_EQUAL             : 88
PLUS                 : 95
PLUS_EQUAL           : 82
PP_DATE              : 
PP_DEFINE            : 36
PP_DTMACRO           : 
PP_ERROR             : 
PP_FILE              : 
PP_IF                : 
PP_IFDEF             : 
PP_IFNDEF            : 
PP_INCLUDE           : 37
PP_LINE              : 
PP_PRAGMA            : 
PP_STMACRO           : 
PP_TIME              : 
PP_TIMESTAMP         : 
PP_UNDEF             : 
QUESTIONMARK         : 
RBRACKET             : 
RCURL_BRACE          : 49 55 59 60 61
REGISTER             : 
RETURN               : 
RPAREN               : 49 55 59 60 72
SEMICOLON            : 47 48 50 51 68
SHIFTL_EQUAL         : 91
SHIFTR_EQUAL         : 92
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
SHORT                : 74
SIGNED               : 
SINGLE_APOS          : 
SINGLE_QUOTE         : 
SIZEOF               : 
STATIC               : 
STRING               : 39
STRUCT               : 
SWITCH               : 55
TILDE                : 
TIMES                : 97
TIMES_EQUAL          : 85
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VARNAME              : 72 78 79 80 94 116
VOID                 : 
VOLTILE              : 
VTAB                 : 
WHILE                : 49
XOR_EQUAL            : 89
error                : 

Nonterminals, with rules where they appear

ASSIGNMENT_DECLARATION : 19 66
ASSIGNMENT_OPERATOR  : 20 80
BODY_STRUCTURE       : 49
BUCLE                : 32
CODE                 : 11 68
COMENTARIOLEX        : 21 67
COMPARISON           : 27 110 111
COMPARISONS          : 28 49 55 59 60 111
COMPARISON_OPERATOR  : 26 109
CONTROL_STRUCTURES   : 6 69
DECIMAL_DECLARATION  : 18 65
DECIMAL_TYPE         : 16 79
DEFINE               : 2 34
ELSE_STRUCTURE       : 33 60
EXPRESSION           : 12 70 71
EXPRESSIONS          : 13 46 47 48 50 51 59 60 61 71
FOR_STRUCTURE        : 10 43
FUNCTION             : 14 63
IF_STRUCTURE         : 9 42 62
INCLUDE              : 3 35
INTEGER_DECLARATION  : 17 64
INTEGER_TYPE         : 15 78
LOGICAL_OPERATOR     : 29 111
NUMBER               : 5 38 100 100 115
OPERATION            : 24 101 102
OPERATIONS           : 25 102
OPERATOR             : 23 100 102
PREPROCESOR_DIRECTIVE : 1
ROOT                 : 0
SENTENCE             : 30 80
SWITCH_BODY          : 31 54 55
SWITCH_CASE          : 52 54
SWITCH_DEFAULT       : 53
SWITCH_STRUCTURE     : 8 45
VALUE                : 4 36 109 109
VARIABLELEX          : 22 36 56 57
WHILE_STRUCTURE      : 7 44

Parsing method: LALR

state 0

    (0) S' -> . ROOT
    (1) ROOT -> . PREPROCESOR_DIRECTIVE
    (2) ROOT -> . DEFINE
    (3) ROOT -> . INCLUDE
    (4) ROOT -> . VALUE
    (5) ROOT -> . NUMBER
    (6) ROOT -> . CONTROL_STRUCTURES
    (7) ROOT -> . WHILE_STRUCTURE
    (8) ROOT -> . SWITCH_STRUCTURE
    (9) ROOT -> . IF_STRUCTURE
    (10) ROOT -> . FOR_STRUCTURE
    (11) ROOT -> . CODE
    (12) ROOT -> . EXPRESSION
    (13) ROOT -> . EXPRESSIONS
    (14) ROOT -> . FUNCTION
    (15) ROOT -> . INTEGER_TYPE
    (16) ROOT -> . DECIMAL_TYPE
    (17) ROOT -> . INTEGER_DECLARATION
    (18) ROOT -> . DECIMAL_DECLARATION
    (19) ROOT -> . ASSIGNMENT_DECLARATION
    (20) ROOT -> . ASSIGNMENT_OPERATOR
    (21) ROOT -> . COMENTARIOLEX
    (22) ROOT -> . VARIABLELEX
    (23) ROOT -> . OPERATOR
    (24) ROOT -> . OPERATION
    (25) ROOT -> . OPERATIONS
    (26) ROOT -> . COMPARISON_OPERATOR
    (27) ROOT -> . COMPARISON
    (28) ROOT -> . COMPARISONS
    (29) ROOT -> . LOGICAL_OPERATOR
    (30) ROOT -> . SENTENCE
    (31) ROOT -> . SWITCH_BODY
    (32) ROOT -> . BUCLE
    (33) ROOT -> . ELSE_STRUCTURE
    (34) PREPROCESOR_DIRECTIVE -> . DEFINE
    (35) PREPROCESOR_DIRECTIVE -> . INCLUDE
    (36) DEFINE -> . PP_DEFINE VARIABLELEX VALUE
    (37) INCLUDE -> . PP_INCLUDE HEADER_LIB
    (38) VALUE -> . NUMBER
    (39) VALUE -> . STRING
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL
    (42) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (43) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (44) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (45) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (49) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (55) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (59) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (58) FOR_STRUCTURE -> . INTEGER
    (63) CODE -> . FUNCTION
    (64) CODE -> . INTEGER_DECLARATION
    (65) CODE -> . DECIMAL_DECLARATION
    (66) CODE -> . ASSIGNMENT_DECLARATION
    (67) CODE -> . COMENTARIOLEX
    (68) EXPRESSION -> . CODE SEMICOLON
    (69) EXPRESSION -> . CONTROL_STRUCTURES
    (70) EXPRESSIONS -> . EXPRESSION
    (71) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (72) FUNCTION -> . VARNAME LPAREN RPAREN
    (73) INTEGER_TYPE -> . INT
    (74) INTEGER_TYPE -> . SHORT
    (75) INTEGER_TYPE -> . LONG
    (76) DECIMAL_TYPE -> . FLOAT
    (77) DECIMAL_TYPE -> . DOUBLE
    (78) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (79) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (80) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (81) ASSIGNMENT_OPERATOR -> . EQUAL
    (82) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (83) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (84) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (85) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (86) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (87) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (88) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (89) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (90) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (91) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (92) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL
    (93) COMENTARIOLEX -> . COMMENT
    (94) VARIABLELEX -> . VARNAME
    (95) OPERATOR -> . PLUS
    (96) OPERATOR -> . MINUS
    (97) OPERATOR -> . TIMES
    (98) OPERATOR -> . MODULUS
    (99) OPERATOR -> . DIVIDE
    (100) OPERATION -> . NUMBER OPERATOR NUMBER
    (101) OPERATIONS -> . OPERATION
    (102) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (103) COMPARISON_OPERATOR -> . EQUAL_TO
    (104) COMPARISON_OPERATOR -> . NOT_EQUAL
    (105) COMPARISON_OPERATOR -> . GREATER_THAN
    (106) COMPARISON_OPERATOR -> . LESS_THAN
    (107) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (108) COMPARISON_OPERATOR -> . LESS_EQUAL
    (109) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (110) COMPARISONS -> . COMPARISON
    (111) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (112) LOGICAL_OPERATOR -> . AND
    (113) LOGICAL_OPERATOR -> . OR
    (114) LOGICAL_OPERATOR -> . NOT
    (115) SENTENCE -> . NUMBER
    (116) SENTENCE -> . VARNAME
    (52) SWITCH_BODY -> . SWITCH_CASE
    (53) SWITCH_BODY -> . SWITCH_DEFAULT
    (54) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (56) BUCLE -> . VARIABLELEX INCREASE
    (57) BUCLE -> . DECREASE VARIABLELEX
    (61) ELSE_STRUCTURE -> . ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) ELSE_STRUCTURE -> . ELSE IF_STRUCTURE
    (50) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (51) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    PP_DEFINE       shift and go to state 35
    PP_INCLUDE      shift and go to state 36
    STRING          shift and go to state 37
    INTEGER         shift and go to state 38
    DECIMAL         shift and go to state 39
    WHILE           shift and go to state 40
    SWITCH          shift and go to state 41
    IF              shift and go to state 42
    VARNAME         shift and go to state 43
    INT             shift and go to state 44
    SHORT           shift and go to state 45
    LONG            shift and go to state 46
    FLOAT           shift and go to state 47
    DOUBLE          shift and go to state 48
    EQUAL           shift and go to state 49
    PLUS_EQUAL      shift and go to state 50
    MINUS_EQUAL     shift and go to state 51
    DIV_EQUAL       shift and go to state 52
    TIMES_EQUAL     shift and go to state 53
    MOD_EQUAL       shift and go to state 54
    AND_EQUAL       shift and go to state 55
    OR_EQUAL        shift and go to state 56
    XOR_EQUAL       shift and go to state 57
    COMPLEMENT_EQUAL shift and go to state 58
    SHIFTL_EQUAL    shift and go to state 59
    SHIFTR_EQUAL    shift and go to state 60
    COMMENT         shift and go to state 61
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    MODULUS         shift and go to state 65
    DIVIDE          shift and go to state 66
    EQUAL_TO        shift and go to state 67
    NOT_EQUAL       shift and go to state 68
    GREATER_THAN    shift and go to state 69
    LESS_THAN       shift and go to state 70
    GREATER_EQUAL   shift and go to state 71
    LESS_EQUAL      shift and go to state 72
    AND             shift and go to state 73
    OR              shift and go to state 74
    NOT             shift and go to state 75
    DECREASE        shift and go to state 78
    ELSE            shift and go to state 79
    CASE            shift and go to state 80
    DEFAULT         shift and go to state 81

    ROOT                           shift and go to state 1
    PREPROCESOR_DIRECTIVE          shift and go to state 2
    DEFINE                         shift and go to state 3
    INCLUDE                        shift and go to state 4
    VALUE                          shift and go to state 5
    NUMBER                         shift and go to state 6
    CONTROL_STRUCTURES             shift and go to state 7
    WHILE_STRUCTURE                shift and go to state 8
    SWITCH_STRUCTURE               shift and go to state 9
    IF_STRUCTURE                   shift and go to state 10
    FOR_STRUCTURE                  shift and go to state 11
    CODE                           shift and go to state 12
    EXPRESSION                     shift and go to state 13
    EXPRESSIONS                    shift and go to state 14
    FUNCTION                       shift and go to state 15
    INTEGER_TYPE                   shift and go to state 16
    DECIMAL_TYPE                   shift and go to state 17
    INTEGER_DECLARATION            shift and go to state 18
    DECIMAL_DECLARATION            shift and go to state 19
    ASSIGNMENT_DECLARATION         shift and go to state 20
    ASSIGNMENT_OPERATOR            shift and go to state 21
    COMENTARIOLEX                  shift and go to state 22
    VARIABLELEX                    shift and go to state 23
    OPERATOR                       shift and go to state 24
    OPERATION                      shift and go to state 25
    OPERATIONS                     shift and go to state 26
    COMPARISON_OPERATOR            shift and go to state 27
    COMPARISON                     shift and go to state 28
    COMPARISONS                    shift and go to state 29
    LOGICAL_OPERATOR               shift and go to state 30
    SENTENCE                       shift and go to state 31
    SWITCH_BODY                    shift and go to state 32
    BUCLE                          shift and go to state 33
    ELSE_STRUCTURE                 shift and go to state 34
    SWITCH_CASE                    shift and go to state 76
    SWITCH_DEFAULT                 shift and go to state 77

state 1

    (0) S' -> ROOT .



state 2

    (1) ROOT -> PREPROCESOR_DIRECTIVE .

    $end            reduce using rule 1 (ROOT -> PREPROCESOR_DIRECTIVE .)


state 3

    (2) ROOT -> DEFINE .
    (34) PREPROCESOR_DIRECTIVE -> DEFINE .

  ! reduce/reduce conflict for $end resolved using rule 2 (ROOT -> DEFINE .)
    $end            reduce using rule 2 (ROOT -> DEFINE .)

  ! $end            [ reduce using rule 34 (PREPROCESOR_DIRECTIVE -> DEFINE .) ]


state 4

    (3) ROOT -> INCLUDE .
    (35) PREPROCESOR_DIRECTIVE -> INCLUDE .

  ! reduce/reduce conflict for $end resolved using rule 3 (ROOT -> INCLUDE .)
    $end            reduce using rule 3 (ROOT -> INCLUDE .)

  ! $end            [ reduce using rule 35 (PREPROCESOR_DIRECTIVE -> INCLUDE .) ]


state 5

    (4) ROOT -> VALUE .
    (109) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (103) COMPARISON_OPERATOR -> . EQUAL_TO
    (104) COMPARISON_OPERATOR -> . NOT_EQUAL
    (105) COMPARISON_OPERATOR -> . GREATER_THAN
    (106) COMPARISON_OPERATOR -> . LESS_THAN
    (107) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (108) COMPARISON_OPERATOR -> . LESS_EQUAL

    $end            reduce using rule 4 (ROOT -> VALUE .)
    EQUAL_TO        shift and go to state 67
    NOT_EQUAL       shift and go to state 68
    GREATER_THAN    shift and go to state 69
    LESS_THAN       shift and go to state 70
    GREATER_EQUAL   shift and go to state 71
    LESS_EQUAL      shift and go to state 72

    COMPARISON_OPERATOR            shift and go to state 82

state 6

    (5) ROOT -> NUMBER .
    (38) VALUE -> NUMBER .
    (100) OPERATION -> NUMBER . OPERATOR NUMBER
    (115) SENTENCE -> NUMBER .
    (95) OPERATOR -> . PLUS
    (96) OPERATOR -> . MINUS
    (97) OPERATOR -> . TIMES
    (98) OPERATOR -> . MODULUS
    (99) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
    $end            reduce using rule 5 (ROOT -> NUMBER .)
    EQUAL_TO        reduce using rule 38 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 38 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 38 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 38 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 38 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 38 (VALUE -> NUMBER .)
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    MODULUS         shift and go to state 65
    DIVIDE          shift and go to state 66

  ! $end            [ reduce using rule 38 (VALUE -> NUMBER .) ]
  ! $end            [ reduce using rule 115 (SENTENCE -> NUMBER .) ]

    OPERATOR                       shift and go to state 83

state 7

    (6) ROOT -> CONTROL_STRUCTURES .
    (69) EXPRESSION -> CONTROL_STRUCTURES .

  ! reduce/reduce conflict for $end resolved using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    $end            reduce using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    VARNAME         reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    INTEGER         reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)

  ! $end            [ reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .) ]


state 8

    (7) ROOT -> WHILE_STRUCTURE .
    (44) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 7 (ROOT -> WHILE_STRUCTURE .)
    $end            reduce using rule 7 (ROOT -> WHILE_STRUCTURE .)
    VARNAME         reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INTEGER         reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)

  ! $end            [ reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .) ]


state 9

    (8) ROOT -> SWITCH_STRUCTURE .
    (45) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    $end            reduce using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    VARNAME         reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INTEGER         reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)

  ! $end            [ reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .) ]


state 10

    (9) ROOT -> IF_STRUCTURE .
    (42) CONTROL_STRUCTURES -> IF_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 9 (ROOT -> IF_STRUCTURE .)
    $end            reduce using rule 9 (ROOT -> IF_STRUCTURE .)
    VARNAME         reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INTEGER         reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)

  ! $end            [ reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .) ]


state 11

    (10) ROOT -> FOR_STRUCTURE .
    (43) CONTROL_STRUCTURES -> FOR_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 10 (ROOT -> FOR_STRUCTURE .)
    $end            reduce using rule 10 (ROOT -> FOR_STRUCTURE .)
    VARNAME         reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INTEGER         reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)

  ! $end            [ reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .) ]


state 12

    (11) ROOT -> CODE .
    (68) EXPRESSION -> CODE . SEMICOLON

    $end            reduce using rule 11 (ROOT -> CODE .)
    SEMICOLON       shift and go to state 84


state 13

    (12) ROOT -> EXPRESSION .
    (70) EXPRESSIONS -> EXPRESSION .
    (71) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (70) EXPRESSIONS -> . EXPRESSION
    (71) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (68) EXPRESSION -> . CODE SEMICOLON
    (69) EXPRESSION -> . CONTROL_STRUCTURES
    (63) CODE -> . FUNCTION
    (64) CODE -> . INTEGER_DECLARATION
    (65) CODE -> . DECIMAL_DECLARATION
    (66) CODE -> . ASSIGNMENT_DECLARATION
    (67) CODE -> . COMENTARIOLEX
    (42) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (43) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (44) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (45) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (72) FUNCTION -> . VARNAME LPAREN RPAREN
    (78) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (79) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (80) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (93) COMENTARIOLEX -> . COMMENT
    (59) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (58) FOR_STRUCTURE -> . INTEGER
    (49) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (55) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (73) INTEGER_TYPE -> . INT
    (74) INTEGER_TYPE -> . SHORT
    (75) INTEGER_TYPE -> . LONG
    (76) DECIMAL_TYPE -> . FLOAT
    (77) DECIMAL_TYPE -> . DOUBLE

  ! reduce/reduce conflict for $end resolved using rule 12 (ROOT -> EXPRESSION .)
    $end            reduce using rule 12 (ROOT -> EXPRESSION .)
    VARNAME         shift and go to state 98
    COMMENT         shift and go to state 61
    IF              shift and go to state 42
    INTEGER         shift and go to state 100
    WHILE           shift and go to state 40
    SWITCH          shift and go to state 41
    INT             shift and go to state 44
    SHORT           shift and go to state 45
    LONG            shift and go to state 46
    FLOAT           shift and go to state 47
    DOUBLE          shift and go to state 48

  ! $end            [ reduce using rule 70 (EXPRESSIONS -> EXPRESSION .) ]

    EXPRESSION                     shift and go to state 85
    EXPRESSIONS                    shift and go to state 86
    CODE                           shift and go to state 87
    CONTROL_STRUCTURES             shift and go to state 88
    FUNCTION                       shift and go to state 89
    INTEGER_DECLARATION            shift and go to state 90
    DECIMAL_DECLARATION            shift and go to state 91
    ASSIGNMENT_DECLARATION         shift and go to state 92
    COMENTARIOLEX                  shift and go to state 93
    IF_STRUCTURE                   shift and go to state 94
    FOR_STRUCTURE                  shift and go to state 95
    WHILE_STRUCTURE                shift and go to state 96
    SWITCH_STRUCTURE               shift and go to state 97
    INTEGER_TYPE                   shift and go to state 99
    DECIMAL_TYPE                   shift and go to state 101

state 14

    (13) ROOT -> EXPRESSIONS .

    $end            reduce using rule 13 (ROOT -> EXPRESSIONS .)


state 15

    (14) ROOT -> FUNCTION .
    (63) CODE -> FUNCTION .

  ! reduce/reduce conflict for $end resolved using rule 14 (ROOT -> FUNCTION .)
    $end            reduce using rule 14 (ROOT -> FUNCTION .)
    SEMICOLON       reduce using rule 63 (CODE -> FUNCTION .)

  ! $end            [ reduce using rule 63 (CODE -> FUNCTION .) ]


state 16

    (15) ROOT -> INTEGER_TYPE .
    (78) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    $end            reduce using rule 15 (ROOT -> INTEGER_TYPE .)
    VARNAME         shift and go to state 102


state 17

    (16) ROOT -> DECIMAL_TYPE .
    (79) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    $end            reduce using rule 16 (ROOT -> DECIMAL_TYPE .)
    VARNAME         shift and go to state 103


state 18

    (17) ROOT -> INTEGER_DECLARATION .
    (64) CODE -> INTEGER_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 17 (ROOT -> INTEGER_DECLARATION .)
    $end            reduce using rule 17 (ROOT -> INTEGER_DECLARATION .)
    SEMICOLON       reduce using rule 64 (CODE -> INTEGER_DECLARATION .)

  ! $end            [ reduce using rule 64 (CODE -> INTEGER_DECLARATION .) ]


state 19

    (18) ROOT -> DECIMAL_DECLARATION .
    (65) CODE -> DECIMAL_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    $end            reduce using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    SEMICOLON       reduce using rule 65 (CODE -> DECIMAL_DECLARATION .)

  ! $end            [ reduce using rule 65 (CODE -> DECIMAL_DECLARATION .) ]


state 20

    (19) ROOT -> ASSIGNMENT_DECLARATION .
    (66) CODE -> ASSIGNMENT_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    $end            reduce using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    SEMICOLON       reduce using rule 66 (CODE -> ASSIGNMENT_DECLARATION .)

  ! $end            [ reduce using rule 66 (CODE -> ASSIGNMENT_DECLARATION .) ]


state 21

    (20) ROOT -> ASSIGNMENT_OPERATOR .

    $end            reduce using rule 20 (ROOT -> ASSIGNMENT_OPERATOR .)


state 22

    (21) ROOT -> COMENTARIOLEX .
    (67) CODE -> COMENTARIOLEX .

  ! reduce/reduce conflict for $end resolved using rule 21 (ROOT -> COMENTARIOLEX .)
    $end            reduce using rule 21 (ROOT -> COMENTARIOLEX .)
    SEMICOLON       reduce using rule 67 (CODE -> COMENTARIOLEX .)

  ! $end            [ reduce using rule 67 (CODE -> COMENTARIOLEX .) ]


state 23

    (22) ROOT -> VARIABLELEX .
    (56) BUCLE -> VARIABLELEX . INCREASE

    $end            reduce using rule 22 (ROOT -> VARIABLELEX .)
    INCREASE        shift and go to state 104


state 24

    (23) ROOT -> OPERATOR .

    $end            reduce using rule 23 (ROOT -> OPERATOR .)


state 25

    (24) ROOT -> OPERATION .
    (101) OPERATIONS -> OPERATION .
    (102) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (95) OPERATOR -> . PLUS
    (96) OPERATOR -> . MINUS
    (97) OPERATOR -> . TIMES
    (98) OPERATOR -> . MODULUS
    (99) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 24 (ROOT -> OPERATION .)
    $end            reduce using rule 24 (ROOT -> OPERATION .)
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    MODULUS         shift and go to state 65
    DIVIDE          shift and go to state 66

  ! $end            [ reduce using rule 101 (OPERATIONS -> OPERATION .) ]

    OPERATOR                       shift and go to state 105

state 26

    (25) ROOT -> OPERATIONS .

    $end            reduce using rule 25 (ROOT -> OPERATIONS .)


state 27

    (26) ROOT -> COMPARISON_OPERATOR .

    $end            reduce using rule 26 (ROOT -> COMPARISON_OPERATOR .)


state 28

    (27) ROOT -> COMPARISON .
    (110) COMPARISONS -> COMPARISON .
    (111) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (112) LOGICAL_OPERATOR -> . AND
    (113) LOGICAL_OPERATOR -> . OR
    (114) LOGICAL_OPERATOR -> . NOT

  ! reduce/reduce conflict for $end resolved using rule 27 (ROOT -> COMPARISON .)
    $end            reduce using rule 27 (ROOT -> COMPARISON .)
    AND             shift and go to state 73
    OR              shift and go to state 74
    NOT             shift and go to state 75

  ! $end            [ reduce using rule 110 (COMPARISONS -> COMPARISON .) ]

    LOGICAL_OPERATOR               shift and go to state 106

state 29

    (28) ROOT -> COMPARISONS .

    $end            reduce using rule 28 (ROOT -> COMPARISONS .)


state 30

    (29) ROOT -> LOGICAL_OPERATOR .

    $end            reduce using rule 29 (ROOT -> LOGICAL_OPERATOR .)


state 31

    (30) ROOT -> SENTENCE .

    $end            reduce using rule 30 (ROOT -> SENTENCE .)


state 32

    (31) ROOT -> SWITCH_BODY .

    $end            reduce using rule 31 (ROOT -> SWITCH_BODY .)


state 33

    (32) ROOT -> BUCLE .

    $end            reduce using rule 32 (ROOT -> BUCLE .)


state 34

    (33) ROOT -> ELSE_STRUCTURE .

    $end            reduce using rule 33 (ROOT -> ELSE_STRUCTURE .)


state 35

    (36) DEFINE -> PP_DEFINE . VARIABLELEX VALUE
    (94) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 108

    VARIABLELEX                    shift and go to state 107

state 36

    (37) INCLUDE -> PP_INCLUDE . HEADER_LIB

    HEADER_LIB      shift and go to state 109


state 37

    (39) VALUE -> STRING .

    EQUAL_TO        reduce using rule 39 (VALUE -> STRING .)
    NOT_EQUAL       reduce using rule 39 (VALUE -> STRING .)
    GREATER_THAN    reduce using rule 39 (VALUE -> STRING .)
    LESS_THAN       reduce using rule 39 (VALUE -> STRING .)
    GREATER_EQUAL   reduce using rule 39 (VALUE -> STRING .)
    LESS_EQUAL      reduce using rule 39 (VALUE -> STRING .)
    $end            reduce using rule 39 (VALUE -> STRING .)
    AND             reduce using rule 39 (VALUE -> STRING .)
    OR              reduce using rule 39 (VALUE -> STRING .)
    NOT             reduce using rule 39 (VALUE -> STRING .)
    RPAREN          reduce using rule 39 (VALUE -> STRING .)


state 38

    (40) NUMBER -> INTEGER .
    (58) FOR_STRUCTURE -> INTEGER .

  ! reduce/reduce conflict for $end resolved using rule 40 (NUMBER -> INTEGER .)
    PLUS            reduce using rule 40 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 40 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 40 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 40 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 40 (NUMBER -> INTEGER .)
    $end            reduce using rule 40 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 40 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 40 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 40 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 40 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 40 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 40 (NUMBER -> INTEGER .)
    VARNAME         reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    COMMENT         reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    IF              reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    INTEGER         reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    WHILE           reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    SWITCH          reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    INT             reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    SHORT           reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    LONG            reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    FLOAT           reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    DOUBLE          reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)

  ! $end            [ reduce using rule 58 (FOR_STRUCTURE -> INTEGER .) ]


state 39

    (41) NUMBER -> DECIMAL .

    PLUS            reduce using rule 41 (NUMBER -> DECIMAL .)
    MINUS           reduce using rule 41 (NUMBER -> DECIMAL .)
    TIMES           reduce using rule 41 (NUMBER -> DECIMAL .)
    MODULUS         reduce using rule 41 (NUMBER -> DECIMAL .)
    DIVIDE          reduce using rule 41 (NUMBER -> DECIMAL .)
    $end            reduce using rule 41 (NUMBER -> DECIMAL .)
    EQUAL_TO        reduce using rule 41 (NUMBER -> DECIMAL .)
    NOT_EQUAL       reduce using rule 41 (NUMBER -> DECIMAL .)
    GREATER_THAN    reduce using rule 41 (NUMBER -> DECIMAL .)
    LESS_THAN       reduce using rule 41 (NUMBER -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 41 (NUMBER -> DECIMAL .)
    LESS_EQUAL      reduce using rule 41 (NUMBER -> DECIMAL .)
    AND             reduce using rule 41 (NUMBER -> DECIMAL .)
    OR              reduce using rule 41 (NUMBER -> DECIMAL .)
    NOT             reduce using rule 41 (NUMBER -> DECIMAL .)
    RPAREN          reduce using rule 41 (NUMBER -> DECIMAL .)
    SEMICOLON       reduce using rule 41 (NUMBER -> DECIMAL .)


state 40

    (49) WHILE_STRUCTURE -> WHILE . LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LPAREN          shift and go to state 110


state 41

    (55) SWITCH_STRUCTURE -> SWITCH . LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LPAREN          shift and go to state 111


state 42

    (59) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LPAREN          shift and go to state 112


state 43

    (72) FUNCTION -> VARNAME . LPAREN RPAREN
    (80) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (94) VARIABLELEX -> VARNAME .
    (116) SENTENCE -> VARNAME .
    (81) ASSIGNMENT_OPERATOR -> . EQUAL
    (82) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (83) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (84) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (85) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (86) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (87) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (88) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (89) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (90) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (91) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (92) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 94 (VARIABLELEX -> VARNAME .)
    LPAREN          shift and go to state 113
    INCREASE        reduce using rule 94 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 94 (VARIABLELEX -> VARNAME .)
    EQUAL           shift and go to state 49
    PLUS_EQUAL      shift and go to state 50
    MINUS_EQUAL     shift and go to state 51
    DIV_EQUAL       shift and go to state 52
    TIMES_EQUAL     shift and go to state 53
    MOD_EQUAL       shift and go to state 54
    AND_EQUAL       shift and go to state 55
    OR_EQUAL        shift and go to state 56
    XOR_EQUAL       shift and go to state 57
    COMPLEMENT_EQUAL shift and go to state 58
    SHIFTL_EQUAL    shift and go to state 59
    SHIFTR_EQUAL    shift and go to state 60

  ! $end            [ reduce using rule 116 (SENTENCE -> VARNAME .) ]

    ASSIGNMENT_OPERATOR            shift and go to state 114

state 44

    (73) INTEGER_TYPE -> INT .

    VARNAME         reduce using rule 73 (INTEGER_TYPE -> INT .)
    $end            reduce using rule 73 (INTEGER_TYPE -> INT .)


state 45

    (74) INTEGER_TYPE -> SHORT .

    VARNAME         reduce using rule 74 (INTEGER_TYPE -> SHORT .)
    $end            reduce using rule 74 (INTEGER_TYPE -> SHORT .)


state 46

    (75) INTEGER_TYPE -> LONG .

    VARNAME         reduce using rule 75 (INTEGER_TYPE -> LONG .)
    $end            reduce using rule 75 (INTEGER_TYPE -> LONG .)


state 47

    (76) DECIMAL_TYPE -> FLOAT .

    VARNAME         reduce using rule 76 (DECIMAL_TYPE -> FLOAT .)
    $end            reduce using rule 76 (DECIMAL_TYPE -> FLOAT .)


state 48

    (77) DECIMAL_TYPE -> DOUBLE .

    VARNAME         reduce using rule 77 (DECIMAL_TYPE -> DOUBLE .)
    $end            reduce using rule 77 (DECIMAL_TYPE -> DOUBLE .)


state 49

    (81) ASSIGNMENT_OPERATOR -> EQUAL .

    $end            reduce using rule 81 (ASSIGNMENT_OPERATOR -> EQUAL .)
    VARNAME         reduce using rule 81 (ASSIGNMENT_OPERATOR -> EQUAL .)
    INTEGER         reduce using rule 81 (ASSIGNMENT_OPERATOR -> EQUAL .)
    DECIMAL         reduce using rule 81 (ASSIGNMENT_OPERATOR -> EQUAL .)


state 50

    (82) ASSIGNMENT_OPERATOR -> PLUS_EQUAL .

    $end            reduce using rule 82 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    VARNAME         reduce using rule 82 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    INTEGER         reduce using rule 82 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    DECIMAL         reduce using rule 82 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)


state 51

    (83) ASSIGNMENT_OPERATOR -> MINUS_EQUAL .

    $end            reduce using rule 83 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    VARNAME         reduce using rule 83 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    INTEGER         reduce using rule 83 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    DECIMAL         reduce using rule 83 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)


state 52

    (84) ASSIGNMENT_OPERATOR -> DIV_EQUAL .

    $end            reduce using rule 84 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    VARNAME         reduce using rule 84 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    INTEGER         reduce using rule 84 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    DECIMAL         reduce using rule 84 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)


state 53

    (85) ASSIGNMENT_OPERATOR -> TIMES_EQUAL .

    $end            reduce using rule 85 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    VARNAME         reduce using rule 85 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    INTEGER         reduce using rule 85 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    DECIMAL         reduce using rule 85 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)


state 54

    (86) ASSIGNMENT_OPERATOR -> MOD_EQUAL .

    $end            reduce using rule 86 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    VARNAME         reduce using rule 86 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    INTEGER         reduce using rule 86 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    DECIMAL         reduce using rule 86 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)


state 55

    (87) ASSIGNMENT_OPERATOR -> AND_EQUAL .

    $end            reduce using rule 87 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    VARNAME         reduce using rule 87 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    INTEGER         reduce using rule 87 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    DECIMAL         reduce using rule 87 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)


state 56

    (88) ASSIGNMENT_OPERATOR -> OR_EQUAL .

    $end            reduce using rule 88 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    VARNAME         reduce using rule 88 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    INTEGER         reduce using rule 88 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    DECIMAL         reduce using rule 88 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)


state 57

    (89) ASSIGNMENT_OPERATOR -> XOR_EQUAL .

    $end            reduce using rule 89 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    VARNAME         reduce using rule 89 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    INTEGER         reduce using rule 89 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    DECIMAL         reduce using rule 89 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)


state 58

    (90) ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .

    $end            reduce using rule 90 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    VARNAME         reduce using rule 90 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    INTEGER         reduce using rule 90 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    DECIMAL         reduce using rule 90 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)


state 59

    (91) ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .

    $end            reduce using rule 91 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    VARNAME         reduce using rule 91 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    INTEGER         reduce using rule 91 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    DECIMAL         reduce using rule 91 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)


state 60

    (92) ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .

    $end            reduce using rule 92 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    VARNAME         reduce using rule 92 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    INTEGER         reduce using rule 92 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    DECIMAL         reduce using rule 92 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)


state 61

    (93) COMENTARIOLEX -> COMMENT .

    $end            reduce using rule 93 (COMENTARIOLEX -> COMMENT .)
    SEMICOLON       reduce using rule 93 (COMENTARIOLEX -> COMMENT .)


state 62

    (95) OPERATOR -> PLUS .

    $end            reduce using rule 95 (OPERATOR -> PLUS .)
    INTEGER         reduce using rule 95 (OPERATOR -> PLUS .)
    DECIMAL         reduce using rule 95 (OPERATOR -> PLUS .)


state 63

    (96) OPERATOR -> MINUS .

    $end            reduce using rule 96 (OPERATOR -> MINUS .)
    INTEGER         reduce using rule 96 (OPERATOR -> MINUS .)
    DECIMAL         reduce using rule 96 (OPERATOR -> MINUS .)


state 64

    (97) OPERATOR -> TIMES .

    $end            reduce using rule 97 (OPERATOR -> TIMES .)
    INTEGER         reduce using rule 97 (OPERATOR -> TIMES .)
    DECIMAL         reduce using rule 97 (OPERATOR -> TIMES .)


state 65

    (98) OPERATOR -> MODULUS .

    $end            reduce using rule 98 (OPERATOR -> MODULUS .)
    INTEGER         reduce using rule 98 (OPERATOR -> MODULUS .)
    DECIMAL         reduce using rule 98 (OPERATOR -> MODULUS .)


state 66

    (99) OPERATOR -> DIVIDE .

    $end            reduce using rule 99 (OPERATOR -> DIVIDE .)
    INTEGER         reduce using rule 99 (OPERATOR -> DIVIDE .)
    DECIMAL         reduce using rule 99 (OPERATOR -> DIVIDE .)


state 67

    (103) COMPARISON_OPERATOR -> EQUAL_TO .

    $end            reduce using rule 103 (COMPARISON_OPERATOR -> EQUAL_TO .)
    STRING          reduce using rule 103 (COMPARISON_OPERATOR -> EQUAL_TO .)
    INTEGER         reduce using rule 103 (COMPARISON_OPERATOR -> EQUAL_TO .)
    DECIMAL         reduce using rule 103 (COMPARISON_OPERATOR -> EQUAL_TO .)


state 68

    (104) COMPARISON_OPERATOR -> NOT_EQUAL .

    $end            reduce using rule 104 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    STRING          reduce using rule 104 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    INTEGER         reduce using rule 104 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    DECIMAL         reduce using rule 104 (COMPARISON_OPERATOR -> NOT_EQUAL .)


state 69

    (105) COMPARISON_OPERATOR -> GREATER_THAN .

    $end            reduce using rule 105 (COMPARISON_OPERATOR -> GREATER_THAN .)
    STRING          reduce using rule 105 (COMPARISON_OPERATOR -> GREATER_THAN .)
    INTEGER         reduce using rule 105 (COMPARISON_OPERATOR -> GREATER_THAN .)
    DECIMAL         reduce using rule 105 (COMPARISON_OPERATOR -> GREATER_THAN .)


state 70

    (106) COMPARISON_OPERATOR -> LESS_THAN .

    $end            reduce using rule 106 (COMPARISON_OPERATOR -> LESS_THAN .)
    STRING          reduce using rule 106 (COMPARISON_OPERATOR -> LESS_THAN .)
    INTEGER         reduce using rule 106 (COMPARISON_OPERATOR -> LESS_THAN .)
    DECIMAL         reduce using rule 106 (COMPARISON_OPERATOR -> LESS_THAN .)


state 71

    (107) COMPARISON_OPERATOR -> GREATER_EQUAL .

    $end            reduce using rule 107 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    STRING          reduce using rule 107 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    INTEGER         reduce using rule 107 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    DECIMAL         reduce using rule 107 (COMPARISON_OPERATOR -> GREATER_EQUAL .)


state 72

    (108) COMPARISON_OPERATOR -> LESS_EQUAL .

    $end            reduce using rule 108 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    STRING          reduce using rule 108 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    INTEGER         reduce using rule 108 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    DECIMAL         reduce using rule 108 (COMPARISON_OPERATOR -> LESS_EQUAL .)


state 73

    (112) LOGICAL_OPERATOR -> AND .

    $end            reduce using rule 112 (LOGICAL_OPERATOR -> AND .)
    STRING          reduce using rule 112 (LOGICAL_OPERATOR -> AND .)
    INTEGER         reduce using rule 112 (LOGICAL_OPERATOR -> AND .)
    DECIMAL         reduce using rule 112 (LOGICAL_OPERATOR -> AND .)


state 74

    (113) LOGICAL_OPERATOR -> OR .

    $end            reduce using rule 113 (LOGICAL_OPERATOR -> OR .)
    STRING          reduce using rule 113 (LOGICAL_OPERATOR -> OR .)
    INTEGER         reduce using rule 113 (LOGICAL_OPERATOR -> OR .)
    DECIMAL         reduce using rule 113 (LOGICAL_OPERATOR -> OR .)


state 75

    (114) LOGICAL_OPERATOR -> NOT .

    $end            reduce using rule 114 (LOGICAL_OPERATOR -> NOT .)
    STRING          reduce using rule 114 (LOGICAL_OPERATOR -> NOT .)
    INTEGER         reduce using rule 114 (LOGICAL_OPERATOR -> NOT .)
    DECIMAL         reduce using rule 114 (LOGICAL_OPERATOR -> NOT .)


state 76

    (52) SWITCH_BODY -> SWITCH_CASE .
    (54) SWITCH_BODY -> SWITCH_CASE . SWITCH_BODY
    (52) SWITCH_BODY -> . SWITCH_CASE
    (53) SWITCH_BODY -> . SWITCH_DEFAULT
    (54) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (50) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (51) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    $end            reduce using rule 52 (SWITCH_BODY -> SWITCH_CASE .)
    RCURL_BRACE     reduce using rule 52 (SWITCH_BODY -> SWITCH_CASE .)
    CASE            shift and go to state 80
    DEFAULT         shift and go to state 81

    SWITCH_CASE                    shift and go to state 76
    SWITCH_BODY                    shift and go to state 115
    SWITCH_DEFAULT                 shift and go to state 77

state 77

    (53) SWITCH_BODY -> SWITCH_DEFAULT .

    $end            reduce using rule 53 (SWITCH_BODY -> SWITCH_DEFAULT .)
    RCURL_BRACE     reduce using rule 53 (SWITCH_BODY -> SWITCH_DEFAULT .)


state 78

    (57) BUCLE -> DECREASE . VARIABLELEX
    (94) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 108

    VARIABLELEX                    shift and go to state 116

state 79

    (61) ELSE_STRUCTURE -> ELSE . LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) ELSE_STRUCTURE -> ELSE . IF_STRUCTURE
    (59) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LCURL_BRACE     shift and go to state 117
    IF              shift and go to state 42

    IF_STRUCTURE                   shift and go to state 118

state 80

    (50) SWITCH_CASE -> CASE . INTEGER COLON EXPRESSIONS BREAK SEMICOLON

    INTEGER         shift and go to state 119


state 81

    (51) SWITCH_DEFAULT -> DEFAULT . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 120


state 82

    (109) COMPARISON -> VALUE COMPARISON_OPERATOR . VALUE
    (38) VALUE -> . NUMBER
    (39) VALUE -> . STRING
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL

    STRING          shift and go to state 37
    INTEGER         shift and go to state 123
    DECIMAL         shift and go to state 39

    VALUE                          shift and go to state 121
    NUMBER                         shift and go to state 122

state 83

    (100) OPERATION -> NUMBER OPERATOR . NUMBER
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 123
    DECIMAL         shift and go to state 39

    NUMBER                         shift and go to state 124

state 84

    (68) EXPRESSION -> CODE SEMICOLON .

    VARNAME         reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    COMMENT         reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    IF              reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    INTEGER         reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    WHILE           reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    SWITCH          reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    INT             reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    SHORT           reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    LONG            reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    FLOAT           reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    DOUBLE          reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    $end            reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    RCURL_BRACE     reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    BREAK           reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)
    CONTINUE        reduce using rule 68 (EXPRESSION -> CODE SEMICOLON .)


state 85

    (70) EXPRESSIONS -> EXPRESSION .
    (71) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (70) EXPRESSIONS -> . EXPRESSION
    (71) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (68) EXPRESSION -> . CODE SEMICOLON
    (69) EXPRESSION -> . CONTROL_STRUCTURES
    (63) CODE -> . FUNCTION
    (64) CODE -> . INTEGER_DECLARATION
    (65) CODE -> . DECIMAL_DECLARATION
    (66) CODE -> . ASSIGNMENT_DECLARATION
    (67) CODE -> . COMENTARIOLEX
    (42) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (43) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (44) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (45) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (72) FUNCTION -> . VARNAME LPAREN RPAREN
    (78) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (79) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (80) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (93) COMENTARIOLEX -> . COMMENT
    (59) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (58) FOR_STRUCTURE -> . INTEGER
    (49) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (55) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (73) INTEGER_TYPE -> . INT
    (74) INTEGER_TYPE -> . SHORT
    (75) INTEGER_TYPE -> . LONG
    (76) DECIMAL_TYPE -> . FLOAT
    (77) DECIMAL_TYPE -> . DOUBLE

    $end            reduce using rule 70 (EXPRESSIONS -> EXPRESSION .)
    RCURL_BRACE     reduce using rule 70 (EXPRESSIONS -> EXPRESSION .)
    BREAK           reduce using rule 70 (EXPRESSIONS -> EXPRESSION .)
    CONTINUE        reduce using rule 70 (EXPRESSIONS -> EXPRESSION .)
    VARNAME         shift and go to state 98
    COMMENT         shift and go to state 61
    IF              shift and go to state 42
    INTEGER         shift and go to state 100
    WHILE           shift and go to state 40
    SWITCH          shift and go to state 41
    INT             shift and go to state 44
    SHORT           shift and go to state 45
    LONG            shift and go to state 46
    FLOAT           shift and go to state 47
    DOUBLE          shift and go to state 48

    EXPRESSION                     shift and go to state 85
    EXPRESSIONS                    shift and go to state 86
    CODE                           shift and go to state 87
    CONTROL_STRUCTURES             shift and go to state 88
    FUNCTION                       shift and go to state 89
    INTEGER_DECLARATION            shift and go to state 90
    DECIMAL_DECLARATION            shift and go to state 91
    ASSIGNMENT_DECLARATION         shift and go to state 92
    COMENTARIOLEX                  shift and go to state 93
    IF_STRUCTURE                   shift and go to state 94
    FOR_STRUCTURE                  shift and go to state 95
    WHILE_STRUCTURE                shift and go to state 96
    SWITCH_STRUCTURE               shift and go to state 97
    INTEGER_TYPE                   shift and go to state 99
    DECIMAL_TYPE                   shift and go to state 101

state 86

    (71) EXPRESSIONS -> EXPRESSION EXPRESSIONS .

    $end            reduce using rule 71 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    RCURL_BRACE     reduce using rule 71 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    BREAK           reduce using rule 71 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    CONTINUE        reduce using rule 71 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)


state 87

    (68) EXPRESSION -> CODE . SEMICOLON

    SEMICOLON       shift and go to state 84


state 88

    (69) EXPRESSION -> CONTROL_STRUCTURES .

    VARNAME         reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    INTEGER         reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    $end            reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    RCURL_BRACE     reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    BREAK           reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)
    CONTINUE        reduce using rule 69 (EXPRESSION -> CONTROL_STRUCTURES .)


state 89

    (63) CODE -> FUNCTION .

    SEMICOLON       reduce using rule 63 (CODE -> FUNCTION .)


state 90

    (64) CODE -> INTEGER_DECLARATION .

    SEMICOLON       reduce using rule 64 (CODE -> INTEGER_DECLARATION .)


state 91

    (65) CODE -> DECIMAL_DECLARATION .

    SEMICOLON       reduce using rule 65 (CODE -> DECIMAL_DECLARATION .)


state 92

    (66) CODE -> ASSIGNMENT_DECLARATION .

    SEMICOLON       reduce using rule 66 (CODE -> ASSIGNMENT_DECLARATION .)


state 93

    (67) CODE -> COMENTARIOLEX .

    SEMICOLON       reduce using rule 67 (CODE -> COMENTARIOLEX .)


state 94

    (42) CONTROL_STRUCTURES -> IF_STRUCTURE .

    VARNAME         reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INTEGER         reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    $end            reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    RCURL_BRACE     reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    BREAK           reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    CONTINUE        reduce using rule 42 (CONTROL_STRUCTURES -> IF_STRUCTURE .)


state 95

    (43) CONTROL_STRUCTURES -> FOR_STRUCTURE .

    VARNAME         reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INTEGER         reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    $end            reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    RCURL_BRACE     reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    BREAK           reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    CONTINUE        reduce using rule 43 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)


state 96

    (44) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

    VARNAME         reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INTEGER         reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    $end            reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    RCURL_BRACE     reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    BREAK           reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    CONTINUE        reduce using rule 44 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)


state 97

    (45) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

    VARNAME         reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INTEGER         reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    $end            reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    RCURL_BRACE     reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    BREAK           reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    CONTINUE        reduce using rule 45 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)


state 98

    (72) FUNCTION -> VARNAME . LPAREN RPAREN
    (80) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (81) ASSIGNMENT_OPERATOR -> . EQUAL
    (82) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (83) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (84) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (85) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (86) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (87) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (88) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (89) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (90) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (91) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (92) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

    LPAREN          shift and go to state 113
    EQUAL           shift and go to state 49
    PLUS_EQUAL      shift and go to state 50
    MINUS_EQUAL     shift and go to state 51
    DIV_EQUAL       shift and go to state 52
    TIMES_EQUAL     shift and go to state 53
    MOD_EQUAL       shift and go to state 54
    AND_EQUAL       shift and go to state 55
    OR_EQUAL        shift and go to state 56
    XOR_EQUAL       shift and go to state 57
    COMPLEMENT_EQUAL shift and go to state 58
    SHIFTL_EQUAL    shift and go to state 59
    SHIFTR_EQUAL    shift and go to state 60

    ASSIGNMENT_OPERATOR            shift and go to state 114

state 99

    (78) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    VARNAME         shift and go to state 102


state 100

    (58) FOR_STRUCTURE -> INTEGER .

    VARNAME         reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    COMMENT         reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    IF              reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    INTEGER         reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    WHILE           reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    SWITCH          reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    INT             reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    SHORT           reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    LONG            reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    FLOAT           reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    DOUBLE          reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    $end            reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    RCURL_BRACE     reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    BREAK           reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)
    CONTINUE        reduce using rule 58 (FOR_STRUCTURE -> INTEGER .)


state 101

    (79) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    VARNAME         shift and go to state 103


state 102

    (78) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME . EQUAL INTEGER

    EQUAL           shift and go to state 125


state 103

    (79) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME . EQUAL DECIMAL

    EQUAL           shift and go to state 126


state 104

    (56) BUCLE -> VARIABLELEX INCREASE .

    $end            reduce using rule 56 (BUCLE -> VARIABLELEX INCREASE .)


state 105

    (102) OPERATIONS -> OPERATION OPERATOR . OPERATIONS
    (101) OPERATIONS -> . OPERATION
    (102) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (100) OPERATION -> . NUMBER OPERATOR NUMBER
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 123
    DECIMAL         shift and go to state 39

    OPERATION                      shift and go to state 127
    OPERATIONS                     shift and go to state 128
    NUMBER                         shift and go to state 129

state 106

    (111) COMPARISONS -> COMPARISON LOGICAL_OPERATOR . COMPARISONS
    (110) COMPARISONS -> . COMPARISON
    (111) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (109) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (38) VALUE -> . NUMBER
    (39) VALUE -> . STRING
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL

    STRING          shift and go to state 37
    INTEGER         shift and go to state 123
    DECIMAL         shift and go to state 39

    COMPARISON                     shift and go to state 130
    COMPARISONS                    shift and go to state 131
    VALUE                          shift and go to state 132
    NUMBER                         shift and go to state 122

state 107

    (36) DEFINE -> PP_DEFINE VARIABLELEX . VALUE
    (38) VALUE -> . NUMBER
    (39) VALUE -> . STRING
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL

    STRING          shift and go to state 37
    INTEGER         shift and go to state 123
    DECIMAL         shift and go to state 39

    VALUE                          shift and go to state 133
    NUMBER                         shift and go to state 122

state 108

    (94) VARIABLELEX -> VARNAME .

    STRING          reduce using rule 94 (VARIABLELEX -> VARNAME .)
    INTEGER         reduce using rule 94 (VARIABLELEX -> VARNAME .)
    DECIMAL         reduce using rule 94 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 94 (VARIABLELEX -> VARNAME .)


state 109

    (37) INCLUDE -> PP_INCLUDE HEADER_LIB .

    $end            reduce using rule 37 (INCLUDE -> PP_INCLUDE HEADER_LIB .)


state 110

    (49) WHILE_STRUCTURE -> WHILE LPAREN . COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (110) COMPARISONS -> . COMPARISON
    (111) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (109) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (38) VALUE -> . NUMBER
    (39) VALUE -> . STRING
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL

    STRING          shift and go to state 37
    INTEGER         shift and go to state 123
    DECIMAL         shift and go to state 39

    COMPARISONS                    shift and go to state 134
    COMPARISON                     shift and go to state 130
    VALUE                          shift and go to state 132
    NUMBER                         shift and go to state 122

state 111

    (55) SWITCH_STRUCTURE -> SWITCH LPAREN . COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (110) COMPARISONS -> . COMPARISON
    (111) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (109) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (38) VALUE -> . NUMBER
    (39) VALUE -> . STRING
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL

    STRING          shift and go to state 37
    INTEGER         shift and go to state 123
    DECIMAL         shift and go to state 39

    COMPARISONS                    shift and go to state 135
    COMPARISON                     shift and go to state 130
    VALUE                          shift and go to state 132
    NUMBER                         shift and go to state 122

state 112

    (59) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (110) COMPARISONS -> . COMPARISON
    (111) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (109) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (38) VALUE -> . NUMBER
    (39) VALUE -> . STRING
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL

    STRING          shift and go to state 37
    INTEGER         shift and go to state 123
    DECIMAL         shift and go to state 39

    COMPARISONS                    shift and go to state 136
    COMPARISON                     shift and go to state 130
    VALUE                          shift and go to state 132
    NUMBER                         shift and go to state 122

state 113

    (72) FUNCTION -> VARNAME LPAREN . RPAREN

    RPAREN          shift and go to state 137


state 114

    (80) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR . SENTENCE
    (115) SENTENCE -> . NUMBER
    (116) SENTENCE -> . VARNAME
    (40) NUMBER -> . INTEGER
    (41) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 138
    INTEGER         shift and go to state 123
    DECIMAL         shift and go to state 39

    SENTENCE                       shift and go to state 139
    NUMBER                         shift and go to state 140

state 115

    (54) SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .

    $end            reduce using rule 54 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)
    RCURL_BRACE     reduce using rule 54 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)


state 116

    (57) BUCLE -> DECREASE VARIABLELEX .

    $end            reduce using rule 57 (BUCLE -> DECREASE VARIABLELEX .)


state 117

    (61) ELSE_STRUCTURE -> ELSE LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (70) EXPRESSIONS -> . EXPRESSION
    (71) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (68) EXPRESSION -> . CODE SEMICOLON
    (69) EXPRESSION -> . CONTROL_STRUCTURES
    (63) CODE -> . FUNCTION
    (64) CODE -> . INTEGER_DECLARATION
    (65) CODE -> . DECIMAL_DECLARATION
    (66) CODE -> . ASSIGNMENT_DECLARATION
    (67) CODE -> . COMENTARIOLEX
    (42) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (43) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (44) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (45) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (72) FUNCTION -> . VARNAME LPAREN RPAREN
    (78) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (79) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (80) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (93) COMENTARIOLEX -> . COMMENT
    (59) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (58) FOR_STRUCTURE -> . INTEGER
    (49) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (55) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (73) INTEGER_TYPE -> . INT
    (74) INTEGER_TYPE -> . SHORT
    (75) INTEGER_TYPE -> . LONG
    (76) DECIMAL_TYPE -> . FLOAT
    (77) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 98
    COMMENT         shift and go to state 61
    IF              shift and go to state 42
    INTEGER         shift and go to state 100
    WHILE           shift and go to state 40
    SWITCH          shift and go to state 41
    INT             shift and go to state 44
    SHORT           shift and go to state 45
    LONG            shift and go to state 46
    FLOAT           shift and go to state 47
    DOUBLE          shift and go to state 48

    EXPRESSIONS                    shift and go to state 141
    EXPRESSION                     shift and go to state 85
    CODE                           shift and go to state 87
    CONTROL_STRUCTURES             shift and go to state 88
    FUNCTION                       shift and go to state 89
    INTEGER_DECLARATION            shift and go to state 90
    DECIMAL_DECLARATION            shift and go to state 91
    ASSIGNMENT_DECLARATION         shift and go to state 92
    COMENTARIOLEX                  shift and go to state 93
    IF_STRUCTURE                   shift and go to state 94
    FOR_STRUCTURE                  shift and go to state 95
    WHILE_STRUCTURE                shift and go to state 96
    SWITCH_STRUCTURE               shift and go to state 97
    INTEGER_TYPE                   shift and go to state 99
    DECIMAL_TYPE                   shift and go to state 101

state 118

    (62) ELSE_STRUCTURE -> ELSE IF_STRUCTURE .

    $end            reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    VARNAME         reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    COMMENT         reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    IF              reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    INTEGER         reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    WHILE           reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    SWITCH          reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    INT             reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    SHORT           reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    LONG            reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    FLOAT           reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    DOUBLE          reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    RCURL_BRACE     reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    BREAK           reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)
    CONTINUE        reduce using rule 62 (ELSE_STRUCTURE -> ELSE IF_STRUCTURE .)


state 119

    (50) SWITCH_CASE -> CASE INTEGER . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 142


state 120

    (51) SWITCH_DEFAULT -> DEFAULT COLON . EXPRESSIONS BREAK SEMICOLON
    (70) EXPRESSIONS -> . EXPRESSION
    (71) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (68) EXPRESSION -> . CODE SEMICOLON
    (69) EXPRESSION -> . CONTROL_STRUCTURES
    (63) CODE -> . FUNCTION
    (64) CODE -> . INTEGER_DECLARATION
    (65) CODE -> . DECIMAL_DECLARATION
    (66) CODE -> . ASSIGNMENT_DECLARATION
    (67) CODE -> . COMENTARIOLEX
    (42) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (43) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (44) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (45) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (72) FUNCTION -> . VARNAME LPAREN RPAREN
    (78) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (79) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (80) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (93) COMENTARIOLEX -> . COMMENT
    (59) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (58) FOR_STRUCTURE -> . INTEGER
    (49) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (55) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (73) INTEGER_TYPE -> . INT
    (74) INTEGER_TYPE -> . SHORT
    (75) INTEGER_TYPE -> . LONG
    (76) DECIMAL_TYPE -> . FLOAT
    (77) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 98
    COMMENT         shift and go to state 61
    IF              shift and go to state 42
    INTEGER         shift and go to state 100
    WHILE           shift and go to state 40
    SWITCH          shift and go to state 41
    INT             shift and go to state 44
    SHORT           shift and go to state 45
    LONG            shift and go to state 46
    FLOAT           shift and go to state 47
    DOUBLE          shift and go to state 48

    EXPRESSIONS                    shift and go to state 143
    EXPRESSION                     shift and go to state 85
    CODE                           shift and go to state 87
    CONTROL_STRUCTURES             shift and go to state 88
    FUNCTION                       shift and go to state 89
    INTEGER_DECLARATION            shift and go to state 90
    DECIMAL_DECLARATION            shift and go to state 91
    ASSIGNMENT_DECLARATION         shift and go to state 92
    COMENTARIOLEX                  shift and go to state 93
    IF_STRUCTURE                   shift and go to state 94
    FOR_STRUCTURE                  shift and go to state 95
    WHILE_STRUCTURE                shift and go to state 96
    SWITCH_STRUCTURE               shift and go to state 97
    INTEGER_TYPE                   shift and go to state 99
    DECIMAL_TYPE                   shift and go to state 101

state 121

    (109) COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .

    AND             reduce using rule 109 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    OR              reduce using rule 109 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    NOT             reduce using rule 109 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    $end            reduce using rule 109 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    RPAREN          reduce using rule 109 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)


state 122

    (38) VALUE -> NUMBER .

    AND             reduce using rule 38 (VALUE -> NUMBER .)
    OR              reduce using rule 38 (VALUE -> NUMBER .)
    NOT             reduce using rule 38 (VALUE -> NUMBER .)
    $end            reduce using rule 38 (VALUE -> NUMBER .)
    RPAREN          reduce using rule 38 (VALUE -> NUMBER .)
    EQUAL_TO        reduce using rule 38 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 38 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 38 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 38 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 38 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 38 (VALUE -> NUMBER .)


state 123

    (40) NUMBER -> INTEGER .

    AND             reduce using rule 40 (NUMBER -> INTEGER .)
    OR              reduce using rule 40 (NUMBER -> INTEGER .)
    NOT             reduce using rule 40 (NUMBER -> INTEGER .)
    $end            reduce using rule 40 (NUMBER -> INTEGER .)
    RPAREN          reduce using rule 40 (NUMBER -> INTEGER .)
    PLUS            reduce using rule 40 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 40 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 40 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 40 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 40 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 40 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 40 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 40 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 40 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 40 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 40 (NUMBER -> INTEGER .)
    SEMICOLON       reduce using rule 40 (NUMBER -> INTEGER .)


state 124

    (100) OPERATION -> NUMBER OPERATOR NUMBER .

    PLUS            reduce using rule 100 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MINUS           reduce using rule 100 (OPERATION -> NUMBER OPERATOR NUMBER .)
    TIMES           reduce using rule 100 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MODULUS         reduce using rule 100 (OPERATION -> NUMBER OPERATOR NUMBER .)
    DIVIDE          reduce using rule 100 (OPERATION -> NUMBER OPERATOR NUMBER .)
    $end            reduce using rule 100 (OPERATION -> NUMBER OPERATOR NUMBER .)


state 125

    (78) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL . INTEGER

    INTEGER         shift and go to state 144


state 126

    (79) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL . DECIMAL

    DECIMAL         shift and go to state 145


state 127

    (101) OPERATIONS -> OPERATION .
    (102) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (95) OPERATOR -> . PLUS
    (96) OPERATOR -> . MINUS
    (97) OPERATOR -> . TIMES
    (98) OPERATOR -> . MODULUS
    (99) OPERATOR -> . DIVIDE

    $end            reduce using rule 101 (OPERATIONS -> OPERATION .)
    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    MODULUS         shift and go to state 65
    DIVIDE          shift and go to state 66

    OPERATOR                       shift and go to state 105

state 128

    (102) OPERATIONS -> OPERATION OPERATOR OPERATIONS .

    $end            reduce using rule 102 (OPERATIONS -> OPERATION OPERATOR OPERATIONS .)


state 129

    (100) OPERATION -> NUMBER . OPERATOR NUMBER
    (95) OPERATOR -> . PLUS
    (96) OPERATOR -> . MINUS
    (97) OPERATOR -> . TIMES
    (98) OPERATOR -> . MODULUS
    (99) OPERATOR -> . DIVIDE

    PLUS            shift and go to state 62
    MINUS           shift and go to state 63
    TIMES           shift and go to state 64
    MODULUS         shift and go to state 65
    DIVIDE          shift and go to state 66

    OPERATOR                       shift and go to state 83

state 130

    (110) COMPARISONS -> COMPARISON .
    (111) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (112) LOGICAL_OPERATOR -> . AND
    (113) LOGICAL_OPERATOR -> . OR
    (114) LOGICAL_OPERATOR -> . NOT

    $end            reduce using rule 110 (COMPARISONS -> COMPARISON .)
    RPAREN          reduce using rule 110 (COMPARISONS -> COMPARISON .)
    AND             shift and go to state 73
    OR              shift and go to state 74
    NOT             shift and go to state 75

    LOGICAL_OPERATOR               shift and go to state 106

state 131

    (111) COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .

    $end            reduce using rule 111 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)
    RPAREN          reduce using rule 111 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)


state 132

    (109) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (103) COMPARISON_OPERATOR -> . EQUAL_TO
    (104) COMPARISON_OPERATOR -> . NOT_EQUAL
    (105) COMPARISON_OPERATOR -> . GREATER_THAN
    (106) COMPARISON_OPERATOR -> . LESS_THAN
    (107) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (108) COMPARISON_OPERATOR -> . LESS_EQUAL

    EQUAL_TO        shift and go to state 67
    NOT_EQUAL       shift and go to state 68
    GREATER_THAN    shift and go to state 69
    LESS_THAN       shift and go to state 70
    GREATER_EQUAL   shift and go to state 71
    LESS_EQUAL      shift and go to state 72

    COMPARISON_OPERATOR            shift and go to state 82

state 133

    (36) DEFINE -> PP_DEFINE VARIABLELEX VALUE .

    $end            reduce using rule 36 (DEFINE -> PP_DEFINE VARIABLELEX VALUE .)


state 134

    (49) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS . RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    RPAREN          shift and go to state 146


state 135

    (55) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS . RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    RPAREN          shift and go to state 147


state 136

    (59) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    RPAREN          shift and go to state 148


state 137

    (72) FUNCTION -> VARNAME LPAREN RPAREN .

    $end            reduce using rule 72 (FUNCTION -> VARNAME LPAREN RPAREN .)
    SEMICOLON       reduce using rule 72 (FUNCTION -> VARNAME LPAREN RPAREN .)


state 138

    (116) SENTENCE -> VARNAME .

    $end            reduce using rule 116 (SENTENCE -> VARNAME .)
    SEMICOLON       reduce using rule 116 (SENTENCE -> VARNAME .)


state 139

    (80) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .

    $end            reduce using rule 80 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)
    SEMICOLON       reduce using rule 80 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)


state 140

    (115) SENTENCE -> NUMBER .

    $end            reduce using rule 115 (SENTENCE -> NUMBER .)
    SEMICOLON       reduce using rule 115 (SENTENCE -> NUMBER .)


state 141

    (61) ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS . RCURL_BRACE

    RCURL_BRACE     shift and go to state 149


state 142

    (50) SWITCH_CASE -> CASE INTEGER COLON . EXPRESSIONS BREAK SEMICOLON
    (70) EXPRESSIONS -> . EXPRESSION
    (71) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (68) EXPRESSION -> . CODE SEMICOLON
    (69) EXPRESSION -> . CONTROL_STRUCTURES
    (63) CODE -> . FUNCTION
    (64) CODE -> . INTEGER_DECLARATION
    (65) CODE -> . DECIMAL_DECLARATION
    (66) CODE -> . ASSIGNMENT_DECLARATION
    (67) CODE -> . COMENTARIOLEX
    (42) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (43) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (44) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (45) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (72) FUNCTION -> . VARNAME LPAREN RPAREN
    (78) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (79) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (80) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (93) COMENTARIOLEX -> . COMMENT
    (59) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (58) FOR_STRUCTURE -> . INTEGER
    (49) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (55) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (73) INTEGER_TYPE -> . INT
    (74) INTEGER_TYPE -> . SHORT
    (75) INTEGER_TYPE -> . LONG
    (76) DECIMAL_TYPE -> . FLOAT
    (77) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 98
    COMMENT         shift and go to state 61
    IF              shift and go to state 42
    INTEGER         shift and go to state 100
    WHILE           shift and go to state 40
    SWITCH          shift and go to state 41
    INT             shift and go to state 44
    SHORT           shift and go to state 45
    LONG            shift and go to state 46
    FLOAT           shift and go to state 47
    DOUBLE          shift and go to state 48

    EXPRESSIONS                    shift and go to state 150
    EXPRESSION                     shift and go to state 85
    CODE                           shift and go to state 87
    CONTROL_STRUCTURES             shift and go to state 88
    FUNCTION                       shift and go to state 89
    INTEGER_DECLARATION            shift and go to state 90
    DECIMAL_DECLARATION            shift and go to state 91
    ASSIGNMENT_DECLARATION         shift and go to state 92
    COMENTARIOLEX                  shift and go to state 93
    IF_STRUCTURE                   shift and go to state 94
    FOR_STRUCTURE                  shift and go to state 95
    WHILE_STRUCTURE                shift and go to state 96
    SWITCH_STRUCTURE               shift and go to state 97
    INTEGER_TYPE                   shift and go to state 99
    DECIMAL_TYPE                   shift and go to state 101

state 143

    (51) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 151


state 144

    (78) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .

    $end            reduce using rule 78 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)
    SEMICOLON       reduce using rule 78 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)


state 145

    (79) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .

    $end            reduce using rule 79 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)
    SEMICOLON       reduce using rule 79 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)


state 146

    (49) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN . LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LCURL_BRACE     shift and go to state 152


state 147

    (55) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN . LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LCURL_BRACE     shift and go to state 153


state 148

    (59) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE

    LCURL_BRACE     shift and go to state 154


state 149

    (61) ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .

    $end            reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    VARNAME         reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    COMMENT         reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    IF              reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INTEGER         reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    WHILE           reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SWITCH          reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INT             reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SHORT           reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    LONG            reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FLOAT           reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    DOUBLE          reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    BREAK           reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    CONTINUE        reduce using rule 61 (ELSE_STRUCTURE -> ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE .)


state 150

    (50) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 155


state 151

    (51) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 156


state 152

    (49) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE . BODY_STRUCTURE RCURL_BRACE
    (46) BODY_STRUCTURE -> . EXPRESSIONS
    (47) BODY_STRUCTURE -> . EXPRESSIONS BREAK SEMICOLON
    (48) BODY_STRUCTURE -> . EXPRESSIONS CONTINUE SEMICOLON
    (70) EXPRESSIONS -> . EXPRESSION
    (71) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (68) EXPRESSION -> . CODE SEMICOLON
    (69) EXPRESSION -> . CONTROL_STRUCTURES
    (63) CODE -> . FUNCTION
    (64) CODE -> . INTEGER_DECLARATION
    (65) CODE -> . DECIMAL_DECLARATION
    (66) CODE -> . ASSIGNMENT_DECLARATION
    (67) CODE -> . COMENTARIOLEX
    (42) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (43) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (44) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (45) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (72) FUNCTION -> . VARNAME LPAREN RPAREN
    (78) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (79) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (80) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (93) COMENTARIOLEX -> . COMMENT
    (59) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (58) FOR_STRUCTURE -> . INTEGER
    (49) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (55) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (73) INTEGER_TYPE -> . INT
    (74) INTEGER_TYPE -> . SHORT
    (75) INTEGER_TYPE -> . LONG
    (76) DECIMAL_TYPE -> . FLOAT
    (77) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 98
    COMMENT         shift and go to state 61
    IF              shift and go to state 42
    INTEGER         shift and go to state 100
    WHILE           shift and go to state 40
    SWITCH          shift and go to state 41
    INT             shift and go to state 44
    SHORT           shift and go to state 45
    LONG            shift and go to state 46
    FLOAT           shift and go to state 47
    DOUBLE          shift and go to state 48

    BODY_STRUCTURE                 shift and go to state 157
    EXPRESSIONS                    shift and go to state 158
    EXPRESSION                     shift and go to state 85
    CODE                           shift and go to state 87
    CONTROL_STRUCTURES             shift and go to state 88
    FUNCTION                       shift and go to state 89
    INTEGER_DECLARATION            shift and go to state 90
    DECIMAL_DECLARATION            shift and go to state 91
    ASSIGNMENT_DECLARATION         shift and go to state 92
    COMENTARIOLEX                  shift and go to state 93
    IF_STRUCTURE                   shift and go to state 94
    FOR_STRUCTURE                  shift and go to state 95
    WHILE_STRUCTURE                shift and go to state 96
    SWITCH_STRUCTURE               shift and go to state 97
    INTEGER_TYPE                   shift and go to state 99
    DECIMAL_TYPE                   shift and go to state 101

state 153

    (55) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE . SWITCH_BODY RCURL_BRACE
    (52) SWITCH_BODY -> . SWITCH_CASE
    (53) SWITCH_BODY -> . SWITCH_DEFAULT
    (54) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (50) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (51) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    CASE            shift and go to state 80
    DEFAULT         shift and go to state 81

    SWITCH_BODY                    shift and go to state 159
    SWITCH_CASE                    shift and go to state 76
    SWITCH_DEFAULT                 shift and go to state 77

state 154

    (59) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (70) EXPRESSIONS -> . EXPRESSION
    (71) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (68) EXPRESSION -> . CODE SEMICOLON
    (69) EXPRESSION -> . CONTROL_STRUCTURES
    (63) CODE -> . FUNCTION
    (64) CODE -> . INTEGER_DECLARATION
    (65) CODE -> . DECIMAL_DECLARATION
    (66) CODE -> . ASSIGNMENT_DECLARATION
    (67) CODE -> . COMENTARIOLEX
    (42) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (43) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (44) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (45) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (72) FUNCTION -> . VARNAME LPAREN RPAREN
    (78) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (79) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (80) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (93) COMENTARIOLEX -> . COMMENT
    (59) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (60) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE
    (58) FOR_STRUCTURE -> . INTEGER
    (49) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (55) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (73) INTEGER_TYPE -> . INT
    (74) INTEGER_TYPE -> . SHORT
    (75) INTEGER_TYPE -> . LONG
    (76) DECIMAL_TYPE -> . FLOAT
    (77) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 98
    COMMENT         shift and go to state 61
    IF              shift and go to state 42
    INTEGER         shift and go to state 100
    WHILE           shift and go to state 40
    SWITCH          shift and go to state 41
    INT             shift and go to state 44
    SHORT           shift and go to state 45
    LONG            shift and go to state 46
    FLOAT           shift and go to state 47
    DOUBLE          shift and go to state 48

    EXPRESSIONS                    shift and go to state 160
    EXPRESSION                     shift and go to state 85
    CODE                           shift and go to state 87
    CONTROL_STRUCTURES             shift and go to state 88
    FUNCTION                       shift and go to state 89
    INTEGER_DECLARATION            shift and go to state 90
    DECIMAL_DECLARATION            shift and go to state 91
    ASSIGNMENT_DECLARATION         shift and go to state 92
    COMENTARIOLEX                  shift and go to state 93
    IF_STRUCTURE                   shift and go to state 94
    FOR_STRUCTURE                  shift and go to state 95
    WHILE_STRUCTURE                shift and go to state 96
    SWITCH_STRUCTURE               shift and go to state 97
    INTEGER_TYPE                   shift and go to state 99
    DECIMAL_TYPE                   shift and go to state 101

state 155

    (50) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 161


state 156

    (51) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .

    $end            reduce using rule 51 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 51 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)


state 157

    (49) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE . RCURL_BRACE

    RCURL_BRACE     shift and go to state 162


state 158

    (46) BODY_STRUCTURE -> EXPRESSIONS .
    (47) BODY_STRUCTURE -> EXPRESSIONS . BREAK SEMICOLON
    (48) BODY_STRUCTURE -> EXPRESSIONS . CONTINUE SEMICOLON

    RCURL_BRACE     reduce using rule 46 (BODY_STRUCTURE -> EXPRESSIONS .)
    BREAK           shift and go to state 163
    CONTINUE        shift and go to state 164


state 159

    (55) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY . RCURL_BRACE

    RCURL_BRACE     shift and go to state 165


state 160

    (59) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE
    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE ELSE_STRUCTURE

    RCURL_BRACE     shift and go to state 166


state 161

    (50) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .

    CASE            reduce using rule 50 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    DEFAULT         reduce using rule 50 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    $end            reduce using rule 50 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 50 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)


state 162

    (49) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .

    $end            reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    VARNAME         reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    COMMENT         reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    IF              reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    INTEGER         reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    WHILE           reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SWITCH          reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    INT             reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SHORT           reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    LONG            reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    FLOAT           reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    DOUBLE          reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    BREAK           reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    CONTINUE        reduce using rule 49 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)


state 163

    (47) BODY_STRUCTURE -> EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 167


state 164

    (48) BODY_STRUCTURE -> EXPRESSIONS CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 168


state 165

    (55) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .

    $end            reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    VARNAME         reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    COMMENT         reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    IF              reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    INTEGER         reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    WHILE           reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SWITCH          reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    INT             reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SHORT           reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    LONG            reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    FLOAT           reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    DOUBLE          reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    BREAK           reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    CONTINUE        reduce using rule 55 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)


state 166

    (59) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .
    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE . ELSE_STRUCTURE
    (61) ELSE_STRUCTURE -> . ELSE LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (62) ELSE_STRUCTURE -> . ELSE IF_STRUCTURE

    $end            reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    VARNAME         reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    COMMENT         reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    IF              reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INTEGER         reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    WHILE           reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SWITCH          reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INT             reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SHORT           reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    LONG            reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FLOAT           reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    DOUBLE          reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    BREAK           reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    CONTINUE        reduce using rule 59 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    ELSE            shift and go to state 79

    ELSE_STRUCTURE                 shift and go to state 169

state 167

    (47) BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .

    RCURL_BRACE     reduce using rule 47 (BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .)


state 168

    (48) BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .

    RCURL_BRACE     reduce using rule 48 (BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .)


state 169

    (60) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .

    $end            reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    VARNAME         reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    COMMENT         reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    IF              reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    INTEGER         reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    WHILE           reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    SWITCH          reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    INT             reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    SHORT           reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    LONG            reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    FLOAT           reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    DOUBLE          reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    RCURL_BRACE     reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    BREAK           reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)
    CONTINUE        reduce using rule 60 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE ELSE_STRUCTURE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (ROOT -> DEFINE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> DEFINE) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (ROOT -> INCLUDE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> INCLUDE) in state 4
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (VALUE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (SENTENCE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (ROOT -> CONTROL_STRUCTURES)
WARNING: rejected rule (EXPRESSION -> CONTROL_STRUCTURES) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (ROOT -> WHILE_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> WHILE_STRUCTURE) in state 8
WARNING: reduce/reduce conflict in state 9 resolved using rule (ROOT -> SWITCH_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> SWITCH_STRUCTURE) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (ROOT -> IF_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> IF_STRUCTURE) in state 10
WARNING: reduce/reduce conflict in state 11 resolved using rule (ROOT -> FOR_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> FOR_STRUCTURE) in state 11
WARNING: reduce/reduce conflict in state 13 resolved using rule (ROOT -> EXPRESSION)
WARNING: rejected rule (EXPRESSIONS -> EXPRESSION) in state 13
WARNING: reduce/reduce conflict in state 15 resolved using rule (ROOT -> FUNCTION)
WARNING: rejected rule (CODE -> FUNCTION) in state 15
WARNING: reduce/reduce conflict in state 18 resolved using rule (ROOT -> INTEGER_DECLARATION)
WARNING: rejected rule (CODE -> INTEGER_DECLARATION) in state 18
WARNING: reduce/reduce conflict in state 19 resolved using rule (ROOT -> DECIMAL_DECLARATION)
WARNING: rejected rule (CODE -> DECIMAL_DECLARATION) in state 19
WARNING: reduce/reduce conflict in state 20 resolved using rule (ROOT -> ASSIGNMENT_DECLARATION)
WARNING: rejected rule (CODE -> ASSIGNMENT_DECLARATION) in state 20
WARNING: reduce/reduce conflict in state 22 resolved using rule (ROOT -> COMENTARIOLEX)
WARNING: rejected rule (CODE -> COMENTARIOLEX) in state 22
WARNING: reduce/reduce conflict in state 25 resolved using rule (ROOT -> OPERATION)
WARNING: rejected rule (OPERATIONS -> OPERATION) in state 25
WARNING: reduce/reduce conflict in state 28 resolved using rule (ROOT -> COMPARISON)
WARNING: rejected rule (COMPARISONS -> COMPARISON) in state 28
WARNING: reduce/reduce conflict in state 38 resolved using rule (NUMBER -> INTEGER)
WARNING: rejected rule (FOR_STRUCTURE -> INTEGER) in state 38
WARNING: reduce/reduce conflict in state 43 resolved using rule (VARIABLELEX -> VARNAME)
WARNING: rejected rule (SENTENCE -> VARNAME) in state 43
WARNING: Rule (PREPROCESOR_DIRECTIVE -> DEFINE) is never reduced
WARNING: Rule (PREPROCESOR_DIRECTIVE -> INCLUDE) is never reduced
