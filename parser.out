Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AUTO
    BACKSLASH
    BACKSPACE
    BREAK
    B_AND
    B_COMPLEMENT
    B_OR
    B_XOR
    CASE
    CHAR
    CHARACTER
    COLON
    COMMA
    CONST
    CONTINUE
    DEFAULT
    DO
    DOT
    DOUBLE_APOS
    DOUBLE_QUOTE
    ELSE
    ELSEIF
    ENUM
    EXTERN
    FF_PAGEBREAK
    FOR
    FS_CHAR
    FS_DOUBLE
    FS_FLOAT
    FS_HEX
    FS_INT
    FS_LONG
    FS_LONG_DOUBLE
    FS_OCT
    FS_OCT_LONG
    FS_POINTER
    FS_SCI_NOTATION
    FS_STRING
    FS_UNSIGNED_INT
    FS_UNSIGNED_LONG
    GOTO
    HTAB
    IGNORE
    LBRACKET
    NEWLINE
    NULL
    PP_DATE
    PP_DTMACRO
    PP_ERROR
    PP_FILE
    PP_IF
    PP_IFDEF
    PP_IFNDEF
    PP_LINE
    PP_PRAGMA
    PP_STMACRO
    PP_TIME
    PP_TIMESTAMP
    PP_UNDEF
    QUESTIONMARK
    RBRACKET
    REGISTER
    RETURN
    SHIFT_LEFT
    SHIFT_RIGHT
    SIGNED
    SINGLE_APOS
    SINGLE_QUOTE
    SIZEOF
    STATIC
    STRUCT
    SWITCH
    TILDE
    TYPEDEF
    UNION
    UNSIGNED
    VOID
    VOLTILE
    VTAB
    WHILE

Grammar

Rule 0     S' -> ROOT
Rule 1     ROOT -> PREPROCESOR_DIRECTIVE
Rule 2     ROOT -> DEFINE
Rule 3     ROOT -> INCLUDE
Rule 4     ROOT -> VALUE
Rule 5     ROOT -> NUMBER
Rule 6     ROOT -> CONTROL_STRUCTURES
Rule 7     ROOT -> WHILE_STRUCTURE
Rule 8     ROOT -> SWITCH_STRUCTURE
Rule 9     ROOT -> IF_STRUCTURE
Rule 10    ROOT -> FOR_STRUCTURE
Rule 11    ROOT -> CODE
Rule 12    ROOT -> EXPRESSION
Rule 13    ROOT -> EXPRESSIONS
Rule 14    ROOT -> FUNCTION
Rule 15    ROOT -> INTEGER_TYPE
Rule 16    ROOT -> DECIMAL_TYPE
Rule 17    ROOT -> INTEGER_DECLARATION
Rule 18    ROOT -> DECIMAL_DECLARATION
Rule 19    ROOT -> ASSIGNMENT_DECLARATION
Rule 20    ROOT -> ASSIGNMENT_OPERATOR
Rule 21    ROOT -> COMENTARIOLEX
Rule 22    ROOT -> VARIABLELEX
Rule 23    ROOT -> OPERATOR
Rule 24    ROOT -> OPERATION
Rule 25    ROOT -> OPERATIONS
Rule 26    ROOT -> COMPARISON_OPERATOR
Rule 27    ROOT -> COMPARISON
Rule 28    ROOT -> COMPARISONS
Rule 29    ROOT -> LOGICAL_OPERATOR
Rule 30    ROOT -> SENTENCE
Rule 31    PREPROCESOR_DIRECTIVE -> DEFINE
Rule 32    PREPROCESOR_DIRECTIVE -> INCLUDE
Rule 33    DEFINE -> PP_DEFINE VARIABLELEX VALUE
Rule 34    INCLUDE -> PP_INCLUDE HEADER_LIB
Rule 35    VALUE -> NUMBER
Rule 36    VALUE -> STRING
Rule 37    NUMBER -> INTEGER
Rule 38    NUMBER -> DECIMAL
Rule 39    CONTROL_STRUCTURES -> IF_STRUCTURE
Rule 40    CONTROL_STRUCTURES -> FOR_STRUCTURE
Rule 41    CONTROL_STRUCTURES -> WHILE_STRUCTURE
Rule 42    CONTROL_STRUCTURES -> SWITCH_STRUCTURE
Rule 43    WHILE_STRUCTURE -> INTEGER
Rule 44    SWITCH_STRUCTURE -> INTEGER
Rule 45    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 46    FOR_STRUCTURE -> INTEGER
Rule 47    CODE -> FUNCTION
Rule 48    CODE -> CONTROL_STRUCTURES
Rule 49    CODE -> INTEGER_DECLARATION
Rule 50    CODE -> DECIMAL_DECLARATION
Rule 51    CODE -> ASSIGNMENT_DECLARATION
Rule 52    CODE -> COMENTARIOLEX
Rule 53    EXPRESSION -> CODE SEMICOLON
Rule 54    EXPRESSIONS -> EXPRESSION
Rule 55    EXPRESSIONS -> EXPRESSION EXPRESSIONS
Rule 56    FUNCTION -> VARNAME LPAREN RPAREN
Rule 57    INTEGER_TYPE -> INT
Rule 58    INTEGER_TYPE -> SHORT
Rule 59    INTEGER_TYPE -> LONG
Rule 60    DECIMAL_TYPE -> FLOAT
Rule 61    DECIMAL_TYPE -> DOUBLE
Rule 62    INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER
Rule 63    DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL
Rule 64    ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE
Rule 65    ASSIGNMENT_OPERATOR -> EQUAL
Rule 66    ASSIGNMENT_OPERATOR -> PLUS_EQUAL
Rule 67    ASSIGNMENT_OPERATOR -> MINUS_EQUAL
Rule 68    ASSIGNMENT_OPERATOR -> DIV_EQUAL
Rule 69    ASSIGNMENT_OPERATOR -> TIMES_EQUAL
Rule 70    ASSIGNMENT_OPERATOR -> MOD_EQUAL
Rule 71    ASSIGNMENT_OPERATOR -> AND_EQUAL
Rule 72    ASSIGNMENT_OPERATOR -> OR_EQUAL
Rule 73    ASSIGNMENT_OPERATOR -> XOR_EQUAL
Rule 74    ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL
Rule 75    ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL
Rule 76    ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL
Rule 77    COMENTARIOLEX -> COMMENT
Rule 78    VARIABLELEX -> VARNAME
Rule 79    OPERATOR -> PLUS
Rule 80    OPERATOR -> MINUS
Rule 81    OPERATOR -> TIMES
Rule 82    OPERATOR -> MODULUS
Rule 83    OPERATOR -> DIVIDE
Rule 84    OPERATION -> NUMBER OPERATOR NUMBER
Rule 85    OPERATIONS -> OPERATION
Rule 86    OPERATIONS -> OPERATION OPERATOR OPERATIONS
Rule 87    COMPARISON_OPERATOR -> EQUAL_TO
Rule 88    COMPARISON_OPERATOR -> NOT_EQUAL
Rule 89    COMPARISON_OPERATOR -> GREATER_THAN
Rule 90    COMPARISON_OPERATOR -> LESS_THAN
Rule 91    COMPARISON_OPERATOR -> GREATER_EQUAL
Rule 92    COMPARISON_OPERATOR -> LESS_EQUAL
Rule 93    COMPARISON -> VALUE COMPARISON_OPERATOR VALUE
Rule 94    COMPARISONS -> COMPARISON
Rule 95    COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS
Rule 96    LOGICAL_OPERATOR -> AND
Rule 97    LOGICAL_OPERATOR -> OR
Rule 98    LOGICAL_OPERATOR -> NOT
Rule 99    SENTENCE -> NUMBER
Rule 100   SENTENCE -> VARNAME

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 96
AND_EQUAL            : 71
AUTO                 : 
BACKSLASH            : 
BACKSPACE            : 
BREAK                : 
B_AND                : 
B_COMPLEMENT         : 
B_OR                 : 
B_XOR                : 
CASE                 : 
CHAR                 : 
CHARACTER            : 
COLON                : 
COMMA                : 
COMMENT              : 77
COMPLEMENT_EQUAL     : 74
CONST                : 
CONTINUE             : 
DECIMAL              : 38 63
DEFAULT              : 
DIVIDE               : 83
DIV_EQUAL            : 68
DO                   : 
DOT                  : 
DOUBLE               : 61
DOUBLE_APOS          : 
DOUBLE_QUOTE         : 
ELSE                 : 
ELSEIF               : 
ENUM                 : 
EQUAL                : 62 63 65
EQUAL_TO             : 87
EXTERN               : 
FF_PAGEBREAK         : 
FLOAT                : 60
FOR                  : 
FS_CHAR              : 
FS_DOUBLE            : 
FS_FLOAT             : 
FS_HEX               : 
FS_INT               : 
FS_LONG              : 
FS_LONG_DOUBLE       : 
FS_OCT               : 
FS_OCT_LONG          : 
FS_POINTER           : 
FS_SCI_NOTATION      : 
FS_STRING            : 
FS_UNSIGNED_INT      : 
FS_UNSIGNED_LONG     : 
GOTO                 : 
GREATER_EQUAL        : 91
GREATER_THAN         : 89
HEADER_LIB           : 34
HTAB                 : 
IF                   : 45
IGNORE               : 
INT                  : 57
INTEGER              : 37 43 44 46 62
LBRACKET             : 
LCURL_BRACE          : 45
LESS_EQUAL           : 92
LESS_THAN            : 90
LONG                 : 59
LPAREN               : 45 56
MINUS                : 80
MINUS_EQUAL          : 67
MODULUS              : 82
MOD_EQUAL            : 70
NEWLINE              : 
NOT                  : 98
NOT_EQUAL            : 88
NULL                 : 
OR                   : 97
OR_EQUAL             : 72
PLUS                 : 79
PLUS_EQUAL           : 66
PP_DATE              : 
PP_DEFINE            : 33
PP_DTMACRO           : 
PP_ERROR             : 
PP_FILE              : 
PP_IF                : 
PP_IFDEF             : 
PP_IFNDEF            : 
PP_INCLUDE           : 34
PP_LINE              : 
PP_PRAGMA            : 
PP_STMACRO           : 
PP_TIME              : 
PP_TIMESTAMP         : 
PP_UNDEF             : 
QUESTIONMARK         : 
RBRACKET             : 
RCURL_BRACE          : 45
REGISTER             : 
RETURN               : 
RPAREN               : 45 56
SEMICOLON            : 53
SHIFTL_EQUAL         : 75
SHIFTR_EQUAL         : 76
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
SHORT                : 58
SIGNED               : 
SINGLE_APOS          : 
SINGLE_QUOTE         : 
SIZEOF               : 
STATIC               : 
STRING               : 36
STRUCT               : 
SWITCH               : 
TILDE                : 
TIMES                : 81
TIMES_EQUAL          : 69
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VARNAME              : 56 62 63 64 78 100
VOID                 : 
VOLTILE              : 
VTAB                 : 
WHILE                : 
XOR_EQUAL            : 73
error                : 

Nonterminals, with rules where they appear

ASSIGNMENT_DECLARATION : 19 51
ASSIGNMENT_OPERATOR  : 20 64
CODE                 : 11 53
COMENTARIOLEX        : 21 52
COMPARISON           : 27 94 95
COMPARISONS          : 28 45 95
COMPARISON_OPERATOR  : 26 93
CONTROL_STRUCTURES   : 6 48
DECIMAL_DECLARATION  : 18 50
DECIMAL_TYPE         : 16 63
DEFINE               : 2 31
EXPRESSION           : 12 54 55
EXPRESSIONS          : 13 45 55
FOR_STRUCTURE        : 10 40
FUNCTION             : 14 47
IF_STRUCTURE         : 9 39
INCLUDE              : 3 32
INTEGER_DECLARATION  : 17 49
INTEGER_TYPE         : 15 62
LOGICAL_OPERATOR     : 29 95
NUMBER               : 5 35 84 84 99
OPERATION            : 24 85 86
OPERATIONS           : 25 86
OPERATOR             : 23 84 86
PREPROCESOR_DIRECTIVE : 1
ROOT                 : 0
SENTENCE             : 30 64
SWITCH_STRUCTURE     : 8 42
VALUE                : 4 33 93 93
VARIABLELEX          : 22 33
WHILE_STRUCTURE      : 7 41

Parsing method: LALR

state 0

    (0) S' -> . ROOT
    (1) ROOT -> . PREPROCESOR_DIRECTIVE
    (2) ROOT -> . DEFINE
    (3) ROOT -> . INCLUDE
    (4) ROOT -> . VALUE
    (5) ROOT -> . NUMBER
    (6) ROOT -> . CONTROL_STRUCTURES
    (7) ROOT -> . WHILE_STRUCTURE
    (8) ROOT -> . SWITCH_STRUCTURE
    (9) ROOT -> . IF_STRUCTURE
    (10) ROOT -> . FOR_STRUCTURE
    (11) ROOT -> . CODE
    (12) ROOT -> . EXPRESSION
    (13) ROOT -> . EXPRESSIONS
    (14) ROOT -> . FUNCTION
    (15) ROOT -> . INTEGER_TYPE
    (16) ROOT -> . DECIMAL_TYPE
    (17) ROOT -> . INTEGER_DECLARATION
    (18) ROOT -> . DECIMAL_DECLARATION
    (19) ROOT -> . ASSIGNMENT_DECLARATION
    (20) ROOT -> . ASSIGNMENT_OPERATOR
    (21) ROOT -> . COMENTARIOLEX
    (22) ROOT -> . VARIABLELEX
    (23) ROOT -> . OPERATOR
    (24) ROOT -> . OPERATION
    (25) ROOT -> . OPERATIONS
    (26) ROOT -> . COMPARISON_OPERATOR
    (27) ROOT -> . COMPARISON
    (28) ROOT -> . COMPARISONS
    (29) ROOT -> . LOGICAL_OPERATOR
    (30) ROOT -> . SENTENCE
    (31) PREPROCESOR_DIRECTIVE -> . DEFINE
    (32) PREPROCESOR_DIRECTIVE -> . INCLUDE
    (33) DEFINE -> . PP_DEFINE VARIABLELEX VALUE
    (34) INCLUDE -> . PP_INCLUDE HEADER_LIB
    (35) VALUE -> . NUMBER
    (36) VALUE -> . STRING
    (37) NUMBER -> . INTEGER
    (38) NUMBER -> . DECIMAL
    (39) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (40) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (41) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (42) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (43) WHILE_STRUCTURE -> . INTEGER
    (44) SWITCH_STRUCTURE -> . INTEGER
    (45) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (46) FOR_STRUCTURE -> . INTEGER
    (47) CODE -> . FUNCTION
    (48) CODE -> . CONTROL_STRUCTURES
    (49) CODE -> . INTEGER_DECLARATION
    (50) CODE -> . DECIMAL_DECLARATION
    (51) CODE -> . ASSIGNMENT_DECLARATION
    (52) CODE -> . COMENTARIOLEX
    (53) EXPRESSION -> . CODE SEMICOLON
    (54) EXPRESSIONS -> . EXPRESSION
    (55) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (56) FUNCTION -> . VARNAME LPAREN RPAREN
    (57) INTEGER_TYPE -> . INT
    (58) INTEGER_TYPE -> . SHORT
    (59) INTEGER_TYPE -> . LONG
    (60) DECIMAL_TYPE -> . FLOAT
    (61) DECIMAL_TYPE -> . DOUBLE
    (62) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (63) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (64) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (65) ASSIGNMENT_OPERATOR -> . EQUAL
    (66) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (67) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (68) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (69) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (70) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (71) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (72) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (73) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (74) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (75) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (76) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL
    (77) COMENTARIOLEX -> . COMMENT
    (78) VARIABLELEX -> . VARNAME
    (79) OPERATOR -> . PLUS
    (80) OPERATOR -> . MINUS
    (81) OPERATOR -> . TIMES
    (82) OPERATOR -> . MODULUS
    (83) OPERATOR -> . DIVIDE
    (84) OPERATION -> . NUMBER OPERATOR NUMBER
    (85) OPERATIONS -> . OPERATION
    (86) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (87) COMPARISON_OPERATOR -> . EQUAL_TO
    (88) COMPARISON_OPERATOR -> . NOT_EQUAL
    (89) COMPARISON_OPERATOR -> . GREATER_THAN
    (90) COMPARISON_OPERATOR -> . LESS_THAN
    (91) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (92) COMPARISON_OPERATOR -> . LESS_EQUAL
    (93) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (94) COMPARISONS -> . COMPARISON
    (95) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (96) LOGICAL_OPERATOR -> . AND
    (97) LOGICAL_OPERATOR -> . OR
    (98) LOGICAL_OPERATOR -> . NOT
    (99) SENTENCE -> . NUMBER
    (100) SENTENCE -> . VARNAME

    PP_DEFINE       shift and go to state 32
    PP_INCLUDE      shift and go to state 33
    STRING          shift and go to state 34
    INTEGER         shift and go to state 35
    DECIMAL         shift and go to state 36
    IF              shift and go to state 37
    VARNAME         shift and go to state 38
    INT             shift and go to state 39
    SHORT           shift and go to state 40
    LONG            shift and go to state 41
    FLOAT           shift and go to state 42
    DOUBLE          shift and go to state 43
    EQUAL           shift and go to state 44
    PLUS_EQUAL      shift and go to state 45
    MINUS_EQUAL     shift and go to state 46
    DIV_EQUAL       shift and go to state 47
    TIMES_EQUAL     shift and go to state 48
    MOD_EQUAL       shift and go to state 49
    AND_EQUAL       shift and go to state 50
    OR_EQUAL        shift and go to state 51
    XOR_EQUAL       shift and go to state 52
    COMPLEMENT_EQUAL shift and go to state 53
    SHIFTL_EQUAL    shift and go to state 54
    SHIFTR_EQUAL    shift and go to state 55
    COMMENT         shift and go to state 56
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    MODULUS         shift and go to state 60
    DIVIDE          shift and go to state 61
    EQUAL_TO        shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    GREATER_THAN    shift and go to state 64
    LESS_THAN       shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS_EQUAL      shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    NOT             shift and go to state 70

    ROOT                           shift and go to state 1
    PREPROCESOR_DIRECTIVE          shift and go to state 2
    DEFINE                         shift and go to state 3
    INCLUDE                        shift and go to state 4
    VALUE                          shift and go to state 5
    NUMBER                         shift and go to state 6
    CONTROL_STRUCTURES             shift and go to state 7
    WHILE_STRUCTURE                shift and go to state 8
    SWITCH_STRUCTURE               shift and go to state 9
    IF_STRUCTURE                   shift and go to state 10
    FOR_STRUCTURE                  shift and go to state 11
    CODE                           shift and go to state 12
    EXPRESSION                     shift and go to state 13
    EXPRESSIONS                    shift and go to state 14
    FUNCTION                       shift and go to state 15
    INTEGER_TYPE                   shift and go to state 16
    DECIMAL_TYPE                   shift and go to state 17
    INTEGER_DECLARATION            shift and go to state 18
    DECIMAL_DECLARATION            shift and go to state 19
    ASSIGNMENT_DECLARATION         shift and go to state 20
    ASSIGNMENT_OPERATOR            shift and go to state 21
    COMENTARIOLEX                  shift and go to state 22
    VARIABLELEX                    shift and go to state 23
    OPERATOR                       shift and go to state 24
    OPERATION                      shift and go to state 25
    OPERATIONS                     shift and go to state 26
    COMPARISON_OPERATOR            shift and go to state 27
    COMPARISON                     shift and go to state 28
    COMPARISONS                    shift and go to state 29
    LOGICAL_OPERATOR               shift and go to state 30
    SENTENCE                       shift and go to state 31

state 1

    (0) S' -> ROOT .



state 2

    (1) ROOT -> PREPROCESOR_DIRECTIVE .

    $end            reduce using rule 1 (ROOT -> PREPROCESOR_DIRECTIVE .)


state 3

    (2) ROOT -> DEFINE .
    (31) PREPROCESOR_DIRECTIVE -> DEFINE .

  ! reduce/reduce conflict for $end resolved using rule 2 (ROOT -> DEFINE .)
    $end            reduce using rule 2 (ROOT -> DEFINE .)

  ! $end            [ reduce using rule 31 (PREPROCESOR_DIRECTIVE -> DEFINE .) ]


state 4

    (3) ROOT -> INCLUDE .
    (32) PREPROCESOR_DIRECTIVE -> INCLUDE .

  ! reduce/reduce conflict for $end resolved using rule 3 (ROOT -> INCLUDE .)
    $end            reduce using rule 3 (ROOT -> INCLUDE .)

  ! $end            [ reduce using rule 32 (PREPROCESOR_DIRECTIVE -> INCLUDE .) ]


state 5

    (4) ROOT -> VALUE .
    (93) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (87) COMPARISON_OPERATOR -> . EQUAL_TO
    (88) COMPARISON_OPERATOR -> . NOT_EQUAL
    (89) COMPARISON_OPERATOR -> . GREATER_THAN
    (90) COMPARISON_OPERATOR -> . LESS_THAN
    (91) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (92) COMPARISON_OPERATOR -> . LESS_EQUAL

    $end            reduce using rule 4 (ROOT -> VALUE .)
    EQUAL_TO        shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    GREATER_THAN    shift and go to state 64
    LESS_THAN       shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS_EQUAL      shift and go to state 67

    COMPARISON_OPERATOR            shift and go to state 71

state 6

    (5) ROOT -> NUMBER .
    (35) VALUE -> NUMBER .
    (84) OPERATION -> NUMBER . OPERATOR NUMBER
    (99) SENTENCE -> NUMBER .
    (79) OPERATOR -> . PLUS
    (80) OPERATOR -> . MINUS
    (81) OPERATOR -> . TIMES
    (82) OPERATOR -> . MODULUS
    (83) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
    $end            reduce using rule 5 (ROOT -> NUMBER .)
    EQUAL_TO        reduce using rule 35 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 35 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 35 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 35 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 35 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 35 (VALUE -> NUMBER .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    MODULUS         shift and go to state 60
    DIVIDE          shift and go to state 61

  ! $end            [ reduce using rule 35 (VALUE -> NUMBER .) ]
  ! $end            [ reduce using rule 99 (SENTENCE -> NUMBER .) ]

    OPERATOR                       shift and go to state 72

state 7

    (6) ROOT -> CONTROL_STRUCTURES .
    (48) CODE -> CONTROL_STRUCTURES .

  ! reduce/reduce conflict for $end resolved using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    $end            reduce using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    SEMICOLON       reduce using rule 48 (CODE -> CONTROL_STRUCTURES .)

  ! $end            [ reduce using rule 48 (CODE -> CONTROL_STRUCTURES .) ]


state 8

    (7) ROOT -> WHILE_STRUCTURE .
    (41) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 7 (ROOT -> WHILE_STRUCTURE .)
    $end            reduce using rule 7 (ROOT -> WHILE_STRUCTURE .)
    SEMICOLON       reduce using rule 41 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)

  ! $end            [ reduce using rule 41 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .) ]


state 9

    (8) ROOT -> SWITCH_STRUCTURE .
    (42) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    $end            reduce using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    SEMICOLON       reduce using rule 42 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)

  ! $end            [ reduce using rule 42 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .) ]


state 10

    (9) ROOT -> IF_STRUCTURE .
    (39) CONTROL_STRUCTURES -> IF_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 9 (ROOT -> IF_STRUCTURE .)
    $end            reduce using rule 9 (ROOT -> IF_STRUCTURE .)
    SEMICOLON       reduce using rule 39 (CONTROL_STRUCTURES -> IF_STRUCTURE .)

  ! $end            [ reduce using rule 39 (CONTROL_STRUCTURES -> IF_STRUCTURE .) ]


state 11

    (10) ROOT -> FOR_STRUCTURE .
    (40) CONTROL_STRUCTURES -> FOR_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 10 (ROOT -> FOR_STRUCTURE .)
    $end            reduce using rule 10 (ROOT -> FOR_STRUCTURE .)
    SEMICOLON       reduce using rule 40 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)

  ! $end            [ reduce using rule 40 (CONTROL_STRUCTURES -> FOR_STRUCTURE .) ]


state 12

    (11) ROOT -> CODE .
    (53) EXPRESSION -> CODE . SEMICOLON

    $end            reduce using rule 11 (ROOT -> CODE .)
    SEMICOLON       shift and go to state 73


state 13

    (12) ROOT -> EXPRESSION .
    (54) EXPRESSIONS -> EXPRESSION .
    (55) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (54) EXPRESSIONS -> . EXPRESSION
    (55) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (53) EXPRESSION -> . CODE SEMICOLON
    (47) CODE -> . FUNCTION
    (48) CODE -> . CONTROL_STRUCTURES
    (49) CODE -> . INTEGER_DECLARATION
    (50) CODE -> . DECIMAL_DECLARATION
    (51) CODE -> . ASSIGNMENT_DECLARATION
    (52) CODE -> . COMENTARIOLEX
    (56) FUNCTION -> . VARNAME LPAREN RPAREN
    (39) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (40) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (41) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (42) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (62) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (63) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (64) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (77) COMENTARIOLEX -> . COMMENT
    (45) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (46) FOR_STRUCTURE -> . INTEGER
    (43) WHILE_STRUCTURE -> . INTEGER
    (44) SWITCH_STRUCTURE -> . INTEGER
    (57) INTEGER_TYPE -> . INT
    (58) INTEGER_TYPE -> . SHORT
    (59) INTEGER_TYPE -> . LONG
    (60) DECIMAL_TYPE -> . FLOAT
    (61) DECIMAL_TYPE -> . DOUBLE

  ! reduce/reduce conflict for $end resolved using rule 12 (ROOT -> EXPRESSION .)
    $end            reduce using rule 12 (ROOT -> EXPRESSION .)
    VARNAME         shift and go to state 83
    COMMENT         shift and go to state 56
    IF              shift and go to state 37
    INTEGER         shift and go to state 89
    INT             shift and go to state 39
    SHORT           shift and go to state 40
    LONG            shift and go to state 41
    FLOAT           shift and go to state 42
    DOUBLE          shift and go to state 43

  ! $end            [ reduce using rule 54 (EXPRESSIONS -> EXPRESSION .) ]

    EXPRESSION                     shift and go to state 74
    EXPRESSIONS                    shift and go to state 75
    CODE                           shift and go to state 76
    FUNCTION                       shift and go to state 77
    CONTROL_STRUCTURES             shift and go to state 78
    INTEGER_DECLARATION            shift and go to state 79
    DECIMAL_DECLARATION            shift and go to state 80
    ASSIGNMENT_DECLARATION         shift and go to state 81
    COMENTARIOLEX                  shift and go to state 82
    IF_STRUCTURE                   shift and go to state 84
    FOR_STRUCTURE                  shift and go to state 85
    WHILE_STRUCTURE                shift and go to state 86
    SWITCH_STRUCTURE               shift and go to state 87
    INTEGER_TYPE                   shift and go to state 88
    DECIMAL_TYPE                   shift and go to state 90

state 14

    (13) ROOT -> EXPRESSIONS .

    $end            reduce using rule 13 (ROOT -> EXPRESSIONS .)


state 15

    (14) ROOT -> FUNCTION .
    (47) CODE -> FUNCTION .

  ! reduce/reduce conflict for $end resolved using rule 14 (ROOT -> FUNCTION .)
    $end            reduce using rule 14 (ROOT -> FUNCTION .)
    SEMICOLON       reduce using rule 47 (CODE -> FUNCTION .)

  ! $end            [ reduce using rule 47 (CODE -> FUNCTION .) ]


state 16

    (15) ROOT -> INTEGER_TYPE .
    (62) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    $end            reduce using rule 15 (ROOT -> INTEGER_TYPE .)
    VARNAME         shift and go to state 91


state 17

    (16) ROOT -> DECIMAL_TYPE .
    (63) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    $end            reduce using rule 16 (ROOT -> DECIMAL_TYPE .)
    VARNAME         shift and go to state 92


state 18

    (17) ROOT -> INTEGER_DECLARATION .
    (49) CODE -> INTEGER_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 17 (ROOT -> INTEGER_DECLARATION .)
    $end            reduce using rule 17 (ROOT -> INTEGER_DECLARATION .)
    SEMICOLON       reduce using rule 49 (CODE -> INTEGER_DECLARATION .)

  ! $end            [ reduce using rule 49 (CODE -> INTEGER_DECLARATION .) ]


state 19

    (18) ROOT -> DECIMAL_DECLARATION .
    (50) CODE -> DECIMAL_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    $end            reduce using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    SEMICOLON       reduce using rule 50 (CODE -> DECIMAL_DECLARATION .)

  ! $end            [ reduce using rule 50 (CODE -> DECIMAL_DECLARATION .) ]


state 20

    (19) ROOT -> ASSIGNMENT_DECLARATION .
    (51) CODE -> ASSIGNMENT_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    $end            reduce using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    SEMICOLON       reduce using rule 51 (CODE -> ASSIGNMENT_DECLARATION .)

  ! $end            [ reduce using rule 51 (CODE -> ASSIGNMENT_DECLARATION .) ]


state 21

    (20) ROOT -> ASSIGNMENT_OPERATOR .

    $end            reduce using rule 20 (ROOT -> ASSIGNMENT_OPERATOR .)


state 22

    (21) ROOT -> COMENTARIOLEX .
    (52) CODE -> COMENTARIOLEX .

  ! reduce/reduce conflict for $end resolved using rule 21 (ROOT -> COMENTARIOLEX .)
    $end            reduce using rule 21 (ROOT -> COMENTARIOLEX .)
    SEMICOLON       reduce using rule 52 (CODE -> COMENTARIOLEX .)

  ! $end            [ reduce using rule 52 (CODE -> COMENTARIOLEX .) ]


state 23

    (22) ROOT -> VARIABLELEX .

    $end            reduce using rule 22 (ROOT -> VARIABLELEX .)


state 24

    (23) ROOT -> OPERATOR .

    $end            reduce using rule 23 (ROOT -> OPERATOR .)


state 25

    (24) ROOT -> OPERATION .
    (85) OPERATIONS -> OPERATION .
    (86) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (79) OPERATOR -> . PLUS
    (80) OPERATOR -> . MINUS
    (81) OPERATOR -> . TIMES
    (82) OPERATOR -> . MODULUS
    (83) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 24 (ROOT -> OPERATION .)
    $end            reduce using rule 24 (ROOT -> OPERATION .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    MODULUS         shift and go to state 60
    DIVIDE          shift and go to state 61

  ! $end            [ reduce using rule 85 (OPERATIONS -> OPERATION .) ]

    OPERATOR                       shift and go to state 93

state 26

    (25) ROOT -> OPERATIONS .

    $end            reduce using rule 25 (ROOT -> OPERATIONS .)


state 27

    (26) ROOT -> COMPARISON_OPERATOR .

    $end            reduce using rule 26 (ROOT -> COMPARISON_OPERATOR .)


state 28

    (27) ROOT -> COMPARISON .
    (94) COMPARISONS -> COMPARISON .
    (95) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (96) LOGICAL_OPERATOR -> . AND
    (97) LOGICAL_OPERATOR -> . OR
    (98) LOGICAL_OPERATOR -> . NOT

  ! reduce/reduce conflict for $end resolved using rule 27 (ROOT -> COMPARISON .)
    $end            reduce using rule 27 (ROOT -> COMPARISON .)
    AND             shift and go to state 68
    OR              shift and go to state 69
    NOT             shift and go to state 70

  ! $end            [ reduce using rule 94 (COMPARISONS -> COMPARISON .) ]

    LOGICAL_OPERATOR               shift and go to state 94

state 29

    (28) ROOT -> COMPARISONS .

    $end            reduce using rule 28 (ROOT -> COMPARISONS .)


state 30

    (29) ROOT -> LOGICAL_OPERATOR .

    $end            reduce using rule 29 (ROOT -> LOGICAL_OPERATOR .)


state 31

    (30) ROOT -> SENTENCE .

    $end            reduce using rule 30 (ROOT -> SENTENCE .)


state 32

    (33) DEFINE -> PP_DEFINE . VARIABLELEX VALUE
    (78) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 96

    VARIABLELEX                    shift and go to state 95

state 33

    (34) INCLUDE -> PP_INCLUDE . HEADER_LIB

    HEADER_LIB      shift and go to state 97


state 34

    (36) VALUE -> STRING .

    EQUAL_TO        reduce using rule 36 (VALUE -> STRING .)
    NOT_EQUAL       reduce using rule 36 (VALUE -> STRING .)
    GREATER_THAN    reduce using rule 36 (VALUE -> STRING .)
    LESS_THAN       reduce using rule 36 (VALUE -> STRING .)
    GREATER_EQUAL   reduce using rule 36 (VALUE -> STRING .)
    LESS_EQUAL      reduce using rule 36 (VALUE -> STRING .)
    $end            reduce using rule 36 (VALUE -> STRING .)
    AND             reduce using rule 36 (VALUE -> STRING .)
    OR              reduce using rule 36 (VALUE -> STRING .)
    NOT             reduce using rule 36 (VALUE -> STRING .)
    RPAREN          reduce using rule 36 (VALUE -> STRING .)


state 35

    (37) NUMBER -> INTEGER .
    (43) WHILE_STRUCTURE -> INTEGER .
    (44) SWITCH_STRUCTURE -> INTEGER .
    (46) FOR_STRUCTURE -> INTEGER .

  ! reduce/reduce conflict for $end resolved using rule 37 (NUMBER -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 37 (NUMBER -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 43 (WHILE_STRUCTURE -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 37 (NUMBER -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 43 (WHILE_STRUCTURE -> INTEGER .)
    PLUS            reduce using rule 37 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 37 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 37 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 37 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 37 (NUMBER -> INTEGER .)
    $end            reduce using rule 37 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 37 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 37 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 37 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 37 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 37 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 37 (NUMBER -> INTEGER .)
    SEMICOLON       reduce using rule 43 (WHILE_STRUCTURE -> INTEGER .)

  ! $end            [ reduce using rule 43 (WHILE_STRUCTURE -> INTEGER .) ]
  ! $end            [ reduce using rule 44 (SWITCH_STRUCTURE -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 44 (SWITCH_STRUCTURE -> INTEGER .) ]
  ! $end            [ reduce using rule 46 (FOR_STRUCTURE -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 46 (FOR_STRUCTURE -> INTEGER .) ]


state 36

    (38) NUMBER -> DECIMAL .

    PLUS            reduce using rule 38 (NUMBER -> DECIMAL .)
    MINUS           reduce using rule 38 (NUMBER -> DECIMAL .)
    TIMES           reduce using rule 38 (NUMBER -> DECIMAL .)
    MODULUS         reduce using rule 38 (NUMBER -> DECIMAL .)
    DIVIDE          reduce using rule 38 (NUMBER -> DECIMAL .)
    $end            reduce using rule 38 (NUMBER -> DECIMAL .)
    EQUAL_TO        reduce using rule 38 (NUMBER -> DECIMAL .)
    NOT_EQUAL       reduce using rule 38 (NUMBER -> DECIMAL .)
    GREATER_THAN    reduce using rule 38 (NUMBER -> DECIMAL .)
    LESS_THAN       reduce using rule 38 (NUMBER -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 38 (NUMBER -> DECIMAL .)
    LESS_EQUAL      reduce using rule 38 (NUMBER -> DECIMAL .)
    AND             reduce using rule 38 (NUMBER -> DECIMAL .)
    OR              reduce using rule 38 (NUMBER -> DECIMAL .)
    NOT             reduce using rule 38 (NUMBER -> DECIMAL .)
    RPAREN          reduce using rule 38 (NUMBER -> DECIMAL .)
    SEMICOLON       reduce using rule 38 (NUMBER -> DECIMAL .)


state 37

    (45) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE

    LPAREN          shift and go to state 98


state 38

    (56) FUNCTION -> VARNAME . LPAREN RPAREN
    (64) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (78) VARIABLELEX -> VARNAME .
    (100) SENTENCE -> VARNAME .
    (65) ASSIGNMENT_OPERATOR -> . EQUAL
    (66) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (67) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (68) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (69) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (70) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (71) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (72) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (73) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (74) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (75) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (76) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 78 (VARIABLELEX -> VARNAME .)
    LPAREN          shift and go to state 99
    $end            reduce using rule 78 (VARIABLELEX -> VARNAME .)
    EQUAL           shift and go to state 44
    PLUS_EQUAL      shift and go to state 45
    MINUS_EQUAL     shift and go to state 46
    DIV_EQUAL       shift and go to state 47
    TIMES_EQUAL     shift and go to state 48
    MOD_EQUAL       shift and go to state 49
    AND_EQUAL       shift and go to state 50
    OR_EQUAL        shift and go to state 51
    XOR_EQUAL       shift and go to state 52
    COMPLEMENT_EQUAL shift and go to state 53
    SHIFTL_EQUAL    shift and go to state 54
    SHIFTR_EQUAL    shift and go to state 55

  ! $end            [ reduce using rule 100 (SENTENCE -> VARNAME .) ]

    ASSIGNMENT_OPERATOR            shift and go to state 100

state 39

    (57) INTEGER_TYPE -> INT .

    VARNAME         reduce using rule 57 (INTEGER_TYPE -> INT .)
    $end            reduce using rule 57 (INTEGER_TYPE -> INT .)


state 40

    (58) INTEGER_TYPE -> SHORT .

    VARNAME         reduce using rule 58 (INTEGER_TYPE -> SHORT .)
    $end            reduce using rule 58 (INTEGER_TYPE -> SHORT .)


state 41

    (59) INTEGER_TYPE -> LONG .

    VARNAME         reduce using rule 59 (INTEGER_TYPE -> LONG .)
    $end            reduce using rule 59 (INTEGER_TYPE -> LONG .)


state 42

    (60) DECIMAL_TYPE -> FLOAT .

    VARNAME         reduce using rule 60 (DECIMAL_TYPE -> FLOAT .)
    $end            reduce using rule 60 (DECIMAL_TYPE -> FLOAT .)


state 43

    (61) DECIMAL_TYPE -> DOUBLE .

    VARNAME         reduce using rule 61 (DECIMAL_TYPE -> DOUBLE .)
    $end            reduce using rule 61 (DECIMAL_TYPE -> DOUBLE .)


state 44

    (65) ASSIGNMENT_OPERATOR -> EQUAL .

    $end            reduce using rule 65 (ASSIGNMENT_OPERATOR -> EQUAL .)
    VARNAME         reduce using rule 65 (ASSIGNMENT_OPERATOR -> EQUAL .)
    INTEGER         reduce using rule 65 (ASSIGNMENT_OPERATOR -> EQUAL .)
    DECIMAL         reduce using rule 65 (ASSIGNMENT_OPERATOR -> EQUAL .)


state 45

    (66) ASSIGNMENT_OPERATOR -> PLUS_EQUAL .

    $end            reduce using rule 66 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    VARNAME         reduce using rule 66 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    INTEGER         reduce using rule 66 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    DECIMAL         reduce using rule 66 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)


state 46

    (67) ASSIGNMENT_OPERATOR -> MINUS_EQUAL .

    $end            reduce using rule 67 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    VARNAME         reduce using rule 67 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    INTEGER         reduce using rule 67 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    DECIMAL         reduce using rule 67 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)


state 47

    (68) ASSIGNMENT_OPERATOR -> DIV_EQUAL .

    $end            reduce using rule 68 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    VARNAME         reduce using rule 68 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    INTEGER         reduce using rule 68 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    DECIMAL         reduce using rule 68 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)


state 48

    (69) ASSIGNMENT_OPERATOR -> TIMES_EQUAL .

    $end            reduce using rule 69 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    VARNAME         reduce using rule 69 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    INTEGER         reduce using rule 69 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    DECIMAL         reduce using rule 69 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)


state 49

    (70) ASSIGNMENT_OPERATOR -> MOD_EQUAL .

    $end            reduce using rule 70 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    VARNAME         reduce using rule 70 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    INTEGER         reduce using rule 70 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    DECIMAL         reduce using rule 70 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)


state 50

    (71) ASSIGNMENT_OPERATOR -> AND_EQUAL .

    $end            reduce using rule 71 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    VARNAME         reduce using rule 71 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    INTEGER         reduce using rule 71 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    DECIMAL         reduce using rule 71 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)


state 51

    (72) ASSIGNMENT_OPERATOR -> OR_EQUAL .

    $end            reduce using rule 72 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    VARNAME         reduce using rule 72 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    INTEGER         reduce using rule 72 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    DECIMAL         reduce using rule 72 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)


state 52

    (73) ASSIGNMENT_OPERATOR -> XOR_EQUAL .

    $end            reduce using rule 73 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    VARNAME         reduce using rule 73 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    INTEGER         reduce using rule 73 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    DECIMAL         reduce using rule 73 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)


state 53

    (74) ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .

    $end            reduce using rule 74 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    VARNAME         reduce using rule 74 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    INTEGER         reduce using rule 74 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    DECIMAL         reduce using rule 74 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)


state 54

    (75) ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .

    $end            reduce using rule 75 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    VARNAME         reduce using rule 75 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    INTEGER         reduce using rule 75 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    DECIMAL         reduce using rule 75 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)


state 55

    (76) ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .

    $end            reduce using rule 76 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    VARNAME         reduce using rule 76 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    INTEGER         reduce using rule 76 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    DECIMAL         reduce using rule 76 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)


state 56

    (77) COMENTARIOLEX -> COMMENT .

    $end            reduce using rule 77 (COMENTARIOLEX -> COMMENT .)
    SEMICOLON       reduce using rule 77 (COMENTARIOLEX -> COMMENT .)


state 57

    (79) OPERATOR -> PLUS .

    $end            reduce using rule 79 (OPERATOR -> PLUS .)
    INTEGER         reduce using rule 79 (OPERATOR -> PLUS .)
    DECIMAL         reduce using rule 79 (OPERATOR -> PLUS .)


state 58

    (80) OPERATOR -> MINUS .

    $end            reduce using rule 80 (OPERATOR -> MINUS .)
    INTEGER         reduce using rule 80 (OPERATOR -> MINUS .)
    DECIMAL         reduce using rule 80 (OPERATOR -> MINUS .)


state 59

    (81) OPERATOR -> TIMES .

    $end            reduce using rule 81 (OPERATOR -> TIMES .)
    INTEGER         reduce using rule 81 (OPERATOR -> TIMES .)
    DECIMAL         reduce using rule 81 (OPERATOR -> TIMES .)


state 60

    (82) OPERATOR -> MODULUS .

    $end            reduce using rule 82 (OPERATOR -> MODULUS .)
    INTEGER         reduce using rule 82 (OPERATOR -> MODULUS .)
    DECIMAL         reduce using rule 82 (OPERATOR -> MODULUS .)


state 61

    (83) OPERATOR -> DIVIDE .

    $end            reduce using rule 83 (OPERATOR -> DIVIDE .)
    INTEGER         reduce using rule 83 (OPERATOR -> DIVIDE .)
    DECIMAL         reduce using rule 83 (OPERATOR -> DIVIDE .)


state 62

    (87) COMPARISON_OPERATOR -> EQUAL_TO .

    $end            reduce using rule 87 (COMPARISON_OPERATOR -> EQUAL_TO .)
    STRING          reduce using rule 87 (COMPARISON_OPERATOR -> EQUAL_TO .)
    INTEGER         reduce using rule 87 (COMPARISON_OPERATOR -> EQUAL_TO .)
    DECIMAL         reduce using rule 87 (COMPARISON_OPERATOR -> EQUAL_TO .)


state 63

    (88) COMPARISON_OPERATOR -> NOT_EQUAL .

    $end            reduce using rule 88 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    STRING          reduce using rule 88 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    INTEGER         reduce using rule 88 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    DECIMAL         reduce using rule 88 (COMPARISON_OPERATOR -> NOT_EQUAL .)


state 64

    (89) COMPARISON_OPERATOR -> GREATER_THAN .

    $end            reduce using rule 89 (COMPARISON_OPERATOR -> GREATER_THAN .)
    STRING          reduce using rule 89 (COMPARISON_OPERATOR -> GREATER_THAN .)
    INTEGER         reduce using rule 89 (COMPARISON_OPERATOR -> GREATER_THAN .)
    DECIMAL         reduce using rule 89 (COMPARISON_OPERATOR -> GREATER_THAN .)


state 65

    (90) COMPARISON_OPERATOR -> LESS_THAN .

    $end            reduce using rule 90 (COMPARISON_OPERATOR -> LESS_THAN .)
    STRING          reduce using rule 90 (COMPARISON_OPERATOR -> LESS_THAN .)
    INTEGER         reduce using rule 90 (COMPARISON_OPERATOR -> LESS_THAN .)
    DECIMAL         reduce using rule 90 (COMPARISON_OPERATOR -> LESS_THAN .)


state 66

    (91) COMPARISON_OPERATOR -> GREATER_EQUAL .

    $end            reduce using rule 91 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    STRING          reduce using rule 91 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    INTEGER         reduce using rule 91 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    DECIMAL         reduce using rule 91 (COMPARISON_OPERATOR -> GREATER_EQUAL .)


state 67

    (92) COMPARISON_OPERATOR -> LESS_EQUAL .

    $end            reduce using rule 92 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    STRING          reduce using rule 92 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    INTEGER         reduce using rule 92 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    DECIMAL         reduce using rule 92 (COMPARISON_OPERATOR -> LESS_EQUAL .)


state 68

    (96) LOGICAL_OPERATOR -> AND .

    $end            reduce using rule 96 (LOGICAL_OPERATOR -> AND .)
    STRING          reduce using rule 96 (LOGICAL_OPERATOR -> AND .)
    INTEGER         reduce using rule 96 (LOGICAL_OPERATOR -> AND .)
    DECIMAL         reduce using rule 96 (LOGICAL_OPERATOR -> AND .)


state 69

    (97) LOGICAL_OPERATOR -> OR .

    $end            reduce using rule 97 (LOGICAL_OPERATOR -> OR .)
    STRING          reduce using rule 97 (LOGICAL_OPERATOR -> OR .)
    INTEGER         reduce using rule 97 (LOGICAL_OPERATOR -> OR .)
    DECIMAL         reduce using rule 97 (LOGICAL_OPERATOR -> OR .)


state 70

    (98) LOGICAL_OPERATOR -> NOT .

    $end            reduce using rule 98 (LOGICAL_OPERATOR -> NOT .)
    STRING          reduce using rule 98 (LOGICAL_OPERATOR -> NOT .)
    INTEGER         reduce using rule 98 (LOGICAL_OPERATOR -> NOT .)
    DECIMAL         reduce using rule 98 (LOGICAL_OPERATOR -> NOT .)


state 71

    (93) COMPARISON -> VALUE COMPARISON_OPERATOR . VALUE
    (35) VALUE -> . NUMBER
    (36) VALUE -> . STRING
    (37) NUMBER -> . INTEGER
    (38) NUMBER -> . DECIMAL

    STRING          shift and go to state 34
    INTEGER         shift and go to state 103
    DECIMAL         shift and go to state 36

    VALUE                          shift and go to state 101
    NUMBER                         shift and go to state 102

state 72

    (84) OPERATION -> NUMBER OPERATOR . NUMBER
    (37) NUMBER -> . INTEGER
    (38) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 103
    DECIMAL         shift and go to state 36

    NUMBER                         shift and go to state 104

state 73

    (53) EXPRESSION -> CODE SEMICOLON .

    VARNAME         reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    COMMENT         reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    IF              reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    INTEGER         reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    INT             reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    SHORT           reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    LONG            reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    FLOAT           reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    DOUBLE          reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    $end            reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)
    RCURL_BRACE     reduce using rule 53 (EXPRESSION -> CODE SEMICOLON .)


state 74

    (54) EXPRESSIONS -> EXPRESSION .
    (55) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (54) EXPRESSIONS -> . EXPRESSION
    (55) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (53) EXPRESSION -> . CODE SEMICOLON
    (47) CODE -> . FUNCTION
    (48) CODE -> . CONTROL_STRUCTURES
    (49) CODE -> . INTEGER_DECLARATION
    (50) CODE -> . DECIMAL_DECLARATION
    (51) CODE -> . ASSIGNMENT_DECLARATION
    (52) CODE -> . COMENTARIOLEX
    (56) FUNCTION -> . VARNAME LPAREN RPAREN
    (39) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (40) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (41) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (42) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (62) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (63) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (64) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (77) COMENTARIOLEX -> . COMMENT
    (45) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (46) FOR_STRUCTURE -> . INTEGER
    (43) WHILE_STRUCTURE -> . INTEGER
    (44) SWITCH_STRUCTURE -> . INTEGER
    (57) INTEGER_TYPE -> . INT
    (58) INTEGER_TYPE -> . SHORT
    (59) INTEGER_TYPE -> . LONG
    (60) DECIMAL_TYPE -> . FLOAT
    (61) DECIMAL_TYPE -> . DOUBLE

    $end            reduce using rule 54 (EXPRESSIONS -> EXPRESSION .)
    RCURL_BRACE     reduce using rule 54 (EXPRESSIONS -> EXPRESSION .)
    VARNAME         shift and go to state 83
    COMMENT         shift and go to state 56
    IF              shift and go to state 37
    INTEGER         shift and go to state 89
    INT             shift and go to state 39
    SHORT           shift and go to state 40
    LONG            shift and go to state 41
    FLOAT           shift and go to state 42
    DOUBLE          shift and go to state 43

    EXPRESSION                     shift and go to state 74
    EXPRESSIONS                    shift and go to state 75
    CODE                           shift and go to state 76
    FUNCTION                       shift and go to state 77
    CONTROL_STRUCTURES             shift and go to state 78
    INTEGER_DECLARATION            shift and go to state 79
    DECIMAL_DECLARATION            shift and go to state 80
    ASSIGNMENT_DECLARATION         shift and go to state 81
    COMENTARIOLEX                  shift and go to state 82
    IF_STRUCTURE                   shift and go to state 84
    FOR_STRUCTURE                  shift and go to state 85
    WHILE_STRUCTURE                shift and go to state 86
    SWITCH_STRUCTURE               shift and go to state 87
    INTEGER_TYPE                   shift and go to state 88
    DECIMAL_TYPE                   shift and go to state 90

state 75

    (55) EXPRESSIONS -> EXPRESSION EXPRESSIONS .

    $end            reduce using rule 55 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    RCURL_BRACE     reduce using rule 55 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)


state 76

    (53) EXPRESSION -> CODE . SEMICOLON

    SEMICOLON       shift and go to state 73


state 77

    (47) CODE -> FUNCTION .

    SEMICOLON       reduce using rule 47 (CODE -> FUNCTION .)


state 78

    (48) CODE -> CONTROL_STRUCTURES .

    SEMICOLON       reduce using rule 48 (CODE -> CONTROL_STRUCTURES .)


state 79

    (49) CODE -> INTEGER_DECLARATION .

    SEMICOLON       reduce using rule 49 (CODE -> INTEGER_DECLARATION .)


state 80

    (50) CODE -> DECIMAL_DECLARATION .

    SEMICOLON       reduce using rule 50 (CODE -> DECIMAL_DECLARATION .)


state 81

    (51) CODE -> ASSIGNMENT_DECLARATION .

    SEMICOLON       reduce using rule 51 (CODE -> ASSIGNMENT_DECLARATION .)


state 82

    (52) CODE -> COMENTARIOLEX .

    SEMICOLON       reduce using rule 52 (CODE -> COMENTARIOLEX .)


state 83

    (56) FUNCTION -> VARNAME . LPAREN RPAREN
    (64) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (65) ASSIGNMENT_OPERATOR -> . EQUAL
    (66) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (67) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (68) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (69) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (70) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (71) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (72) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (73) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (74) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (75) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (76) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

    LPAREN          shift and go to state 99
    EQUAL           shift and go to state 44
    PLUS_EQUAL      shift and go to state 45
    MINUS_EQUAL     shift and go to state 46
    DIV_EQUAL       shift and go to state 47
    TIMES_EQUAL     shift and go to state 48
    MOD_EQUAL       shift and go to state 49
    AND_EQUAL       shift and go to state 50
    OR_EQUAL        shift and go to state 51
    XOR_EQUAL       shift and go to state 52
    COMPLEMENT_EQUAL shift and go to state 53
    SHIFTL_EQUAL    shift and go to state 54
    SHIFTR_EQUAL    shift and go to state 55

    ASSIGNMENT_OPERATOR            shift and go to state 100

state 84

    (39) CONTROL_STRUCTURES -> IF_STRUCTURE .

    SEMICOLON       reduce using rule 39 (CONTROL_STRUCTURES -> IF_STRUCTURE .)


state 85

    (40) CONTROL_STRUCTURES -> FOR_STRUCTURE .

    SEMICOLON       reduce using rule 40 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)


state 86

    (41) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

    SEMICOLON       reduce using rule 41 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)


state 87

    (42) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

    SEMICOLON       reduce using rule 42 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)


state 88

    (62) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    VARNAME         shift and go to state 91


state 89

    (46) FOR_STRUCTURE -> INTEGER .
    (43) WHILE_STRUCTURE -> INTEGER .
    (44) SWITCH_STRUCTURE -> INTEGER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 43 (WHILE_STRUCTURE -> INTEGER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 43 (WHILE_STRUCTURE -> INTEGER .)
    SEMICOLON       reduce using rule 43 (WHILE_STRUCTURE -> INTEGER .)

  ! SEMICOLON       [ reduce using rule 46 (FOR_STRUCTURE -> INTEGER .) ]
  ! SEMICOLON       [ reduce using rule 44 (SWITCH_STRUCTURE -> INTEGER .) ]


state 90

    (63) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    VARNAME         shift and go to state 92


state 91

    (62) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME . EQUAL INTEGER

    EQUAL           shift and go to state 105


state 92

    (63) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME . EQUAL DECIMAL

    EQUAL           shift and go to state 106


state 93

    (86) OPERATIONS -> OPERATION OPERATOR . OPERATIONS
    (85) OPERATIONS -> . OPERATION
    (86) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (84) OPERATION -> . NUMBER OPERATOR NUMBER
    (37) NUMBER -> . INTEGER
    (38) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 103
    DECIMAL         shift and go to state 36

    OPERATION                      shift and go to state 107
    OPERATIONS                     shift and go to state 108
    NUMBER                         shift and go to state 109

state 94

    (95) COMPARISONS -> COMPARISON LOGICAL_OPERATOR . COMPARISONS
    (94) COMPARISONS -> . COMPARISON
    (95) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (93) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (35) VALUE -> . NUMBER
    (36) VALUE -> . STRING
    (37) NUMBER -> . INTEGER
    (38) NUMBER -> . DECIMAL

    STRING          shift and go to state 34
    INTEGER         shift and go to state 103
    DECIMAL         shift and go to state 36

    COMPARISON                     shift and go to state 110
    COMPARISONS                    shift and go to state 111
    VALUE                          shift and go to state 112
    NUMBER                         shift and go to state 102

state 95

    (33) DEFINE -> PP_DEFINE VARIABLELEX . VALUE
    (35) VALUE -> . NUMBER
    (36) VALUE -> . STRING
    (37) NUMBER -> . INTEGER
    (38) NUMBER -> . DECIMAL

    STRING          shift and go to state 34
    INTEGER         shift and go to state 103
    DECIMAL         shift and go to state 36

    VALUE                          shift and go to state 113
    NUMBER                         shift and go to state 102

state 96

    (78) VARIABLELEX -> VARNAME .

    STRING          reduce using rule 78 (VARIABLELEX -> VARNAME .)
    INTEGER         reduce using rule 78 (VARIABLELEX -> VARNAME .)
    DECIMAL         reduce using rule 78 (VARIABLELEX -> VARNAME .)


state 97

    (34) INCLUDE -> PP_INCLUDE HEADER_LIB .

    $end            reduce using rule 34 (INCLUDE -> PP_INCLUDE HEADER_LIB .)


state 98

    (45) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (94) COMPARISONS -> . COMPARISON
    (95) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (93) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (35) VALUE -> . NUMBER
    (36) VALUE -> . STRING
    (37) NUMBER -> . INTEGER
    (38) NUMBER -> . DECIMAL

    STRING          shift and go to state 34
    INTEGER         shift and go to state 103
    DECIMAL         shift and go to state 36

    COMPARISONS                    shift and go to state 114
    COMPARISON                     shift and go to state 110
    VALUE                          shift and go to state 112
    NUMBER                         shift and go to state 102

state 99

    (56) FUNCTION -> VARNAME LPAREN . RPAREN

    RPAREN          shift and go to state 115


state 100

    (64) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR . SENTENCE
    (99) SENTENCE -> . NUMBER
    (100) SENTENCE -> . VARNAME
    (37) NUMBER -> . INTEGER
    (38) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 116
    INTEGER         shift and go to state 103
    DECIMAL         shift and go to state 36

    SENTENCE                       shift and go to state 117
    NUMBER                         shift and go to state 118

state 101

    (93) COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .

    AND             reduce using rule 93 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    OR              reduce using rule 93 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    NOT             reduce using rule 93 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    $end            reduce using rule 93 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    RPAREN          reduce using rule 93 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)


state 102

    (35) VALUE -> NUMBER .

    AND             reduce using rule 35 (VALUE -> NUMBER .)
    OR              reduce using rule 35 (VALUE -> NUMBER .)
    NOT             reduce using rule 35 (VALUE -> NUMBER .)
    $end            reduce using rule 35 (VALUE -> NUMBER .)
    RPAREN          reduce using rule 35 (VALUE -> NUMBER .)
    EQUAL_TO        reduce using rule 35 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 35 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 35 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 35 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 35 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 35 (VALUE -> NUMBER .)


state 103

    (37) NUMBER -> INTEGER .

    AND             reduce using rule 37 (NUMBER -> INTEGER .)
    OR              reduce using rule 37 (NUMBER -> INTEGER .)
    NOT             reduce using rule 37 (NUMBER -> INTEGER .)
    $end            reduce using rule 37 (NUMBER -> INTEGER .)
    RPAREN          reduce using rule 37 (NUMBER -> INTEGER .)
    PLUS            reduce using rule 37 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 37 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 37 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 37 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 37 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 37 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 37 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 37 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 37 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 37 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 37 (NUMBER -> INTEGER .)
    SEMICOLON       reduce using rule 37 (NUMBER -> INTEGER .)


state 104

    (84) OPERATION -> NUMBER OPERATOR NUMBER .

    PLUS            reduce using rule 84 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MINUS           reduce using rule 84 (OPERATION -> NUMBER OPERATOR NUMBER .)
    TIMES           reduce using rule 84 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MODULUS         reduce using rule 84 (OPERATION -> NUMBER OPERATOR NUMBER .)
    DIVIDE          reduce using rule 84 (OPERATION -> NUMBER OPERATOR NUMBER .)
    $end            reduce using rule 84 (OPERATION -> NUMBER OPERATOR NUMBER .)


state 105

    (62) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL . INTEGER

    INTEGER         shift and go to state 119


state 106

    (63) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL . DECIMAL

    DECIMAL         shift and go to state 120


state 107

    (85) OPERATIONS -> OPERATION .
    (86) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (79) OPERATOR -> . PLUS
    (80) OPERATOR -> . MINUS
    (81) OPERATOR -> . TIMES
    (82) OPERATOR -> . MODULUS
    (83) OPERATOR -> . DIVIDE

    $end            reduce using rule 85 (OPERATIONS -> OPERATION .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    MODULUS         shift and go to state 60
    DIVIDE          shift and go to state 61

    OPERATOR                       shift and go to state 93

state 108

    (86) OPERATIONS -> OPERATION OPERATOR OPERATIONS .

    $end            reduce using rule 86 (OPERATIONS -> OPERATION OPERATOR OPERATIONS .)


state 109

    (84) OPERATION -> NUMBER . OPERATOR NUMBER
    (79) OPERATOR -> . PLUS
    (80) OPERATOR -> . MINUS
    (81) OPERATOR -> . TIMES
    (82) OPERATOR -> . MODULUS
    (83) OPERATOR -> . DIVIDE

    PLUS            shift and go to state 57
    MINUS           shift and go to state 58
    TIMES           shift and go to state 59
    MODULUS         shift and go to state 60
    DIVIDE          shift and go to state 61

    OPERATOR                       shift and go to state 72

state 110

    (94) COMPARISONS -> COMPARISON .
    (95) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (96) LOGICAL_OPERATOR -> . AND
    (97) LOGICAL_OPERATOR -> . OR
    (98) LOGICAL_OPERATOR -> . NOT

    $end            reduce using rule 94 (COMPARISONS -> COMPARISON .)
    RPAREN          reduce using rule 94 (COMPARISONS -> COMPARISON .)
    AND             shift and go to state 68
    OR              shift and go to state 69
    NOT             shift and go to state 70

    LOGICAL_OPERATOR               shift and go to state 94

state 111

    (95) COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .

    $end            reduce using rule 95 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)
    RPAREN          reduce using rule 95 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)


state 112

    (93) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (87) COMPARISON_OPERATOR -> . EQUAL_TO
    (88) COMPARISON_OPERATOR -> . NOT_EQUAL
    (89) COMPARISON_OPERATOR -> . GREATER_THAN
    (90) COMPARISON_OPERATOR -> . LESS_THAN
    (91) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (92) COMPARISON_OPERATOR -> . LESS_EQUAL

    EQUAL_TO        shift and go to state 62
    NOT_EQUAL       shift and go to state 63
    GREATER_THAN    shift and go to state 64
    LESS_THAN       shift and go to state 65
    GREATER_EQUAL   shift and go to state 66
    LESS_EQUAL      shift and go to state 67

    COMPARISON_OPERATOR            shift and go to state 71

state 113

    (33) DEFINE -> PP_DEFINE VARIABLELEX VALUE .

    $end            reduce using rule 33 (DEFINE -> PP_DEFINE VARIABLELEX VALUE .)


state 114

    (45) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE

    RPAREN          shift and go to state 121


state 115

    (56) FUNCTION -> VARNAME LPAREN RPAREN .

    $end            reduce using rule 56 (FUNCTION -> VARNAME LPAREN RPAREN .)
    SEMICOLON       reduce using rule 56 (FUNCTION -> VARNAME LPAREN RPAREN .)


state 116

    (100) SENTENCE -> VARNAME .

    $end            reduce using rule 100 (SENTENCE -> VARNAME .)
    SEMICOLON       reduce using rule 100 (SENTENCE -> VARNAME .)


state 117

    (64) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .

    $end            reduce using rule 64 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)
    SEMICOLON       reduce using rule 64 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)


state 118

    (99) SENTENCE -> NUMBER .

    $end            reduce using rule 99 (SENTENCE -> NUMBER .)
    SEMICOLON       reduce using rule 99 (SENTENCE -> NUMBER .)


state 119

    (62) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .

    $end            reduce using rule 62 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)
    SEMICOLON       reduce using rule 62 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)


state 120

    (63) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .

    $end            reduce using rule 63 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)
    SEMICOLON       reduce using rule 63 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)


state 121

    (45) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE

    LCURL_BRACE     shift and go to state 122


state 122

    (45) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (54) EXPRESSIONS -> . EXPRESSION
    (55) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (53) EXPRESSION -> . CODE SEMICOLON
    (47) CODE -> . FUNCTION
    (48) CODE -> . CONTROL_STRUCTURES
    (49) CODE -> . INTEGER_DECLARATION
    (50) CODE -> . DECIMAL_DECLARATION
    (51) CODE -> . ASSIGNMENT_DECLARATION
    (52) CODE -> . COMENTARIOLEX
    (56) FUNCTION -> . VARNAME LPAREN RPAREN
    (39) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (40) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (41) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (42) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (62) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (63) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (64) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (77) COMENTARIOLEX -> . COMMENT
    (45) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (46) FOR_STRUCTURE -> . INTEGER
    (43) WHILE_STRUCTURE -> . INTEGER
    (44) SWITCH_STRUCTURE -> . INTEGER
    (57) INTEGER_TYPE -> . INT
    (58) INTEGER_TYPE -> . SHORT
    (59) INTEGER_TYPE -> . LONG
    (60) DECIMAL_TYPE -> . FLOAT
    (61) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 83
    COMMENT         shift and go to state 56
    IF              shift and go to state 37
    INTEGER         shift and go to state 89
    INT             shift and go to state 39
    SHORT           shift and go to state 40
    LONG            shift and go to state 41
    FLOAT           shift and go to state 42
    DOUBLE          shift and go to state 43

    EXPRESSIONS                    shift and go to state 123
    EXPRESSION                     shift and go to state 74
    CODE                           shift and go to state 76
    FUNCTION                       shift and go to state 77
    CONTROL_STRUCTURES             shift and go to state 78
    INTEGER_DECLARATION            shift and go to state 79
    DECIMAL_DECLARATION            shift and go to state 80
    ASSIGNMENT_DECLARATION         shift and go to state 81
    COMENTARIOLEX                  shift and go to state 82
    IF_STRUCTURE                   shift and go to state 84
    FOR_STRUCTURE                  shift and go to state 85
    WHILE_STRUCTURE                shift and go to state 86
    SWITCH_STRUCTURE               shift and go to state 87
    INTEGER_TYPE                   shift and go to state 88
    DECIMAL_TYPE                   shift and go to state 90

state 123

    (45) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE

    RCURL_BRACE     shift and go to state 124


state 124

    (45) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .

    $end            reduce using rule 45 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SEMICOLON       reduce using rule 45 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (ROOT -> DEFINE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> DEFINE) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (ROOT -> INCLUDE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> INCLUDE) in state 4
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (VALUE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (SENTENCE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (ROOT -> CONTROL_STRUCTURES)
WARNING: rejected rule (CODE -> CONTROL_STRUCTURES) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (ROOT -> WHILE_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> WHILE_STRUCTURE) in state 8
WARNING: reduce/reduce conflict in state 9 resolved using rule (ROOT -> SWITCH_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> SWITCH_STRUCTURE) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (ROOT -> IF_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> IF_STRUCTURE) in state 10
WARNING: reduce/reduce conflict in state 11 resolved using rule (ROOT -> FOR_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> FOR_STRUCTURE) in state 11
WARNING: reduce/reduce conflict in state 13 resolved using rule (ROOT -> EXPRESSION)
WARNING: rejected rule (EXPRESSIONS -> EXPRESSION) in state 13
WARNING: reduce/reduce conflict in state 15 resolved using rule (ROOT -> FUNCTION)
WARNING: rejected rule (CODE -> FUNCTION) in state 15
WARNING: reduce/reduce conflict in state 18 resolved using rule (ROOT -> INTEGER_DECLARATION)
WARNING: rejected rule (CODE -> INTEGER_DECLARATION) in state 18
WARNING: reduce/reduce conflict in state 19 resolved using rule (ROOT -> DECIMAL_DECLARATION)
WARNING: rejected rule (CODE -> DECIMAL_DECLARATION) in state 19
WARNING: reduce/reduce conflict in state 20 resolved using rule (ROOT -> ASSIGNMENT_DECLARATION)
WARNING: rejected rule (CODE -> ASSIGNMENT_DECLARATION) in state 20
WARNING: reduce/reduce conflict in state 22 resolved using rule (ROOT -> COMENTARIOLEX)
WARNING: rejected rule (CODE -> COMENTARIOLEX) in state 22
WARNING: reduce/reduce conflict in state 25 resolved using rule (ROOT -> OPERATION)
WARNING: rejected rule (OPERATIONS -> OPERATION) in state 25
WARNING: reduce/reduce conflict in state 28 resolved using rule (ROOT -> COMPARISON)
WARNING: rejected rule (COMPARISONS -> COMPARISON) in state 28
WARNING: reduce/reduce conflict in state 35 resolved using rule (NUMBER -> INTEGER)
WARNING: rejected rule (WHILE_STRUCTURE -> INTEGER) in state 35
WARNING: reduce/reduce conflict in state 35 resolved using rule (NUMBER -> INTEGER)
WARNING: rejected rule (SWITCH_STRUCTURE -> INTEGER) in state 35
WARNING: reduce/reduce conflict in state 35 resolved using rule (WHILE_STRUCTURE -> INTEGER)
WARNING: rejected rule (SWITCH_STRUCTURE -> INTEGER) in state 35
WARNING: reduce/reduce conflict in state 35 resolved using rule (NUMBER -> INTEGER)
WARNING: rejected rule (FOR_STRUCTURE -> INTEGER) in state 35
WARNING: reduce/reduce conflict in state 35 resolved using rule (WHILE_STRUCTURE -> INTEGER)
WARNING: rejected rule (FOR_STRUCTURE -> INTEGER) in state 35
WARNING: reduce/reduce conflict in state 38 resolved using rule (VARIABLELEX -> VARNAME)
WARNING: rejected rule (SENTENCE -> VARNAME) in state 38
WARNING: reduce/reduce conflict in state 89 resolved using rule (WHILE_STRUCTURE -> INTEGER)
WARNING: rejected rule (FOR_STRUCTURE -> INTEGER) in state 89
WARNING: reduce/reduce conflict in state 89 resolved using rule (WHILE_STRUCTURE -> INTEGER)
WARNING: rejected rule (SWITCH_STRUCTURE -> INTEGER) in state 89
WARNING: Rule (PREPROCESOR_DIRECTIVE -> DEFINE) is never reduced
WARNING: Rule (PREPROCESOR_DIRECTIVE -> INCLUDE) is never reduced
WARNING: Rule (SWITCH_STRUCTURE -> INTEGER) is never reduced
WARNING: Rule (FOR_STRUCTURE -> INTEGER) is never reduced
