Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AUTO
    BACKSLASH
    BACKSPACE
    B_AND
    B_COMPLEMENT
    B_OR
    B_XOR
    CHAR
    CHARACTER
    COMMA
    CONST
    DO
    DOT
    DOUBLE_APOS
    DOUBLE_QUOTE
    ELSE
    ENUM
    EXTERN
    FF_PAGEBREAK
    FOR
    FS_CHAR
    FS_DOUBLE
    FS_FLOAT
    FS_HEX
    FS_INT
    FS_LONG
    FS_LONG_DOUBLE
    FS_OCT
    FS_OCT_LONG
    FS_POINTER
    FS_SCI_NOTATION
    FS_STRING
    FS_UNSIGNED_INT
    FS_UNSIGNED_LONG
    GOTO
    HTAB
    IGNORE
    LBRACKET
    NEWLINE
    NULL
    PP_DATE
    PP_DTMACRO
    PP_ERROR
    PP_FILE
    PP_IF
    PP_IFDEF
    PP_IFNDEF
    PP_LINE
    PP_PRAGMA
    PP_STMACRO
    PP_TIME
    PP_TIMESTAMP
    PP_UNDEF
    QUESTIONMARK
    RBRACKET
    REGISTER
    RETURN
    SHIFT_LEFT
    SHIFT_RIGHT
    SIGNED
    SINGLE_APOS
    SINGLE_QUOTE
    SIZEOF
    STATIC
    STRUCT
    TILDE
    TYPEDEF
    UNION
    UNSIGNED
    VOID
    VOLTILE
    VTAB

Grammar

Rule 0     S' -> ROOT
Rule 1     ROOT -> PREPROCESOR_DIRECTIVE
Rule 2     ROOT -> DEFINE
Rule 3     ROOT -> INCLUDE
Rule 4     ROOT -> VALUE
Rule 5     ROOT -> NUMBER
Rule 6     ROOT -> CONTROL_STRUCTURES
Rule 7     ROOT -> WHILE_STRUCTURE
Rule 8     ROOT -> SWITCH_STRUCTURE
Rule 9     ROOT -> IF_STRUCTURE
Rule 10    ROOT -> FOR_STRUCTURE
Rule 11    ROOT -> CODE
Rule 12    ROOT -> EXPRESSION
Rule 13    ROOT -> EXPRESSIONS
Rule 14    ROOT -> FUNCTION
Rule 15    ROOT -> INTEGER_TYPE
Rule 16    ROOT -> DECIMAL_TYPE
Rule 17    ROOT -> INTEGER_DECLARATION
Rule 18    ROOT -> DECIMAL_DECLARATION
Rule 19    ROOT -> ASSIGNMENT_DECLARATION
Rule 20    ROOT -> ASSIGNMENT_OPERATOR
Rule 21    ROOT -> COMENTARIOLEX
Rule 22    ROOT -> VARIABLELEX
Rule 23    ROOT -> OPERATOR
Rule 24    ROOT -> OPERATION
Rule 25    ROOT -> OPERATIONS
Rule 26    ROOT -> COMPARISON_OPERATOR
Rule 27    ROOT -> COMPARISON
Rule 28    ROOT -> COMPARISONS
Rule 29    ROOT -> LOGICAL_OPERATOR
Rule 30    ROOT -> SENTENCE
Rule 31    ROOT -> SWITCH_BODY
Rule 32    ROOT -> BUCLE
Rule 33    PREPROCESOR_DIRECTIVE -> DEFINE
Rule 34    PREPROCESOR_DIRECTIVE -> INCLUDE
Rule 35    DEFINE -> PP_DEFINE VARIABLELEX VALUE
Rule 36    INCLUDE -> PP_INCLUDE HEADER_LIB
Rule 37    VALUE -> NUMBER
Rule 38    VALUE -> STRING
Rule 39    NUMBER -> INTEGER
Rule 40    NUMBER -> DECIMAL
Rule 41    CONTROL_STRUCTURES -> IF_STRUCTURE
Rule 42    CONTROL_STRUCTURES -> FOR_STRUCTURE
Rule 43    CONTROL_STRUCTURES -> WHILE_STRUCTURE
Rule 44    CONTROL_STRUCTURES -> SWITCH_STRUCTURE
Rule 45    BODY_STRUCTURE -> EXPRESSIONS
Rule 46    BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON
Rule 47    BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON
Rule 48    WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
Rule 49    SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
Rule 50    SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON
Rule 51    SWITCH_BODY -> SWITCH_CASE
Rule 52    SWITCH_BODY -> SWITCH_DEFAULT
Rule 53    SWITCH_BODY -> SWITCH_CASE SWITCH_BODY
Rule 54    SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
Rule 55    BUCLE -> VARIABLELEX INCREASE
Rule 56    BUCLE -> DECREASE VARIABLELEX
Rule 57    FOR_STRUCTURE -> INTEGER
Rule 58    IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
Rule 59    CODE -> FUNCTION
Rule 60    CODE -> INTEGER_DECLARATION
Rule 61    CODE -> DECIMAL_DECLARATION
Rule 62    CODE -> ASSIGNMENT_DECLARATION
Rule 63    CODE -> COMENTARIOLEX
Rule 64    EXPRESSION -> CODE SEMICOLON
Rule 65    EXPRESSION -> CONTROL_STRUCTURES
Rule 66    EXPRESSIONS -> EXPRESSION
Rule 67    EXPRESSIONS -> EXPRESSION EXPRESSIONS
Rule 68    FUNCTION -> VARNAME LPAREN RPAREN
Rule 69    INTEGER_TYPE -> INT
Rule 70    INTEGER_TYPE -> SHORT
Rule 71    INTEGER_TYPE -> LONG
Rule 72    DECIMAL_TYPE -> FLOAT
Rule 73    DECIMAL_TYPE -> DOUBLE
Rule 74    INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER
Rule 75    DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL
Rule 76    ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE
Rule 77    ASSIGNMENT_OPERATOR -> EQUAL
Rule 78    ASSIGNMENT_OPERATOR -> PLUS_EQUAL
Rule 79    ASSIGNMENT_OPERATOR -> MINUS_EQUAL
Rule 80    ASSIGNMENT_OPERATOR -> DIV_EQUAL
Rule 81    ASSIGNMENT_OPERATOR -> TIMES_EQUAL
Rule 82    ASSIGNMENT_OPERATOR -> MOD_EQUAL
Rule 83    ASSIGNMENT_OPERATOR -> AND_EQUAL
Rule 84    ASSIGNMENT_OPERATOR -> OR_EQUAL
Rule 85    ASSIGNMENT_OPERATOR -> XOR_EQUAL
Rule 86    ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL
Rule 87    ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL
Rule 88    ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL
Rule 89    COMENTARIOLEX -> COMMENT
Rule 90    VARIABLELEX -> VARNAME
Rule 91    OPERATOR -> PLUS
Rule 92    OPERATOR -> MINUS
Rule 93    OPERATOR -> TIMES
Rule 94    OPERATOR -> MODULUS
Rule 95    OPERATOR -> DIVIDE
Rule 96    OPERATION -> NUMBER OPERATOR NUMBER
Rule 97    OPERATIONS -> OPERATION
Rule 98    OPERATIONS -> OPERATION OPERATOR OPERATIONS
Rule 99    COMPARISON_OPERATOR -> EQUAL_TO
Rule 100   COMPARISON_OPERATOR -> NOT_EQUAL
Rule 101   COMPARISON_OPERATOR -> GREATER_THAN
Rule 102   COMPARISON_OPERATOR -> LESS_THAN
Rule 103   COMPARISON_OPERATOR -> GREATER_EQUAL
Rule 104   COMPARISON_OPERATOR -> LESS_EQUAL
Rule 105   COMPARISON -> VALUE COMPARISON_OPERATOR VALUE
Rule 106   COMPARISONS -> COMPARISON
Rule 107   COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS
Rule 108   LOGICAL_OPERATOR -> AND
Rule 109   LOGICAL_OPERATOR -> OR
Rule 110   LOGICAL_OPERATOR -> NOT
Rule 111   SENTENCE -> NUMBER
Rule 112   SENTENCE -> VARNAME

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 108
AND_EQUAL            : 83
AUTO                 : 
BACKSLASH            : 
BACKSPACE            : 
BREAK                : 46 49 50
B_AND                : 
B_COMPLEMENT         : 
B_OR                 : 
B_XOR                : 
CASE                 : 49
CHAR                 : 
CHARACTER            : 
COLON                : 49 50
COMMA                : 
COMMENT              : 89
COMPLEMENT_EQUAL     : 86
CONST                : 
CONTINUE             : 47
DECIMAL              : 40 75
DECREASE             : 56
DEFAULT              : 50
DIVIDE               : 95
DIV_EQUAL            : 80
DO                   : 
DOT                  : 
DOUBLE               : 73
DOUBLE_APOS          : 
DOUBLE_QUOTE         : 
ELSE                 : 
ENUM                 : 
EQUAL                : 74 75 77
EQUAL_TO             : 99
EXTERN               : 
FF_PAGEBREAK         : 
FLOAT                : 72
FOR                  : 
FS_CHAR              : 
FS_DOUBLE            : 
FS_FLOAT             : 
FS_HEX               : 
FS_INT               : 
FS_LONG              : 
FS_LONG_DOUBLE       : 
FS_OCT               : 
FS_OCT_LONG          : 
FS_POINTER           : 
FS_SCI_NOTATION      : 
FS_STRING            : 
FS_UNSIGNED_INT      : 
FS_UNSIGNED_LONG     : 
GOTO                 : 
GREATER_EQUAL        : 103
GREATER_THAN         : 101
HEADER_LIB           : 36
HTAB                 : 
IF                   : 58
IGNORE               : 
INCREASE             : 55
INT                  : 69
INTEGER              : 39 49 57 74
LBRACKET             : 
LCURL_BRACE          : 48 54 58
LESS_EQUAL           : 104
LESS_THAN            : 102
LONG                 : 71
LPAREN               : 48 54 58 68
MINUS                : 92
MINUS_EQUAL          : 79
MODULUS              : 94
MOD_EQUAL            : 82
NEWLINE              : 
NOT                  : 110
NOT_EQUAL            : 100
NULL                 : 
OR                   : 109
OR_EQUAL             : 84
PLUS                 : 91
PLUS_EQUAL           : 78
PP_DATE              : 
PP_DEFINE            : 35
PP_DTMACRO           : 
PP_ERROR             : 
PP_FILE              : 
PP_IF                : 
PP_IFDEF             : 
PP_IFNDEF            : 
PP_INCLUDE           : 36
PP_LINE              : 
PP_PRAGMA            : 
PP_STMACRO           : 
PP_TIME              : 
PP_TIMESTAMP         : 
PP_UNDEF             : 
QUESTIONMARK         : 
RBRACKET             : 
RCURL_BRACE          : 48 54 58
REGISTER             : 
RETURN               : 
RPAREN               : 48 54 58 68
SEMICOLON            : 46 47 49 50 64
SHIFTL_EQUAL         : 87
SHIFTR_EQUAL         : 88
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
SHORT                : 70
SIGNED               : 
SINGLE_APOS          : 
SINGLE_QUOTE         : 
SIZEOF               : 
STATIC               : 
STRING               : 38
STRUCT               : 
SWITCH               : 54
TILDE                : 
TIMES                : 93
TIMES_EQUAL          : 81
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VARNAME              : 68 74 75 76 90 112
VOID                 : 
VOLTILE              : 
VTAB                 : 
WHILE                : 48
XOR_EQUAL            : 85
error                : 

Nonterminals, with rules where they appear

ASSIGNMENT_DECLARATION : 19 62
ASSIGNMENT_OPERATOR  : 20 76
BODY_STRUCTURE       : 48
BUCLE                : 32
CODE                 : 11 64
COMENTARIOLEX        : 21 63
COMPARISON           : 27 106 107
COMPARISONS          : 28 48 54 58 107
COMPARISON_OPERATOR  : 26 105
CONTROL_STRUCTURES   : 6 65
DECIMAL_DECLARATION  : 18 61
DECIMAL_TYPE         : 16 75
DEFINE               : 2 33
EXPRESSION           : 12 66 67
EXPRESSIONS          : 13 45 46 47 49 50 58 67
FOR_STRUCTURE        : 10 42
FUNCTION             : 14 59
IF_STRUCTURE         : 9 41
INCLUDE              : 3 34
INTEGER_DECLARATION  : 17 60
INTEGER_TYPE         : 15 74
LOGICAL_OPERATOR     : 29 107
NUMBER               : 5 37 96 96 111
OPERATION            : 24 97 98
OPERATIONS           : 25 98
OPERATOR             : 23 96 98
PREPROCESOR_DIRECTIVE : 1
ROOT                 : 0
SENTENCE             : 30 76
SWITCH_BODY          : 31 53 54
SWITCH_CASE          : 51 53
SWITCH_DEFAULT       : 52
SWITCH_STRUCTURE     : 8 44
VALUE                : 4 35 105 105
VARIABLELEX          : 22 35 55 56
WHILE_STRUCTURE      : 7 43

Parsing method: LALR

state 0

    (0) S' -> . ROOT
    (1) ROOT -> . PREPROCESOR_DIRECTIVE
    (2) ROOT -> . DEFINE
    (3) ROOT -> . INCLUDE
    (4) ROOT -> . VALUE
    (5) ROOT -> . NUMBER
    (6) ROOT -> . CONTROL_STRUCTURES
    (7) ROOT -> . WHILE_STRUCTURE
    (8) ROOT -> . SWITCH_STRUCTURE
    (9) ROOT -> . IF_STRUCTURE
    (10) ROOT -> . FOR_STRUCTURE
    (11) ROOT -> . CODE
    (12) ROOT -> . EXPRESSION
    (13) ROOT -> . EXPRESSIONS
    (14) ROOT -> . FUNCTION
    (15) ROOT -> . INTEGER_TYPE
    (16) ROOT -> . DECIMAL_TYPE
    (17) ROOT -> . INTEGER_DECLARATION
    (18) ROOT -> . DECIMAL_DECLARATION
    (19) ROOT -> . ASSIGNMENT_DECLARATION
    (20) ROOT -> . ASSIGNMENT_OPERATOR
    (21) ROOT -> . COMENTARIOLEX
    (22) ROOT -> . VARIABLELEX
    (23) ROOT -> . OPERATOR
    (24) ROOT -> . OPERATION
    (25) ROOT -> . OPERATIONS
    (26) ROOT -> . COMPARISON_OPERATOR
    (27) ROOT -> . COMPARISON
    (28) ROOT -> . COMPARISONS
    (29) ROOT -> . LOGICAL_OPERATOR
    (30) ROOT -> . SENTENCE
    (31) ROOT -> . SWITCH_BODY
    (32) ROOT -> . BUCLE
    (33) PREPROCESOR_DIRECTIVE -> . DEFINE
    (34) PREPROCESOR_DIRECTIVE -> . INCLUDE
    (35) DEFINE -> . PP_DEFINE VARIABLELEX VALUE
    (36) INCLUDE -> . PP_INCLUDE HEADER_LIB
    (37) VALUE -> . NUMBER
    (38) VALUE -> . STRING
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL
    (41) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (42) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (43) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (44) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (48) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (54) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (58) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (57) FOR_STRUCTURE -> . INTEGER
    (59) CODE -> . FUNCTION
    (60) CODE -> . INTEGER_DECLARATION
    (61) CODE -> . DECIMAL_DECLARATION
    (62) CODE -> . ASSIGNMENT_DECLARATION
    (63) CODE -> . COMENTARIOLEX
    (64) EXPRESSION -> . CODE SEMICOLON
    (65) EXPRESSION -> . CONTROL_STRUCTURES
    (66) EXPRESSIONS -> . EXPRESSION
    (67) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (68) FUNCTION -> . VARNAME LPAREN RPAREN
    (69) INTEGER_TYPE -> . INT
    (70) INTEGER_TYPE -> . SHORT
    (71) INTEGER_TYPE -> . LONG
    (72) DECIMAL_TYPE -> . FLOAT
    (73) DECIMAL_TYPE -> . DOUBLE
    (74) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (75) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (76) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (77) ASSIGNMENT_OPERATOR -> . EQUAL
    (78) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (79) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (80) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (81) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (82) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (83) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (84) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (85) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (86) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (87) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (88) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL
    (89) COMENTARIOLEX -> . COMMENT
    (90) VARIABLELEX -> . VARNAME
    (91) OPERATOR -> . PLUS
    (92) OPERATOR -> . MINUS
    (93) OPERATOR -> . TIMES
    (94) OPERATOR -> . MODULUS
    (95) OPERATOR -> . DIVIDE
    (96) OPERATION -> . NUMBER OPERATOR NUMBER
    (97) OPERATIONS -> . OPERATION
    (98) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (99) COMPARISON_OPERATOR -> . EQUAL_TO
    (100) COMPARISON_OPERATOR -> . NOT_EQUAL
    (101) COMPARISON_OPERATOR -> . GREATER_THAN
    (102) COMPARISON_OPERATOR -> . LESS_THAN
    (103) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (104) COMPARISON_OPERATOR -> . LESS_EQUAL
    (105) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (106) COMPARISONS -> . COMPARISON
    (107) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (108) LOGICAL_OPERATOR -> . AND
    (109) LOGICAL_OPERATOR -> . OR
    (110) LOGICAL_OPERATOR -> . NOT
    (111) SENTENCE -> . NUMBER
    (112) SENTENCE -> . VARNAME
    (51) SWITCH_BODY -> . SWITCH_CASE
    (52) SWITCH_BODY -> . SWITCH_DEFAULT
    (53) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (55) BUCLE -> . VARIABLELEX INCREASE
    (56) BUCLE -> . DECREASE VARIABLELEX
    (49) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (50) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    PP_DEFINE       shift and go to state 34
    PP_INCLUDE      shift and go to state 35
    STRING          shift and go to state 36
    INTEGER         shift and go to state 37
    DECIMAL         shift and go to state 38
    WHILE           shift and go to state 39
    SWITCH          shift and go to state 40
    IF              shift and go to state 41
    VARNAME         shift and go to state 42
    INT             shift and go to state 43
    SHORT           shift and go to state 44
    LONG            shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    EQUAL           shift and go to state 48
    PLUS_EQUAL      shift and go to state 49
    MINUS_EQUAL     shift and go to state 50
    DIV_EQUAL       shift and go to state 51
    TIMES_EQUAL     shift and go to state 52
    MOD_EQUAL       shift and go to state 53
    AND_EQUAL       shift and go to state 54
    OR_EQUAL        shift and go to state 55
    XOR_EQUAL       shift and go to state 56
    COMPLEMENT_EQUAL shift and go to state 57
    SHIFTL_EQUAL    shift and go to state 58
    SHIFTR_EQUAL    shift and go to state 59
    COMMENT         shift and go to state 60
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    MODULUS         shift and go to state 64
    DIVIDE          shift and go to state 65
    EQUAL_TO        shift and go to state 66
    NOT_EQUAL       shift and go to state 67
    GREATER_THAN    shift and go to state 68
    LESS_THAN       shift and go to state 69
    GREATER_EQUAL   shift and go to state 70
    LESS_EQUAL      shift and go to state 71
    AND             shift and go to state 72
    OR              shift and go to state 73
    NOT             shift and go to state 74
    DECREASE        shift and go to state 77
    CASE            shift and go to state 78
    DEFAULT         shift and go to state 79

    ROOT                           shift and go to state 1
    PREPROCESOR_DIRECTIVE          shift and go to state 2
    DEFINE                         shift and go to state 3
    INCLUDE                        shift and go to state 4
    VALUE                          shift and go to state 5
    NUMBER                         shift and go to state 6
    CONTROL_STRUCTURES             shift and go to state 7
    WHILE_STRUCTURE                shift and go to state 8
    SWITCH_STRUCTURE               shift and go to state 9
    IF_STRUCTURE                   shift and go to state 10
    FOR_STRUCTURE                  shift and go to state 11
    CODE                           shift and go to state 12
    EXPRESSION                     shift and go to state 13
    EXPRESSIONS                    shift and go to state 14
    FUNCTION                       shift and go to state 15
    INTEGER_TYPE                   shift and go to state 16
    DECIMAL_TYPE                   shift and go to state 17
    INTEGER_DECLARATION            shift and go to state 18
    DECIMAL_DECLARATION            shift and go to state 19
    ASSIGNMENT_DECLARATION         shift and go to state 20
    ASSIGNMENT_OPERATOR            shift and go to state 21
    COMENTARIOLEX                  shift and go to state 22
    VARIABLELEX                    shift and go to state 23
    OPERATOR                       shift and go to state 24
    OPERATION                      shift and go to state 25
    OPERATIONS                     shift and go to state 26
    COMPARISON_OPERATOR            shift and go to state 27
    COMPARISON                     shift and go to state 28
    COMPARISONS                    shift and go to state 29
    LOGICAL_OPERATOR               shift and go to state 30
    SENTENCE                       shift and go to state 31
    SWITCH_BODY                    shift and go to state 32
    BUCLE                          shift and go to state 33
    SWITCH_CASE                    shift and go to state 75
    SWITCH_DEFAULT                 shift and go to state 76

state 1

    (0) S' -> ROOT .



state 2

    (1) ROOT -> PREPROCESOR_DIRECTIVE .

    $end            reduce using rule 1 (ROOT -> PREPROCESOR_DIRECTIVE .)


state 3

    (2) ROOT -> DEFINE .
    (33) PREPROCESOR_DIRECTIVE -> DEFINE .

  ! reduce/reduce conflict for $end resolved using rule 2 (ROOT -> DEFINE .)
    $end            reduce using rule 2 (ROOT -> DEFINE .)

  ! $end            [ reduce using rule 33 (PREPROCESOR_DIRECTIVE -> DEFINE .) ]


state 4

    (3) ROOT -> INCLUDE .
    (34) PREPROCESOR_DIRECTIVE -> INCLUDE .

  ! reduce/reduce conflict for $end resolved using rule 3 (ROOT -> INCLUDE .)
    $end            reduce using rule 3 (ROOT -> INCLUDE .)

  ! $end            [ reduce using rule 34 (PREPROCESOR_DIRECTIVE -> INCLUDE .) ]


state 5

    (4) ROOT -> VALUE .
    (105) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (99) COMPARISON_OPERATOR -> . EQUAL_TO
    (100) COMPARISON_OPERATOR -> . NOT_EQUAL
    (101) COMPARISON_OPERATOR -> . GREATER_THAN
    (102) COMPARISON_OPERATOR -> . LESS_THAN
    (103) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (104) COMPARISON_OPERATOR -> . LESS_EQUAL

    $end            reduce using rule 4 (ROOT -> VALUE .)
    EQUAL_TO        shift and go to state 66
    NOT_EQUAL       shift and go to state 67
    GREATER_THAN    shift and go to state 68
    LESS_THAN       shift and go to state 69
    GREATER_EQUAL   shift and go to state 70
    LESS_EQUAL      shift and go to state 71

    COMPARISON_OPERATOR            shift and go to state 80

state 6

    (5) ROOT -> NUMBER .
    (37) VALUE -> NUMBER .
    (96) OPERATION -> NUMBER . OPERATOR NUMBER
    (111) SENTENCE -> NUMBER .
    (91) OPERATOR -> . PLUS
    (92) OPERATOR -> . MINUS
    (93) OPERATOR -> . TIMES
    (94) OPERATOR -> . MODULUS
    (95) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 5 (ROOT -> NUMBER .)
    $end            reduce using rule 5 (ROOT -> NUMBER .)
    EQUAL_TO        reduce using rule 37 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 37 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 37 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 37 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 37 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 37 (VALUE -> NUMBER .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    MODULUS         shift and go to state 64
    DIVIDE          shift and go to state 65

  ! $end            [ reduce using rule 37 (VALUE -> NUMBER .) ]
  ! $end            [ reduce using rule 111 (SENTENCE -> NUMBER .) ]

    OPERATOR                       shift and go to state 81

state 7

    (6) ROOT -> CONTROL_STRUCTURES .
    (65) EXPRESSION -> CONTROL_STRUCTURES .

  ! reduce/reduce conflict for $end resolved using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    $end            reduce using rule 6 (ROOT -> CONTROL_STRUCTURES .)
    VARNAME         reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    INTEGER         reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)

  ! $end            [ reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .) ]


state 8

    (7) ROOT -> WHILE_STRUCTURE .
    (43) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 7 (ROOT -> WHILE_STRUCTURE .)
    $end            reduce using rule 7 (ROOT -> WHILE_STRUCTURE .)
    VARNAME         reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INTEGER         reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)

  ! $end            [ reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .) ]


state 9

    (8) ROOT -> SWITCH_STRUCTURE .
    (44) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    $end            reduce using rule 8 (ROOT -> SWITCH_STRUCTURE .)
    VARNAME         reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INTEGER         reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)

  ! $end            [ reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .) ]


state 10

    (9) ROOT -> IF_STRUCTURE .
    (41) CONTROL_STRUCTURES -> IF_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 9 (ROOT -> IF_STRUCTURE .)
    $end            reduce using rule 9 (ROOT -> IF_STRUCTURE .)
    VARNAME         reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INTEGER         reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)

  ! $end            [ reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .) ]


state 11

    (10) ROOT -> FOR_STRUCTURE .
    (42) CONTROL_STRUCTURES -> FOR_STRUCTURE .

  ! reduce/reduce conflict for $end resolved using rule 10 (ROOT -> FOR_STRUCTURE .)
    $end            reduce using rule 10 (ROOT -> FOR_STRUCTURE .)
    VARNAME         reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INTEGER         reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)

  ! $end            [ reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .) ]


state 12

    (11) ROOT -> CODE .
    (64) EXPRESSION -> CODE . SEMICOLON

    $end            reduce using rule 11 (ROOT -> CODE .)
    SEMICOLON       shift and go to state 82


state 13

    (12) ROOT -> EXPRESSION .
    (66) EXPRESSIONS -> EXPRESSION .
    (67) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (66) EXPRESSIONS -> . EXPRESSION
    (67) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (64) EXPRESSION -> . CODE SEMICOLON
    (65) EXPRESSION -> . CONTROL_STRUCTURES
    (59) CODE -> . FUNCTION
    (60) CODE -> . INTEGER_DECLARATION
    (61) CODE -> . DECIMAL_DECLARATION
    (62) CODE -> . ASSIGNMENT_DECLARATION
    (63) CODE -> . COMENTARIOLEX
    (41) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (42) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (43) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (44) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (68) FUNCTION -> . VARNAME LPAREN RPAREN
    (74) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (75) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (76) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (89) COMENTARIOLEX -> . COMMENT
    (58) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (57) FOR_STRUCTURE -> . INTEGER
    (48) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (54) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (69) INTEGER_TYPE -> . INT
    (70) INTEGER_TYPE -> . SHORT
    (71) INTEGER_TYPE -> . LONG
    (72) DECIMAL_TYPE -> . FLOAT
    (73) DECIMAL_TYPE -> . DOUBLE

  ! reduce/reduce conflict for $end resolved using rule 12 (ROOT -> EXPRESSION .)
    $end            reduce using rule 12 (ROOT -> EXPRESSION .)
    VARNAME         shift and go to state 96
    COMMENT         shift and go to state 60
    IF              shift and go to state 41
    INTEGER         shift and go to state 98
    WHILE           shift and go to state 39
    SWITCH          shift and go to state 40
    INT             shift and go to state 43
    SHORT           shift and go to state 44
    LONG            shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47

  ! $end            [ reduce using rule 66 (EXPRESSIONS -> EXPRESSION .) ]

    EXPRESSION                     shift and go to state 83
    EXPRESSIONS                    shift and go to state 84
    CODE                           shift and go to state 85
    CONTROL_STRUCTURES             shift and go to state 86
    FUNCTION                       shift and go to state 87
    INTEGER_DECLARATION            shift and go to state 88
    DECIMAL_DECLARATION            shift and go to state 89
    ASSIGNMENT_DECLARATION         shift and go to state 90
    COMENTARIOLEX                  shift and go to state 91
    IF_STRUCTURE                   shift and go to state 92
    FOR_STRUCTURE                  shift and go to state 93
    WHILE_STRUCTURE                shift and go to state 94
    SWITCH_STRUCTURE               shift and go to state 95
    INTEGER_TYPE                   shift and go to state 97
    DECIMAL_TYPE                   shift and go to state 99

state 14

    (13) ROOT -> EXPRESSIONS .

    $end            reduce using rule 13 (ROOT -> EXPRESSIONS .)


state 15

    (14) ROOT -> FUNCTION .
    (59) CODE -> FUNCTION .

  ! reduce/reduce conflict for $end resolved using rule 14 (ROOT -> FUNCTION .)
    $end            reduce using rule 14 (ROOT -> FUNCTION .)
    SEMICOLON       reduce using rule 59 (CODE -> FUNCTION .)

  ! $end            [ reduce using rule 59 (CODE -> FUNCTION .) ]


state 16

    (15) ROOT -> INTEGER_TYPE .
    (74) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    $end            reduce using rule 15 (ROOT -> INTEGER_TYPE .)
    VARNAME         shift and go to state 100


state 17

    (16) ROOT -> DECIMAL_TYPE .
    (75) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    $end            reduce using rule 16 (ROOT -> DECIMAL_TYPE .)
    VARNAME         shift and go to state 101


state 18

    (17) ROOT -> INTEGER_DECLARATION .
    (60) CODE -> INTEGER_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 17 (ROOT -> INTEGER_DECLARATION .)
    $end            reduce using rule 17 (ROOT -> INTEGER_DECLARATION .)
    SEMICOLON       reduce using rule 60 (CODE -> INTEGER_DECLARATION .)

  ! $end            [ reduce using rule 60 (CODE -> INTEGER_DECLARATION .) ]


state 19

    (18) ROOT -> DECIMAL_DECLARATION .
    (61) CODE -> DECIMAL_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    $end            reduce using rule 18 (ROOT -> DECIMAL_DECLARATION .)
    SEMICOLON       reduce using rule 61 (CODE -> DECIMAL_DECLARATION .)

  ! $end            [ reduce using rule 61 (CODE -> DECIMAL_DECLARATION .) ]


state 20

    (19) ROOT -> ASSIGNMENT_DECLARATION .
    (62) CODE -> ASSIGNMENT_DECLARATION .

  ! reduce/reduce conflict for $end resolved using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    $end            reduce using rule 19 (ROOT -> ASSIGNMENT_DECLARATION .)
    SEMICOLON       reduce using rule 62 (CODE -> ASSIGNMENT_DECLARATION .)

  ! $end            [ reduce using rule 62 (CODE -> ASSIGNMENT_DECLARATION .) ]


state 21

    (20) ROOT -> ASSIGNMENT_OPERATOR .

    $end            reduce using rule 20 (ROOT -> ASSIGNMENT_OPERATOR .)


state 22

    (21) ROOT -> COMENTARIOLEX .
    (63) CODE -> COMENTARIOLEX .

  ! reduce/reduce conflict for $end resolved using rule 21 (ROOT -> COMENTARIOLEX .)
    $end            reduce using rule 21 (ROOT -> COMENTARIOLEX .)
    SEMICOLON       reduce using rule 63 (CODE -> COMENTARIOLEX .)

  ! $end            [ reduce using rule 63 (CODE -> COMENTARIOLEX .) ]


state 23

    (22) ROOT -> VARIABLELEX .
    (55) BUCLE -> VARIABLELEX . INCREASE

    $end            reduce using rule 22 (ROOT -> VARIABLELEX .)
    INCREASE        shift and go to state 102


state 24

    (23) ROOT -> OPERATOR .

    $end            reduce using rule 23 (ROOT -> OPERATOR .)


state 25

    (24) ROOT -> OPERATION .
    (97) OPERATIONS -> OPERATION .
    (98) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (91) OPERATOR -> . PLUS
    (92) OPERATOR -> . MINUS
    (93) OPERATOR -> . TIMES
    (94) OPERATOR -> . MODULUS
    (95) OPERATOR -> . DIVIDE

  ! reduce/reduce conflict for $end resolved using rule 24 (ROOT -> OPERATION .)
    $end            reduce using rule 24 (ROOT -> OPERATION .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    MODULUS         shift and go to state 64
    DIVIDE          shift and go to state 65

  ! $end            [ reduce using rule 97 (OPERATIONS -> OPERATION .) ]

    OPERATOR                       shift and go to state 103

state 26

    (25) ROOT -> OPERATIONS .

    $end            reduce using rule 25 (ROOT -> OPERATIONS .)


state 27

    (26) ROOT -> COMPARISON_OPERATOR .

    $end            reduce using rule 26 (ROOT -> COMPARISON_OPERATOR .)


state 28

    (27) ROOT -> COMPARISON .
    (106) COMPARISONS -> COMPARISON .
    (107) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (108) LOGICAL_OPERATOR -> . AND
    (109) LOGICAL_OPERATOR -> . OR
    (110) LOGICAL_OPERATOR -> . NOT

  ! reduce/reduce conflict for $end resolved using rule 27 (ROOT -> COMPARISON .)
    $end            reduce using rule 27 (ROOT -> COMPARISON .)
    AND             shift and go to state 72
    OR              shift and go to state 73
    NOT             shift and go to state 74

  ! $end            [ reduce using rule 106 (COMPARISONS -> COMPARISON .) ]

    LOGICAL_OPERATOR               shift and go to state 104

state 29

    (28) ROOT -> COMPARISONS .

    $end            reduce using rule 28 (ROOT -> COMPARISONS .)


state 30

    (29) ROOT -> LOGICAL_OPERATOR .

    $end            reduce using rule 29 (ROOT -> LOGICAL_OPERATOR .)


state 31

    (30) ROOT -> SENTENCE .

    $end            reduce using rule 30 (ROOT -> SENTENCE .)


state 32

    (31) ROOT -> SWITCH_BODY .

    $end            reduce using rule 31 (ROOT -> SWITCH_BODY .)


state 33

    (32) ROOT -> BUCLE .

    $end            reduce using rule 32 (ROOT -> BUCLE .)


state 34

    (35) DEFINE -> PP_DEFINE . VARIABLELEX VALUE
    (90) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 106

    VARIABLELEX                    shift and go to state 105

state 35

    (36) INCLUDE -> PP_INCLUDE . HEADER_LIB

    HEADER_LIB      shift and go to state 107


state 36

    (38) VALUE -> STRING .

    EQUAL_TO        reduce using rule 38 (VALUE -> STRING .)
    NOT_EQUAL       reduce using rule 38 (VALUE -> STRING .)
    GREATER_THAN    reduce using rule 38 (VALUE -> STRING .)
    LESS_THAN       reduce using rule 38 (VALUE -> STRING .)
    GREATER_EQUAL   reduce using rule 38 (VALUE -> STRING .)
    LESS_EQUAL      reduce using rule 38 (VALUE -> STRING .)
    $end            reduce using rule 38 (VALUE -> STRING .)
    AND             reduce using rule 38 (VALUE -> STRING .)
    OR              reduce using rule 38 (VALUE -> STRING .)
    NOT             reduce using rule 38 (VALUE -> STRING .)
    RPAREN          reduce using rule 38 (VALUE -> STRING .)


state 37

    (39) NUMBER -> INTEGER .
    (57) FOR_STRUCTURE -> INTEGER .

  ! reduce/reduce conflict for $end resolved using rule 39 (NUMBER -> INTEGER .)
    PLUS            reduce using rule 39 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 39 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 39 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 39 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 39 (NUMBER -> INTEGER .)
    $end            reduce using rule 39 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 39 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 39 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 39 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 39 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 39 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 39 (NUMBER -> INTEGER .)
    VARNAME         reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    COMMENT         reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    IF              reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    INTEGER         reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    WHILE           reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    SWITCH          reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    INT             reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    SHORT           reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    LONG            reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    FLOAT           reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    DOUBLE          reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)

  ! $end            [ reduce using rule 57 (FOR_STRUCTURE -> INTEGER .) ]


state 38

    (40) NUMBER -> DECIMAL .

    PLUS            reduce using rule 40 (NUMBER -> DECIMAL .)
    MINUS           reduce using rule 40 (NUMBER -> DECIMAL .)
    TIMES           reduce using rule 40 (NUMBER -> DECIMAL .)
    MODULUS         reduce using rule 40 (NUMBER -> DECIMAL .)
    DIVIDE          reduce using rule 40 (NUMBER -> DECIMAL .)
    $end            reduce using rule 40 (NUMBER -> DECIMAL .)
    EQUAL_TO        reduce using rule 40 (NUMBER -> DECIMAL .)
    NOT_EQUAL       reduce using rule 40 (NUMBER -> DECIMAL .)
    GREATER_THAN    reduce using rule 40 (NUMBER -> DECIMAL .)
    LESS_THAN       reduce using rule 40 (NUMBER -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 40 (NUMBER -> DECIMAL .)
    LESS_EQUAL      reduce using rule 40 (NUMBER -> DECIMAL .)
    AND             reduce using rule 40 (NUMBER -> DECIMAL .)
    OR              reduce using rule 40 (NUMBER -> DECIMAL .)
    NOT             reduce using rule 40 (NUMBER -> DECIMAL .)
    RPAREN          reduce using rule 40 (NUMBER -> DECIMAL .)
    SEMICOLON       reduce using rule 40 (NUMBER -> DECIMAL .)


state 39

    (48) WHILE_STRUCTURE -> WHILE . LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LPAREN          shift and go to state 108


state 40

    (54) SWITCH_STRUCTURE -> SWITCH . LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LPAREN          shift and go to state 109


state 41

    (58) IF_STRUCTURE -> IF . LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE

    LPAREN          shift and go to state 110


state 42

    (68) FUNCTION -> VARNAME . LPAREN RPAREN
    (76) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (90) VARIABLELEX -> VARNAME .
    (112) SENTENCE -> VARNAME .
    (77) ASSIGNMENT_OPERATOR -> . EQUAL
    (78) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (79) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (80) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (81) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (82) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (83) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (84) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (85) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (86) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (87) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (88) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

  ! reduce/reduce conflict for $end resolved using rule 90 (VARIABLELEX -> VARNAME .)
    LPAREN          shift and go to state 111
    INCREASE        reduce using rule 90 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 90 (VARIABLELEX -> VARNAME .)
    EQUAL           shift and go to state 48
    PLUS_EQUAL      shift and go to state 49
    MINUS_EQUAL     shift and go to state 50
    DIV_EQUAL       shift and go to state 51
    TIMES_EQUAL     shift and go to state 52
    MOD_EQUAL       shift and go to state 53
    AND_EQUAL       shift and go to state 54
    OR_EQUAL        shift and go to state 55
    XOR_EQUAL       shift and go to state 56
    COMPLEMENT_EQUAL shift and go to state 57
    SHIFTL_EQUAL    shift and go to state 58
    SHIFTR_EQUAL    shift and go to state 59

  ! $end            [ reduce using rule 112 (SENTENCE -> VARNAME .) ]

    ASSIGNMENT_OPERATOR            shift and go to state 112

state 43

    (69) INTEGER_TYPE -> INT .

    VARNAME         reduce using rule 69 (INTEGER_TYPE -> INT .)
    $end            reduce using rule 69 (INTEGER_TYPE -> INT .)


state 44

    (70) INTEGER_TYPE -> SHORT .

    VARNAME         reduce using rule 70 (INTEGER_TYPE -> SHORT .)
    $end            reduce using rule 70 (INTEGER_TYPE -> SHORT .)


state 45

    (71) INTEGER_TYPE -> LONG .

    VARNAME         reduce using rule 71 (INTEGER_TYPE -> LONG .)
    $end            reduce using rule 71 (INTEGER_TYPE -> LONG .)


state 46

    (72) DECIMAL_TYPE -> FLOAT .

    VARNAME         reduce using rule 72 (DECIMAL_TYPE -> FLOAT .)
    $end            reduce using rule 72 (DECIMAL_TYPE -> FLOAT .)


state 47

    (73) DECIMAL_TYPE -> DOUBLE .

    VARNAME         reduce using rule 73 (DECIMAL_TYPE -> DOUBLE .)
    $end            reduce using rule 73 (DECIMAL_TYPE -> DOUBLE .)


state 48

    (77) ASSIGNMENT_OPERATOR -> EQUAL .

    $end            reduce using rule 77 (ASSIGNMENT_OPERATOR -> EQUAL .)
    VARNAME         reduce using rule 77 (ASSIGNMENT_OPERATOR -> EQUAL .)
    INTEGER         reduce using rule 77 (ASSIGNMENT_OPERATOR -> EQUAL .)
    DECIMAL         reduce using rule 77 (ASSIGNMENT_OPERATOR -> EQUAL .)


state 49

    (78) ASSIGNMENT_OPERATOR -> PLUS_EQUAL .

    $end            reduce using rule 78 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    VARNAME         reduce using rule 78 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    INTEGER         reduce using rule 78 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)
    DECIMAL         reduce using rule 78 (ASSIGNMENT_OPERATOR -> PLUS_EQUAL .)


state 50

    (79) ASSIGNMENT_OPERATOR -> MINUS_EQUAL .

    $end            reduce using rule 79 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    VARNAME         reduce using rule 79 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    INTEGER         reduce using rule 79 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)
    DECIMAL         reduce using rule 79 (ASSIGNMENT_OPERATOR -> MINUS_EQUAL .)


state 51

    (80) ASSIGNMENT_OPERATOR -> DIV_EQUAL .

    $end            reduce using rule 80 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    VARNAME         reduce using rule 80 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    INTEGER         reduce using rule 80 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)
    DECIMAL         reduce using rule 80 (ASSIGNMENT_OPERATOR -> DIV_EQUAL .)


state 52

    (81) ASSIGNMENT_OPERATOR -> TIMES_EQUAL .

    $end            reduce using rule 81 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    VARNAME         reduce using rule 81 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    INTEGER         reduce using rule 81 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)
    DECIMAL         reduce using rule 81 (ASSIGNMENT_OPERATOR -> TIMES_EQUAL .)


state 53

    (82) ASSIGNMENT_OPERATOR -> MOD_EQUAL .

    $end            reduce using rule 82 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    VARNAME         reduce using rule 82 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    INTEGER         reduce using rule 82 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)
    DECIMAL         reduce using rule 82 (ASSIGNMENT_OPERATOR -> MOD_EQUAL .)


state 54

    (83) ASSIGNMENT_OPERATOR -> AND_EQUAL .

    $end            reduce using rule 83 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    VARNAME         reduce using rule 83 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    INTEGER         reduce using rule 83 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)
    DECIMAL         reduce using rule 83 (ASSIGNMENT_OPERATOR -> AND_EQUAL .)


state 55

    (84) ASSIGNMENT_OPERATOR -> OR_EQUAL .

    $end            reduce using rule 84 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    VARNAME         reduce using rule 84 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    INTEGER         reduce using rule 84 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)
    DECIMAL         reduce using rule 84 (ASSIGNMENT_OPERATOR -> OR_EQUAL .)


state 56

    (85) ASSIGNMENT_OPERATOR -> XOR_EQUAL .

    $end            reduce using rule 85 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    VARNAME         reduce using rule 85 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    INTEGER         reduce using rule 85 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)
    DECIMAL         reduce using rule 85 (ASSIGNMENT_OPERATOR -> XOR_EQUAL .)


state 57

    (86) ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .

    $end            reduce using rule 86 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    VARNAME         reduce using rule 86 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    INTEGER         reduce using rule 86 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)
    DECIMAL         reduce using rule 86 (ASSIGNMENT_OPERATOR -> COMPLEMENT_EQUAL .)


state 58

    (87) ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .

    $end            reduce using rule 87 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    VARNAME         reduce using rule 87 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    INTEGER         reduce using rule 87 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)
    DECIMAL         reduce using rule 87 (ASSIGNMENT_OPERATOR -> SHIFTL_EQUAL .)


state 59

    (88) ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .

    $end            reduce using rule 88 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    VARNAME         reduce using rule 88 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    INTEGER         reduce using rule 88 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)
    DECIMAL         reduce using rule 88 (ASSIGNMENT_OPERATOR -> SHIFTR_EQUAL .)


state 60

    (89) COMENTARIOLEX -> COMMENT .

    $end            reduce using rule 89 (COMENTARIOLEX -> COMMENT .)
    SEMICOLON       reduce using rule 89 (COMENTARIOLEX -> COMMENT .)


state 61

    (91) OPERATOR -> PLUS .

    $end            reduce using rule 91 (OPERATOR -> PLUS .)
    INTEGER         reduce using rule 91 (OPERATOR -> PLUS .)
    DECIMAL         reduce using rule 91 (OPERATOR -> PLUS .)


state 62

    (92) OPERATOR -> MINUS .

    $end            reduce using rule 92 (OPERATOR -> MINUS .)
    INTEGER         reduce using rule 92 (OPERATOR -> MINUS .)
    DECIMAL         reduce using rule 92 (OPERATOR -> MINUS .)


state 63

    (93) OPERATOR -> TIMES .

    $end            reduce using rule 93 (OPERATOR -> TIMES .)
    INTEGER         reduce using rule 93 (OPERATOR -> TIMES .)
    DECIMAL         reduce using rule 93 (OPERATOR -> TIMES .)


state 64

    (94) OPERATOR -> MODULUS .

    $end            reduce using rule 94 (OPERATOR -> MODULUS .)
    INTEGER         reduce using rule 94 (OPERATOR -> MODULUS .)
    DECIMAL         reduce using rule 94 (OPERATOR -> MODULUS .)


state 65

    (95) OPERATOR -> DIVIDE .

    $end            reduce using rule 95 (OPERATOR -> DIVIDE .)
    INTEGER         reduce using rule 95 (OPERATOR -> DIVIDE .)
    DECIMAL         reduce using rule 95 (OPERATOR -> DIVIDE .)


state 66

    (99) COMPARISON_OPERATOR -> EQUAL_TO .

    $end            reduce using rule 99 (COMPARISON_OPERATOR -> EQUAL_TO .)
    STRING          reduce using rule 99 (COMPARISON_OPERATOR -> EQUAL_TO .)
    INTEGER         reduce using rule 99 (COMPARISON_OPERATOR -> EQUAL_TO .)
    DECIMAL         reduce using rule 99 (COMPARISON_OPERATOR -> EQUAL_TO .)


state 67

    (100) COMPARISON_OPERATOR -> NOT_EQUAL .

    $end            reduce using rule 100 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    STRING          reduce using rule 100 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    INTEGER         reduce using rule 100 (COMPARISON_OPERATOR -> NOT_EQUAL .)
    DECIMAL         reduce using rule 100 (COMPARISON_OPERATOR -> NOT_EQUAL .)


state 68

    (101) COMPARISON_OPERATOR -> GREATER_THAN .

    $end            reduce using rule 101 (COMPARISON_OPERATOR -> GREATER_THAN .)
    STRING          reduce using rule 101 (COMPARISON_OPERATOR -> GREATER_THAN .)
    INTEGER         reduce using rule 101 (COMPARISON_OPERATOR -> GREATER_THAN .)
    DECIMAL         reduce using rule 101 (COMPARISON_OPERATOR -> GREATER_THAN .)


state 69

    (102) COMPARISON_OPERATOR -> LESS_THAN .

    $end            reduce using rule 102 (COMPARISON_OPERATOR -> LESS_THAN .)
    STRING          reduce using rule 102 (COMPARISON_OPERATOR -> LESS_THAN .)
    INTEGER         reduce using rule 102 (COMPARISON_OPERATOR -> LESS_THAN .)
    DECIMAL         reduce using rule 102 (COMPARISON_OPERATOR -> LESS_THAN .)


state 70

    (103) COMPARISON_OPERATOR -> GREATER_EQUAL .

    $end            reduce using rule 103 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    STRING          reduce using rule 103 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    INTEGER         reduce using rule 103 (COMPARISON_OPERATOR -> GREATER_EQUAL .)
    DECIMAL         reduce using rule 103 (COMPARISON_OPERATOR -> GREATER_EQUAL .)


state 71

    (104) COMPARISON_OPERATOR -> LESS_EQUAL .

    $end            reduce using rule 104 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    STRING          reduce using rule 104 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    INTEGER         reduce using rule 104 (COMPARISON_OPERATOR -> LESS_EQUAL .)
    DECIMAL         reduce using rule 104 (COMPARISON_OPERATOR -> LESS_EQUAL .)


state 72

    (108) LOGICAL_OPERATOR -> AND .

    $end            reduce using rule 108 (LOGICAL_OPERATOR -> AND .)
    STRING          reduce using rule 108 (LOGICAL_OPERATOR -> AND .)
    INTEGER         reduce using rule 108 (LOGICAL_OPERATOR -> AND .)
    DECIMAL         reduce using rule 108 (LOGICAL_OPERATOR -> AND .)


state 73

    (109) LOGICAL_OPERATOR -> OR .

    $end            reduce using rule 109 (LOGICAL_OPERATOR -> OR .)
    STRING          reduce using rule 109 (LOGICAL_OPERATOR -> OR .)
    INTEGER         reduce using rule 109 (LOGICAL_OPERATOR -> OR .)
    DECIMAL         reduce using rule 109 (LOGICAL_OPERATOR -> OR .)


state 74

    (110) LOGICAL_OPERATOR -> NOT .

    $end            reduce using rule 110 (LOGICAL_OPERATOR -> NOT .)
    STRING          reduce using rule 110 (LOGICAL_OPERATOR -> NOT .)
    INTEGER         reduce using rule 110 (LOGICAL_OPERATOR -> NOT .)
    DECIMAL         reduce using rule 110 (LOGICAL_OPERATOR -> NOT .)


state 75

    (51) SWITCH_BODY -> SWITCH_CASE .
    (53) SWITCH_BODY -> SWITCH_CASE . SWITCH_BODY
    (51) SWITCH_BODY -> . SWITCH_CASE
    (52) SWITCH_BODY -> . SWITCH_DEFAULT
    (53) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (49) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (50) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    $end            reduce using rule 51 (SWITCH_BODY -> SWITCH_CASE .)
    RCURL_BRACE     reduce using rule 51 (SWITCH_BODY -> SWITCH_CASE .)
    CASE            shift and go to state 78
    DEFAULT         shift and go to state 79

    SWITCH_CASE                    shift and go to state 75
    SWITCH_BODY                    shift and go to state 113
    SWITCH_DEFAULT                 shift and go to state 76

state 76

    (52) SWITCH_BODY -> SWITCH_DEFAULT .

    $end            reduce using rule 52 (SWITCH_BODY -> SWITCH_DEFAULT .)
    RCURL_BRACE     reduce using rule 52 (SWITCH_BODY -> SWITCH_DEFAULT .)


state 77

    (56) BUCLE -> DECREASE . VARIABLELEX
    (90) VARIABLELEX -> . VARNAME

    VARNAME         shift and go to state 106

    VARIABLELEX                    shift and go to state 114

state 78

    (49) SWITCH_CASE -> CASE . INTEGER COLON EXPRESSIONS BREAK SEMICOLON

    INTEGER         shift and go to state 115


state 79

    (50) SWITCH_DEFAULT -> DEFAULT . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 116


state 80

    (105) COMPARISON -> VALUE COMPARISON_OPERATOR . VALUE
    (37) VALUE -> . NUMBER
    (38) VALUE -> . STRING
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL

    STRING          shift and go to state 36
    INTEGER         shift and go to state 119
    DECIMAL         shift and go to state 38

    VALUE                          shift and go to state 117
    NUMBER                         shift and go to state 118

state 81

    (96) OPERATION -> NUMBER OPERATOR . NUMBER
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 119
    DECIMAL         shift and go to state 38

    NUMBER                         shift and go to state 120

state 82

    (64) EXPRESSION -> CODE SEMICOLON .

    VARNAME         reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    COMMENT         reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    IF              reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    INTEGER         reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    WHILE           reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    SWITCH          reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    INT             reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    SHORT           reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    LONG            reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    FLOAT           reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    DOUBLE          reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    $end            reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    BREAK           reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    CONTINUE        reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)
    RCURL_BRACE     reduce using rule 64 (EXPRESSION -> CODE SEMICOLON .)


state 83

    (66) EXPRESSIONS -> EXPRESSION .
    (67) EXPRESSIONS -> EXPRESSION . EXPRESSIONS
    (66) EXPRESSIONS -> . EXPRESSION
    (67) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (64) EXPRESSION -> . CODE SEMICOLON
    (65) EXPRESSION -> . CONTROL_STRUCTURES
    (59) CODE -> . FUNCTION
    (60) CODE -> . INTEGER_DECLARATION
    (61) CODE -> . DECIMAL_DECLARATION
    (62) CODE -> . ASSIGNMENT_DECLARATION
    (63) CODE -> . COMENTARIOLEX
    (41) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (42) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (43) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (44) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (68) FUNCTION -> . VARNAME LPAREN RPAREN
    (74) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (75) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (76) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (89) COMENTARIOLEX -> . COMMENT
    (58) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (57) FOR_STRUCTURE -> . INTEGER
    (48) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (54) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (69) INTEGER_TYPE -> . INT
    (70) INTEGER_TYPE -> . SHORT
    (71) INTEGER_TYPE -> . LONG
    (72) DECIMAL_TYPE -> . FLOAT
    (73) DECIMAL_TYPE -> . DOUBLE

    $end            reduce using rule 66 (EXPRESSIONS -> EXPRESSION .)
    BREAK           reduce using rule 66 (EXPRESSIONS -> EXPRESSION .)
    CONTINUE        reduce using rule 66 (EXPRESSIONS -> EXPRESSION .)
    RCURL_BRACE     reduce using rule 66 (EXPRESSIONS -> EXPRESSION .)
    VARNAME         shift and go to state 96
    COMMENT         shift and go to state 60
    IF              shift and go to state 41
    INTEGER         shift and go to state 98
    WHILE           shift and go to state 39
    SWITCH          shift and go to state 40
    INT             shift and go to state 43
    SHORT           shift and go to state 44
    LONG            shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47

    EXPRESSION                     shift and go to state 83
    EXPRESSIONS                    shift and go to state 84
    CODE                           shift and go to state 85
    CONTROL_STRUCTURES             shift and go to state 86
    FUNCTION                       shift and go to state 87
    INTEGER_DECLARATION            shift and go to state 88
    DECIMAL_DECLARATION            shift and go to state 89
    ASSIGNMENT_DECLARATION         shift and go to state 90
    COMENTARIOLEX                  shift and go to state 91
    IF_STRUCTURE                   shift and go to state 92
    FOR_STRUCTURE                  shift and go to state 93
    WHILE_STRUCTURE                shift and go to state 94
    SWITCH_STRUCTURE               shift and go to state 95
    INTEGER_TYPE                   shift and go to state 97
    DECIMAL_TYPE                   shift and go to state 99

state 84

    (67) EXPRESSIONS -> EXPRESSION EXPRESSIONS .

    $end            reduce using rule 67 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    BREAK           reduce using rule 67 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    CONTINUE        reduce using rule 67 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)
    RCURL_BRACE     reduce using rule 67 (EXPRESSIONS -> EXPRESSION EXPRESSIONS .)


state 85

    (64) EXPRESSION -> CODE . SEMICOLON

    SEMICOLON       shift and go to state 82


state 86

    (65) EXPRESSION -> CONTROL_STRUCTURES .

    VARNAME         reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    COMMENT         reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    IF              reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    INTEGER         reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    WHILE           reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    SWITCH          reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    INT             reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    SHORT           reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    LONG            reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    FLOAT           reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    DOUBLE          reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    $end            reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    BREAK           reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    CONTINUE        reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)
    RCURL_BRACE     reduce using rule 65 (EXPRESSION -> CONTROL_STRUCTURES .)


state 87

    (59) CODE -> FUNCTION .

    SEMICOLON       reduce using rule 59 (CODE -> FUNCTION .)


state 88

    (60) CODE -> INTEGER_DECLARATION .

    SEMICOLON       reduce using rule 60 (CODE -> INTEGER_DECLARATION .)


state 89

    (61) CODE -> DECIMAL_DECLARATION .

    SEMICOLON       reduce using rule 61 (CODE -> DECIMAL_DECLARATION .)


state 90

    (62) CODE -> ASSIGNMENT_DECLARATION .

    SEMICOLON       reduce using rule 62 (CODE -> ASSIGNMENT_DECLARATION .)


state 91

    (63) CODE -> COMENTARIOLEX .

    SEMICOLON       reduce using rule 63 (CODE -> COMENTARIOLEX .)


state 92

    (41) CONTROL_STRUCTURES -> IF_STRUCTURE .

    VARNAME         reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    COMMENT         reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    IF              reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INTEGER         reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    WHILE           reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SWITCH          reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    INT             reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    SHORT           reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    LONG            reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    FLOAT           reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    DOUBLE          reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    $end            reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    BREAK           reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    CONTINUE        reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)
    RCURL_BRACE     reduce using rule 41 (CONTROL_STRUCTURES -> IF_STRUCTURE .)


state 93

    (42) CONTROL_STRUCTURES -> FOR_STRUCTURE .

    VARNAME         reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    COMMENT         reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    IF              reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INTEGER         reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    WHILE           reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SWITCH          reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    INT             reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    SHORT           reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    LONG            reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    FLOAT           reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    DOUBLE          reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    $end            reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    BREAK           reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    CONTINUE        reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)
    RCURL_BRACE     reduce using rule 42 (CONTROL_STRUCTURES -> FOR_STRUCTURE .)


state 94

    (43) CONTROL_STRUCTURES -> WHILE_STRUCTURE .

    VARNAME         reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    COMMENT         reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    IF              reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INTEGER         reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    WHILE           reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SWITCH          reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    INT             reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    SHORT           reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    LONG            reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    FLOAT           reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    DOUBLE          reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    $end            reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    BREAK           reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    CONTINUE        reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)
    RCURL_BRACE     reduce using rule 43 (CONTROL_STRUCTURES -> WHILE_STRUCTURE .)


state 95

    (44) CONTROL_STRUCTURES -> SWITCH_STRUCTURE .

    VARNAME         reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    COMMENT         reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    IF              reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INTEGER         reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    WHILE           reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SWITCH          reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    INT             reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    SHORT           reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    LONG            reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    FLOAT           reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    DOUBLE          reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    $end            reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    BREAK           reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    CONTINUE        reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)
    RCURL_BRACE     reduce using rule 44 (CONTROL_STRUCTURES -> SWITCH_STRUCTURE .)


state 96

    (68) FUNCTION -> VARNAME . LPAREN RPAREN
    (76) ASSIGNMENT_DECLARATION -> VARNAME . ASSIGNMENT_OPERATOR SENTENCE
    (77) ASSIGNMENT_OPERATOR -> . EQUAL
    (78) ASSIGNMENT_OPERATOR -> . PLUS_EQUAL
    (79) ASSIGNMENT_OPERATOR -> . MINUS_EQUAL
    (80) ASSIGNMENT_OPERATOR -> . DIV_EQUAL
    (81) ASSIGNMENT_OPERATOR -> . TIMES_EQUAL
    (82) ASSIGNMENT_OPERATOR -> . MOD_EQUAL
    (83) ASSIGNMENT_OPERATOR -> . AND_EQUAL
    (84) ASSIGNMENT_OPERATOR -> . OR_EQUAL
    (85) ASSIGNMENT_OPERATOR -> . XOR_EQUAL
    (86) ASSIGNMENT_OPERATOR -> . COMPLEMENT_EQUAL
    (87) ASSIGNMENT_OPERATOR -> . SHIFTL_EQUAL
    (88) ASSIGNMENT_OPERATOR -> . SHIFTR_EQUAL

    LPAREN          shift and go to state 111
    EQUAL           shift and go to state 48
    PLUS_EQUAL      shift and go to state 49
    MINUS_EQUAL     shift and go to state 50
    DIV_EQUAL       shift and go to state 51
    TIMES_EQUAL     shift and go to state 52
    MOD_EQUAL       shift and go to state 53
    AND_EQUAL       shift and go to state 54
    OR_EQUAL        shift and go to state 55
    XOR_EQUAL       shift and go to state 56
    COMPLEMENT_EQUAL shift and go to state 57
    SHIFTL_EQUAL    shift and go to state 58
    SHIFTR_EQUAL    shift and go to state 59

    ASSIGNMENT_OPERATOR            shift and go to state 112

state 97

    (74) INTEGER_DECLARATION -> INTEGER_TYPE . VARNAME EQUAL INTEGER

    VARNAME         shift and go to state 100


state 98

    (57) FOR_STRUCTURE -> INTEGER .

    VARNAME         reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    COMMENT         reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    IF              reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    INTEGER         reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    WHILE           reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    SWITCH          reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    INT             reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    SHORT           reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    LONG            reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    FLOAT           reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    DOUBLE          reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    $end            reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    BREAK           reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    CONTINUE        reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)
    RCURL_BRACE     reduce using rule 57 (FOR_STRUCTURE -> INTEGER .)


state 99

    (75) DECIMAL_DECLARATION -> DECIMAL_TYPE . VARNAME EQUAL DECIMAL

    VARNAME         shift and go to state 101


state 100

    (74) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME . EQUAL INTEGER

    EQUAL           shift and go to state 121


state 101

    (75) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME . EQUAL DECIMAL

    EQUAL           shift and go to state 122


state 102

    (55) BUCLE -> VARIABLELEX INCREASE .

    $end            reduce using rule 55 (BUCLE -> VARIABLELEX INCREASE .)


state 103

    (98) OPERATIONS -> OPERATION OPERATOR . OPERATIONS
    (97) OPERATIONS -> . OPERATION
    (98) OPERATIONS -> . OPERATION OPERATOR OPERATIONS
    (96) OPERATION -> . NUMBER OPERATOR NUMBER
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL

    INTEGER         shift and go to state 119
    DECIMAL         shift and go to state 38

    OPERATION                      shift and go to state 123
    OPERATIONS                     shift and go to state 124
    NUMBER                         shift and go to state 125

state 104

    (107) COMPARISONS -> COMPARISON LOGICAL_OPERATOR . COMPARISONS
    (106) COMPARISONS -> . COMPARISON
    (107) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (105) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (37) VALUE -> . NUMBER
    (38) VALUE -> . STRING
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL

    STRING          shift and go to state 36
    INTEGER         shift and go to state 119
    DECIMAL         shift and go to state 38

    COMPARISON                     shift and go to state 126
    COMPARISONS                    shift and go to state 127
    VALUE                          shift and go to state 128
    NUMBER                         shift and go to state 118

state 105

    (35) DEFINE -> PP_DEFINE VARIABLELEX . VALUE
    (37) VALUE -> . NUMBER
    (38) VALUE -> . STRING
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL

    STRING          shift and go to state 36
    INTEGER         shift and go to state 119
    DECIMAL         shift and go to state 38

    VALUE                          shift and go to state 129
    NUMBER                         shift and go to state 118

state 106

    (90) VARIABLELEX -> VARNAME .

    STRING          reduce using rule 90 (VARIABLELEX -> VARNAME .)
    INTEGER         reduce using rule 90 (VARIABLELEX -> VARNAME .)
    DECIMAL         reduce using rule 90 (VARIABLELEX -> VARNAME .)
    $end            reduce using rule 90 (VARIABLELEX -> VARNAME .)


state 107

    (36) INCLUDE -> PP_INCLUDE HEADER_LIB .

    $end            reduce using rule 36 (INCLUDE -> PP_INCLUDE HEADER_LIB .)


state 108

    (48) WHILE_STRUCTURE -> WHILE LPAREN . COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (106) COMPARISONS -> . COMPARISON
    (107) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (105) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (37) VALUE -> . NUMBER
    (38) VALUE -> . STRING
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL

    STRING          shift and go to state 36
    INTEGER         shift and go to state 119
    DECIMAL         shift and go to state 38

    COMPARISONS                    shift and go to state 130
    COMPARISON                     shift and go to state 126
    VALUE                          shift and go to state 128
    NUMBER                         shift and go to state 118

state 109

    (54) SWITCH_STRUCTURE -> SWITCH LPAREN . COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (106) COMPARISONS -> . COMPARISON
    (107) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (105) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (37) VALUE -> . NUMBER
    (38) VALUE -> . STRING
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL

    STRING          shift and go to state 36
    INTEGER         shift and go to state 119
    DECIMAL         shift and go to state 38

    COMPARISONS                    shift and go to state 131
    COMPARISON                     shift and go to state 126
    VALUE                          shift and go to state 128
    NUMBER                         shift and go to state 118

state 110

    (58) IF_STRUCTURE -> IF LPAREN . COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (106) COMPARISONS -> . COMPARISON
    (107) COMPARISONS -> . COMPARISON LOGICAL_OPERATOR COMPARISONS
    (105) COMPARISON -> . VALUE COMPARISON_OPERATOR VALUE
    (37) VALUE -> . NUMBER
    (38) VALUE -> . STRING
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL

    STRING          shift and go to state 36
    INTEGER         shift and go to state 119
    DECIMAL         shift and go to state 38

    COMPARISONS                    shift and go to state 132
    COMPARISON                     shift and go to state 126
    VALUE                          shift and go to state 128
    NUMBER                         shift and go to state 118

state 111

    (68) FUNCTION -> VARNAME LPAREN . RPAREN

    RPAREN          shift and go to state 133


state 112

    (76) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR . SENTENCE
    (111) SENTENCE -> . NUMBER
    (112) SENTENCE -> . VARNAME
    (39) NUMBER -> . INTEGER
    (40) NUMBER -> . DECIMAL

    VARNAME         shift and go to state 134
    INTEGER         shift and go to state 119
    DECIMAL         shift and go to state 38

    SENTENCE                       shift and go to state 135
    NUMBER                         shift and go to state 136

state 113

    (53) SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .

    $end            reduce using rule 53 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)
    RCURL_BRACE     reduce using rule 53 (SWITCH_BODY -> SWITCH_CASE SWITCH_BODY .)


state 114

    (56) BUCLE -> DECREASE VARIABLELEX .

    $end            reduce using rule 56 (BUCLE -> DECREASE VARIABLELEX .)


state 115

    (49) SWITCH_CASE -> CASE INTEGER . COLON EXPRESSIONS BREAK SEMICOLON

    COLON           shift and go to state 137


state 116

    (50) SWITCH_DEFAULT -> DEFAULT COLON . EXPRESSIONS BREAK SEMICOLON
    (66) EXPRESSIONS -> . EXPRESSION
    (67) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (64) EXPRESSION -> . CODE SEMICOLON
    (65) EXPRESSION -> . CONTROL_STRUCTURES
    (59) CODE -> . FUNCTION
    (60) CODE -> . INTEGER_DECLARATION
    (61) CODE -> . DECIMAL_DECLARATION
    (62) CODE -> . ASSIGNMENT_DECLARATION
    (63) CODE -> . COMENTARIOLEX
    (41) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (42) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (43) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (44) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (68) FUNCTION -> . VARNAME LPAREN RPAREN
    (74) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (75) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (76) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (89) COMENTARIOLEX -> . COMMENT
    (58) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (57) FOR_STRUCTURE -> . INTEGER
    (48) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (54) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (69) INTEGER_TYPE -> . INT
    (70) INTEGER_TYPE -> . SHORT
    (71) INTEGER_TYPE -> . LONG
    (72) DECIMAL_TYPE -> . FLOAT
    (73) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 96
    COMMENT         shift and go to state 60
    IF              shift and go to state 41
    INTEGER         shift and go to state 98
    WHILE           shift and go to state 39
    SWITCH          shift and go to state 40
    INT             shift and go to state 43
    SHORT           shift and go to state 44
    LONG            shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47

    EXPRESSIONS                    shift and go to state 138
    EXPRESSION                     shift and go to state 83
    CODE                           shift and go to state 85
    CONTROL_STRUCTURES             shift and go to state 86
    FUNCTION                       shift and go to state 87
    INTEGER_DECLARATION            shift and go to state 88
    DECIMAL_DECLARATION            shift and go to state 89
    ASSIGNMENT_DECLARATION         shift and go to state 90
    COMENTARIOLEX                  shift and go to state 91
    IF_STRUCTURE                   shift and go to state 92
    FOR_STRUCTURE                  shift and go to state 93
    WHILE_STRUCTURE                shift and go to state 94
    SWITCH_STRUCTURE               shift and go to state 95
    INTEGER_TYPE                   shift and go to state 97
    DECIMAL_TYPE                   shift and go to state 99

state 117

    (105) COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .

    AND             reduce using rule 105 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    OR              reduce using rule 105 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    NOT             reduce using rule 105 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    $end            reduce using rule 105 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)
    RPAREN          reduce using rule 105 (COMPARISON -> VALUE COMPARISON_OPERATOR VALUE .)


state 118

    (37) VALUE -> NUMBER .

    AND             reduce using rule 37 (VALUE -> NUMBER .)
    OR              reduce using rule 37 (VALUE -> NUMBER .)
    NOT             reduce using rule 37 (VALUE -> NUMBER .)
    $end            reduce using rule 37 (VALUE -> NUMBER .)
    RPAREN          reduce using rule 37 (VALUE -> NUMBER .)
    EQUAL_TO        reduce using rule 37 (VALUE -> NUMBER .)
    NOT_EQUAL       reduce using rule 37 (VALUE -> NUMBER .)
    GREATER_THAN    reduce using rule 37 (VALUE -> NUMBER .)
    LESS_THAN       reduce using rule 37 (VALUE -> NUMBER .)
    GREATER_EQUAL   reduce using rule 37 (VALUE -> NUMBER .)
    LESS_EQUAL      reduce using rule 37 (VALUE -> NUMBER .)


state 119

    (39) NUMBER -> INTEGER .

    AND             reduce using rule 39 (NUMBER -> INTEGER .)
    OR              reduce using rule 39 (NUMBER -> INTEGER .)
    NOT             reduce using rule 39 (NUMBER -> INTEGER .)
    $end            reduce using rule 39 (NUMBER -> INTEGER .)
    RPAREN          reduce using rule 39 (NUMBER -> INTEGER .)
    PLUS            reduce using rule 39 (NUMBER -> INTEGER .)
    MINUS           reduce using rule 39 (NUMBER -> INTEGER .)
    TIMES           reduce using rule 39 (NUMBER -> INTEGER .)
    MODULUS         reduce using rule 39 (NUMBER -> INTEGER .)
    DIVIDE          reduce using rule 39 (NUMBER -> INTEGER .)
    EQUAL_TO        reduce using rule 39 (NUMBER -> INTEGER .)
    NOT_EQUAL       reduce using rule 39 (NUMBER -> INTEGER .)
    GREATER_THAN    reduce using rule 39 (NUMBER -> INTEGER .)
    LESS_THAN       reduce using rule 39 (NUMBER -> INTEGER .)
    GREATER_EQUAL   reduce using rule 39 (NUMBER -> INTEGER .)
    LESS_EQUAL      reduce using rule 39 (NUMBER -> INTEGER .)
    SEMICOLON       reduce using rule 39 (NUMBER -> INTEGER .)


state 120

    (96) OPERATION -> NUMBER OPERATOR NUMBER .

    PLUS            reduce using rule 96 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MINUS           reduce using rule 96 (OPERATION -> NUMBER OPERATOR NUMBER .)
    TIMES           reduce using rule 96 (OPERATION -> NUMBER OPERATOR NUMBER .)
    MODULUS         reduce using rule 96 (OPERATION -> NUMBER OPERATOR NUMBER .)
    DIVIDE          reduce using rule 96 (OPERATION -> NUMBER OPERATOR NUMBER .)
    $end            reduce using rule 96 (OPERATION -> NUMBER OPERATOR NUMBER .)


state 121

    (74) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL . INTEGER

    INTEGER         shift and go to state 139


state 122

    (75) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL . DECIMAL

    DECIMAL         shift and go to state 140


state 123

    (97) OPERATIONS -> OPERATION .
    (98) OPERATIONS -> OPERATION . OPERATOR OPERATIONS
    (91) OPERATOR -> . PLUS
    (92) OPERATOR -> . MINUS
    (93) OPERATOR -> . TIMES
    (94) OPERATOR -> . MODULUS
    (95) OPERATOR -> . DIVIDE

    $end            reduce using rule 97 (OPERATIONS -> OPERATION .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    MODULUS         shift and go to state 64
    DIVIDE          shift and go to state 65

    OPERATOR                       shift and go to state 103

state 124

    (98) OPERATIONS -> OPERATION OPERATOR OPERATIONS .

    $end            reduce using rule 98 (OPERATIONS -> OPERATION OPERATOR OPERATIONS .)


state 125

    (96) OPERATION -> NUMBER . OPERATOR NUMBER
    (91) OPERATOR -> . PLUS
    (92) OPERATOR -> . MINUS
    (93) OPERATOR -> . TIMES
    (94) OPERATOR -> . MODULUS
    (95) OPERATOR -> . DIVIDE

    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    TIMES           shift and go to state 63
    MODULUS         shift and go to state 64
    DIVIDE          shift and go to state 65

    OPERATOR                       shift and go to state 81

state 126

    (106) COMPARISONS -> COMPARISON .
    (107) COMPARISONS -> COMPARISON . LOGICAL_OPERATOR COMPARISONS
    (108) LOGICAL_OPERATOR -> . AND
    (109) LOGICAL_OPERATOR -> . OR
    (110) LOGICAL_OPERATOR -> . NOT

    $end            reduce using rule 106 (COMPARISONS -> COMPARISON .)
    RPAREN          reduce using rule 106 (COMPARISONS -> COMPARISON .)
    AND             shift and go to state 72
    OR              shift and go to state 73
    NOT             shift and go to state 74

    LOGICAL_OPERATOR               shift and go to state 104

state 127

    (107) COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .

    $end            reduce using rule 107 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)
    RPAREN          reduce using rule 107 (COMPARISONS -> COMPARISON LOGICAL_OPERATOR COMPARISONS .)


state 128

    (105) COMPARISON -> VALUE . COMPARISON_OPERATOR VALUE
    (99) COMPARISON_OPERATOR -> . EQUAL_TO
    (100) COMPARISON_OPERATOR -> . NOT_EQUAL
    (101) COMPARISON_OPERATOR -> . GREATER_THAN
    (102) COMPARISON_OPERATOR -> . LESS_THAN
    (103) COMPARISON_OPERATOR -> . GREATER_EQUAL
    (104) COMPARISON_OPERATOR -> . LESS_EQUAL

    EQUAL_TO        shift and go to state 66
    NOT_EQUAL       shift and go to state 67
    GREATER_THAN    shift and go to state 68
    LESS_THAN       shift and go to state 69
    GREATER_EQUAL   shift and go to state 70
    LESS_EQUAL      shift and go to state 71

    COMPARISON_OPERATOR            shift and go to state 80

state 129

    (35) DEFINE -> PP_DEFINE VARIABLELEX VALUE .

    $end            reduce using rule 35 (DEFINE -> PP_DEFINE VARIABLELEX VALUE .)


state 130

    (48) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS . RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    RPAREN          shift and go to state 141


state 131

    (54) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS . RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE

    RPAREN          shift and go to state 142


state 132

    (58) IF_STRUCTURE -> IF LPAREN COMPARISONS . RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE

    RPAREN          shift and go to state 143


state 133

    (68) FUNCTION -> VARNAME LPAREN RPAREN .

    $end            reduce using rule 68 (FUNCTION -> VARNAME LPAREN RPAREN .)
    SEMICOLON       reduce using rule 68 (FUNCTION -> VARNAME LPAREN RPAREN .)


state 134

    (112) SENTENCE -> VARNAME .

    $end            reduce using rule 112 (SENTENCE -> VARNAME .)
    SEMICOLON       reduce using rule 112 (SENTENCE -> VARNAME .)


state 135

    (76) ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .

    $end            reduce using rule 76 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)
    SEMICOLON       reduce using rule 76 (ASSIGNMENT_DECLARATION -> VARNAME ASSIGNMENT_OPERATOR SENTENCE .)


state 136

    (111) SENTENCE -> NUMBER .

    $end            reduce using rule 111 (SENTENCE -> NUMBER .)
    SEMICOLON       reduce using rule 111 (SENTENCE -> NUMBER .)


state 137

    (49) SWITCH_CASE -> CASE INTEGER COLON . EXPRESSIONS BREAK SEMICOLON
    (66) EXPRESSIONS -> . EXPRESSION
    (67) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (64) EXPRESSION -> . CODE SEMICOLON
    (65) EXPRESSION -> . CONTROL_STRUCTURES
    (59) CODE -> . FUNCTION
    (60) CODE -> . INTEGER_DECLARATION
    (61) CODE -> . DECIMAL_DECLARATION
    (62) CODE -> . ASSIGNMENT_DECLARATION
    (63) CODE -> . COMENTARIOLEX
    (41) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (42) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (43) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (44) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (68) FUNCTION -> . VARNAME LPAREN RPAREN
    (74) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (75) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (76) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (89) COMENTARIOLEX -> . COMMENT
    (58) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (57) FOR_STRUCTURE -> . INTEGER
    (48) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (54) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (69) INTEGER_TYPE -> . INT
    (70) INTEGER_TYPE -> . SHORT
    (71) INTEGER_TYPE -> . LONG
    (72) DECIMAL_TYPE -> . FLOAT
    (73) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 96
    COMMENT         shift and go to state 60
    IF              shift and go to state 41
    INTEGER         shift and go to state 98
    WHILE           shift and go to state 39
    SWITCH          shift and go to state 40
    INT             shift and go to state 43
    SHORT           shift and go to state 44
    LONG            shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47

    EXPRESSIONS                    shift and go to state 144
    EXPRESSION                     shift and go to state 83
    CODE                           shift and go to state 85
    CONTROL_STRUCTURES             shift and go to state 86
    FUNCTION                       shift and go to state 87
    INTEGER_DECLARATION            shift and go to state 88
    DECIMAL_DECLARATION            shift and go to state 89
    ASSIGNMENT_DECLARATION         shift and go to state 90
    COMENTARIOLEX                  shift and go to state 91
    IF_STRUCTURE                   shift and go to state 92
    FOR_STRUCTURE                  shift and go to state 93
    WHILE_STRUCTURE                shift and go to state 94
    SWITCH_STRUCTURE               shift and go to state 95
    INTEGER_TYPE                   shift and go to state 97
    DECIMAL_TYPE                   shift and go to state 99

state 138

    (50) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 145


state 139

    (74) INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .

    $end            reduce using rule 74 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)
    SEMICOLON       reduce using rule 74 (INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER .)


state 140

    (75) DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .

    $end            reduce using rule 75 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)
    SEMICOLON       reduce using rule 75 (DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL .)


state 141

    (48) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN . LCURL_BRACE BODY_STRUCTURE RCURL_BRACE

    LCURL_BRACE     shift and go to state 146


state 142

    (54) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN . LCURL_BRACE SWITCH_BODY RCURL_BRACE

    LCURL_BRACE     shift and go to state 147


state 143

    (58) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN . LCURL_BRACE EXPRESSIONS RCURL_BRACE

    LCURL_BRACE     shift and go to state 148


state 144

    (49) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS . BREAK SEMICOLON

    BREAK           shift and go to state 149


state 145

    (50) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 150


state 146

    (48) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE . BODY_STRUCTURE RCURL_BRACE
    (45) BODY_STRUCTURE -> . EXPRESSIONS
    (46) BODY_STRUCTURE -> . EXPRESSIONS BREAK SEMICOLON
    (47) BODY_STRUCTURE -> . EXPRESSIONS CONTINUE SEMICOLON
    (66) EXPRESSIONS -> . EXPRESSION
    (67) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (64) EXPRESSION -> . CODE SEMICOLON
    (65) EXPRESSION -> . CONTROL_STRUCTURES
    (59) CODE -> . FUNCTION
    (60) CODE -> . INTEGER_DECLARATION
    (61) CODE -> . DECIMAL_DECLARATION
    (62) CODE -> . ASSIGNMENT_DECLARATION
    (63) CODE -> . COMENTARIOLEX
    (41) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (42) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (43) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (44) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (68) FUNCTION -> . VARNAME LPAREN RPAREN
    (74) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (75) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (76) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (89) COMENTARIOLEX -> . COMMENT
    (58) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (57) FOR_STRUCTURE -> . INTEGER
    (48) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (54) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (69) INTEGER_TYPE -> . INT
    (70) INTEGER_TYPE -> . SHORT
    (71) INTEGER_TYPE -> . LONG
    (72) DECIMAL_TYPE -> . FLOAT
    (73) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 96
    COMMENT         shift and go to state 60
    IF              shift and go to state 41
    INTEGER         shift and go to state 98
    WHILE           shift and go to state 39
    SWITCH          shift and go to state 40
    INT             shift and go to state 43
    SHORT           shift and go to state 44
    LONG            shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47

    BODY_STRUCTURE                 shift and go to state 151
    EXPRESSIONS                    shift and go to state 152
    EXPRESSION                     shift and go to state 83
    CODE                           shift and go to state 85
    CONTROL_STRUCTURES             shift and go to state 86
    FUNCTION                       shift and go to state 87
    INTEGER_DECLARATION            shift and go to state 88
    DECIMAL_DECLARATION            shift and go to state 89
    ASSIGNMENT_DECLARATION         shift and go to state 90
    COMENTARIOLEX                  shift and go to state 91
    IF_STRUCTURE                   shift and go to state 92
    FOR_STRUCTURE                  shift and go to state 93
    WHILE_STRUCTURE                shift and go to state 94
    SWITCH_STRUCTURE               shift and go to state 95
    INTEGER_TYPE                   shift and go to state 97
    DECIMAL_TYPE                   shift and go to state 99

state 147

    (54) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE . SWITCH_BODY RCURL_BRACE
    (51) SWITCH_BODY -> . SWITCH_CASE
    (52) SWITCH_BODY -> . SWITCH_DEFAULT
    (53) SWITCH_BODY -> . SWITCH_CASE SWITCH_BODY
    (49) SWITCH_CASE -> . CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON
    (50) SWITCH_DEFAULT -> . DEFAULT COLON EXPRESSIONS BREAK SEMICOLON

    CASE            shift and go to state 78
    DEFAULT         shift and go to state 79

    SWITCH_BODY                    shift and go to state 153
    SWITCH_CASE                    shift and go to state 75
    SWITCH_DEFAULT                 shift and go to state 76

state 148

    (58) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE . EXPRESSIONS RCURL_BRACE
    (66) EXPRESSIONS -> . EXPRESSION
    (67) EXPRESSIONS -> . EXPRESSION EXPRESSIONS
    (64) EXPRESSION -> . CODE SEMICOLON
    (65) EXPRESSION -> . CONTROL_STRUCTURES
    (59) CODE -> . FUNCTION
    (60) CODE -> . INTEGER_DECLARATION
    (61) CODE -> . DECIMAL_DECLARATION
    (62) CODE -> . ASSIGNMENT_DECLARATION
    (63) CODE -> . COMENTARIOLEX
    (41) CONTROL_STRUCTURES -> . IF_STRUCTURE
    (42) CONTROL_STRUCTURES -> . FOR_STRUCTURE
    (43) CONTROL_STRUCTURES -> . WHILE_STRUCTURE
    (44) CONTROL_STRUCTURES -> . SWITCH_STRUCTURE
    (68) FUNCTION -> . VARNAME LPAREN RPAREN
    (74) INTEGER_DECLARATION -> . INTEGER_TYPE VARNAME EQUAL INTEGER
    (75) DECIMAL_DECLARATION -> . DECIMAL_TYPE VARNAME EQUAL DECIMAL
    (76) ASSIGNMENT_DECLARATION -> . VARNAME ASSIGNMENT_OPERATOR SENTENCE
    (89) COMENTARIOLEX -> . COMMENT
    (58) IF_STRUCTURE -> . IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE
    (57) FOR_STRUCTURE -> . INTEGER
    (48) WHILE_STRUCTURE -> . WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE
    (54) SWITCH_STRUCTURE -> . SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE
    (69) INTEGER_TYPE -> . INT
    (70) INTEGER_TYPE -> . SHORT
    (71) INTEGER_TYPE -> . LONG
    (72) DECIMAL_TYPE -> . FLOAT
    (73) DECIMAL_TYPE -> . DOUBLE

    VARNAME         shift and go to state 96
    COMMENT         shift and go to state 60
    IF              shift and go to state 41
    INTEGER         shift and go to state 98
    WHILE           shift and go to state 39
    SWITCH          shift and go to state 40
    INT             shift and go to state 43
    SHORT           shift and go to state 44
    LONG            shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47

    EXPRESSIONS                    shift and go to state 154
    EXPRESSION                     shift and go to state 83
    CODE                           shift and go to state 85
    CONTROL_STRUCTURES             shift and go to state 86
    FUNCTION                       shift and go to state 87
    INTEGER_DECLARATION            shift and go to state 88
    DECIMAL_DECLARATION            shift and go to state 89
    ASSIGNMENT_DECLARATION         shift and go to state 90
    COMENTARIOLEX                  shift and go to state 91
    IF_STRUCTURE                   shift and go to state 92
    FOR_STRUCTURE                  shift and go to state 93
    WHILE_STRUCTURE                shift and go to state 94
    SWITCH_STRUCTURE               shift and go to state 95
    INTEGER_TYPE                   shift and go to state 97
    DECIMAL_TYPE                   shift and go to state 99

state 149

    (49) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 155


state 150

    (50) SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .

    $end            reduce using rule 50 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 50 (SWITCH_DEFAULT -> DEFAULT COLON EXPRESSIONS BREAK SEMICOLON .)


state 151

    (48) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE . RCURL_BRACE

    RCURL_BRACE     shift and go to state 156


state 152

    (45) BODY_STRUCTURE -> EXPRESSIONS .
    (46) BODY_STRUCTURE -> EXPRESSIONS . BREAK SEMICOLON
    (47) BODY_STRUCTURE -> EXPRESSIONS . CONTINUE SEMICOLON

    RCURL_BRACE     reduce using rule 45 (BODY_STRUCTURE -> EXPRESSIONS .)
    BREAK           shift and go to state 157
    CONTINUE        shift and go to state 158


state 153

    (54) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY . RCURL_BRACE

    RCURL_BRACE     shift and go to state 159


state 154

    (58) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS . RCURL_BRACE

    RCURL_BRACE     shift and go to state 160


state 155

    (49) SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .

    CASE            reduce using rule 49 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    DEFAULT         reduce using rule 49 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    $end            reduce using rule 49 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)
    RCURL_BRACE     reduce using rule 49 (SWITCH_CASE -> CASE INTEGER COLON EXPRESSIONS BREAK SEMICOLON .)


state 156

    (48) WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .

    $end            reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    VARNAME         reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    COMMENT         reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    IF              reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    INTEGER         reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    WHILE           reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SWITCH          reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    INT             reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    SHORT           reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    LONG            reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    FLOAT           reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    DOUBLE          reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    BREAK           reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    CONTINUE        reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 48 (WHILE_STRUCTURE -> WHILE LPAREN COMPARISONS RPAREN LCURL_BRACE BODY_STRUCTURE RCURL_BRACE .)


state 157

    (46) BODY_STRUCTURE -> EXPRESSIONS BREAK . SEMICOLON

    SEMICOLON       shift and go to state 161


state 158

    (47) BODY_STRUCTURE -> EXPRESSIONS CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 162


state 159

    (54) SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .

    $end            reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    VARNAME         reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    COMMENT         reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    IF              reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    INTEGER         reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    WHILE           reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SWITCH          reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    INT             reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    SHORT           reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    LONG            reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    FLOAT           reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    DOUBLE          reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    BREAK           reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    CONTINUE        reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 54 (SWITCH_STRUCTURE -> SWITCH LPAREN COMPARISONS RPAREN LCURL_BRACE SWITCH_BODY RCURL_BRACE .)


state 160

    (58) IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .

    $end            reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    VARNAME         reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    COMMENT         reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    IF              reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INTEGER         reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    WHILE           reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SWITCH          reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    INT             reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    SHORT           reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    LONG            reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    FLOAT           reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    DOUBLE          reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    BREAK           reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    CONTINUE        reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)
    RCURL_BRACE     reduce using rule 58 (IF_STRUCTURE -> IF LPAREN COMPARISONS RPAREN LCURL_BRACE EXPRESSIONS RCURL_BRACE .)


state 161

    (46) BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .

    RCURL_BRACE     reduce using rule 46 (BODY_STRUCTURE -> EXPRESSIONS BREAK SEMICOLON .)


state 162

    (47) BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .

    RCURL_BRACE     reduce using rule 47 (BODY_STRUCTURE -> EXPRESSIONS CONTINUE SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (ROOT -> DEFINE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> DEFINE) in state 3
WARNING: reduce/reduce conflict in state 4 resolved using rule (ROOT -> INCLUDE)
WARNING: rejected rule (PREPROCESOR_DIRECTIVE -> INCLUDE) in state 4
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (VALUE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 6 resolved using rule (ROOT -> NUMBER)
WARNING: rejected rule (SENTENCE -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 7 resolved using rule (ROOT -> CONTROL_STRUCTURES)
WARNING: rejected rule (EXPRESSION -> CONTROL_STRUCTURES) in state 7
WARNING: reduce/reduce conflict in state 8 resolved using rule (ROOT -> WHILE_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> WHILE_STRUCTURE) in state 8
WARNING: reduce/reduce conflict in state 9 resolved using rule (ROOT -> SWITCH_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> SWITCH_STRUCTURE) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (ROOT -> IF_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> IF_STRUCTURE) in state 10
WARNING: reduce/reduce conflict in state 11 resolved using rule (ROOT -> FOR_STRUCTURE)
WARNING: rejected rule (CONTROL_STRUCTURES -> FOR_STRUCTURE) in state 11
WARNING: reduce/reduce conflict in state 13 resolved using rule (ROOT -> EXPRESSION)
WARNING: rejected rule (EXPRESSIONS -> EXPRESSION) in state 13
WARNING: reduce/reduce conflict in state 15 resolved using rule (ROOT -> FUNCTION)
WARNING: rejected rule (CODE -> FUNCTION) in state 15
WARNING: reduce/reduce conflict in state 18 resolved using rule (ROOT -> INTEGER_DECLARATION)
WARNING: rejected rule (CODE -> INTEGER_DECLARATION) in state 18
WARNING: reduce/reduce conflict in state 19 resolved using rule (ROOT -> DECIMAL_DECLARATION)
WARNING: rejected rule (CODE -> DECIMAL_DECLARATION) in state 19
WARNING: reduce/reduce conflict in state 20 resolved using rule (ROOT -> ASSIGNMENT_DECLARATION)
WARNING: rejected rule (CODE -> ASSIGNMENT_DECLARATION) in state 20
WARNING: reduce/reduce conflict in state 22 resolved using rule (ROOT -> COMENTARIOLEX)
WARNING: rejected rule (CODE -> COMENTARIOLEX) in state 22
WARNING: reduce/reduce conflict in state 25 resolved using rule (ROOT -> OPERATION)
WARNING: rejected rule (OPERATIONS -> OPERATION) in state 25
WARNING: reduce/reduce conflict in state 28 resolved using rule (ROOT -> COMPARISON)
WARNING: rejected rule (COMPARISONS -> COMPARISON) in state 28
WARNING: reduce/reduce conflict in state 37 resolved using rule (NUMBER -> INTEGER)
WARNING: rejected rule (FOR_STRUCTURE -> INTEGER) in state 37
WARNING: reduce/reduce conflict in state 42 resolved using rule (VARIABLELEX -> VARNAME)
WARNING: rejected rule (SENTENCE -> VARNAME) in state 42
WARNING: Rule (PREPROCESOR_DIRECTIVE -> DEFINE) is never reduced
WARNING: Rule (PREPROCESOR_DIRECTIVE -> INCLUDE) is never reduced
