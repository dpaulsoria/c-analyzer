Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    AND
    AND_EQUAL
    AUTO
    BACKSLASH
    BACKSPACE
    BREAK
    B_AND
    B_COMPLEMENT
    B_OR
    B_XOR
    CASE
    CHARACTER
    COLON
    COMMA
    COMPLEMENT_EQUAL
    CONST
    CONTINUE
    DEFAULT
    DIV_EQUAL
    DO
    DOT
    DOUBLE_APOS
    DOUBLE_QUOTE
    ENUM
    EQUAL_TO
    EXTERN
    FF_PAGEBREAK
    FS_CHAR
    FS_DOUBLE
    FS_FLOAT
    FS_HEX
    FS_INT
    FS_LONG
    FS_LONG_DOUBLE
    FS_OCT
    FS_OCT_LONG
    FS_POINTER
    FS_SCI_NOTATION
    FS_STRING
    FS_UNSIGNED_INT
    FS_UNSIGNED_LONG
    GOTO
    GREATER_EQUAL
    GREATER_THAN
    HTAB
    IGNORE
    LBRACKET
    LCURL_BRACE
    LESS_EQUAL
    LESS_THAN
    LPAREN
    MINUS_EQUAL
    MOD_EQUAL
    NEWLINE
    NOT
    NOT_EQUAL
    NULL
    OR
    OR_EQUAL
    PLUS_EQUAL
    PP_DATE
    PP_DEFINE
    PP_DTMACRO
    PP_ERROR
    PP_FILE
    PP_IF
    PP_IFDEF
    PP_IFNDEF
    PP_LINE
    PP_PRAGMA
    PP_STMACRO
    PP_TIME
    PP_TIMESTAMP
    PP_UNDEF
    QUESTIONMARK
    RBRACKET
    RCURL_BRACE
    REGISTER
    RETURN
    RPAREN
    SEMICOLON
    SHIFTL_EQUAL
    SHIFTR_EQUAL
    SHIFT_LEFT
    SHIFT_RIGHT
    SIGNED
    SINGLE_APOS
    SINGLE_QUOTE
    SIZEOF
    STATIC
    STRING
    STRUCT
    TILDE
    TIMES_EQUAL
    TYPEDEF
    UNION
    UNSIGNED
    VOID
    VOLTILE
    VTAB
    XOR_EQUAL

Grammar

Rule 0     S' -> EXPRESSION
Rule 1     EXPRESSION -> COMENTARIOLEX
Rule 2     EXPRESSION -> VARIABLELEX
Rule 3     EXPRESSION -> OPERATION
Rule 4     EXPRESSION -> DECLARATION
Rule 5     EXPRESSION -> SENTENCIAS
Rule 6     EXPRESSION -> INCLUDE
Rule 7     INCLUDE -> PP_INCLUDE HEADER_LIB
Rule 8     VALUE -> INTEGER
Rule 9     VALUE -> DECIMAL
Rule 10    SENTENCIAS -> IF
Rule 11    SENTENCIAS -> ELSEIF
Rule 12    SENTENCIAS -> ELSE
Rule 13    SENTENCIAS -> FOR
Rule 14    SENTENCIAS -> WHILE
Rule 15    SENTENCIAS -> SWITCH
Rule 16    DATA_TYPE -> INTEGER_TYPE
Rule 17    DATA_TYPE -> DECIMAL_TYPE
Rule 18    DATA_TYPE -> CHAR
Rule 19    INTEGER_TYPE -> INT
Rule 20    INTEGER_TYPE -> SHORT
Rule 21    INTEGER_TYPE -> LONG
Rule 22    DECIMAL_TYPE -> FLOAT
Rule 23    DECIMAL_TYPE -> DOUBLE
Rule 24    DECLARATION -> DATA_TYPE VARNAME EQUAL INTEGER
Rule 25    INTEGER_DECLARATION -> INTEGER_TYPE VARNAME EQUAL INTEGER
Rule 26    DECIMAL_DECLARATION -> DECIMAL_TYPE VARNAME EQUAL DECIMAL
Rule 27    COMENTARIOLEX -> COMMENT
Rule 28    VARIABLELEX -> VARNAME
Rule 29    OPERADOR -> PLUS
Rule 30    OPERADOR -> MINUS
Rule 31    OPERADOR -> TIMES
Rule 32    OPERADOR -> MODULUS
Rule 33    OPERADOR -> DIVIDE
Rule 34    OPERATION -> VALUE OPERADOR VALUE

Terminals, with rules where they appear

AMPERSAND            : 
AND                  : 
AND_EQUAL            : 
AUTO                 : 
BACKSLASH            : 
BACKSPACE            : 
BREAK                : 
B_AND                : 
B_COMPLEMENT         : 
B_OR                 : 
B_XOR                : 
CASE                 : 
CHAR                 : 18
CHARACTER            : 
COLON                : 
COMMA                : 
COMMENT              : 27
COMPLEMENT_EQUAL     : 
CONST                : 
CONTINUE             : 
DECIMAL              : 9 26
DEFAULT              : 
DIVIDE               : 33
DIV_EQUAL            : 
DO                   : 
DOT                  : 
DOUBLE               : 23
DOUBLE_APOS          : 
DOUBLE_QUOTE         : 
ELSE                 : 12
ELSEIF               : 11
ENUM                 : 
EQUAL                : 24 25 26
EQUAL_TO             : 
EXTERN               : 
FF_PAGEBREAK         : 
FLOAT                : 22
FOR                  : 13
FS_CHAR              : 
FS_DOUBLE            : 
FS_FLOAT             : 
FS_HEX               : 
FS_INT               : 
FS_LONG              : 
FS_LONG_DOUBLE       : 
FS_OCT               : 
FS_OCT_LONG          : 
FS_POINTER           : 
FS_SCI_NOTATION      : 
FS_STRING            : 
FS_UNSIGNED_INT      : 
FS_UNSIGNED_LONG     : 
GOTO                 : 
GREATER_EQUAL        : 
GREATER_THAN         : 
HEADER_LIB           : 7
HTAB                 : 
IF                   : 10
IGNORE               : 
INT                  : 19
INTEGER              : 8 24 25
LBRACKET             : 
LCURL_BRACE          : 
LESS_EQUAL           : 
LESS_THAN            : 
LONG                 : 21
LPAREN               : 
MINUS                : 30
MINUS_EQUAL          : 
MODULUS              : 32
MOD_EQUAL            : 
NEWLINE              : 
NOT                  : 
NOT_EQUAL            : 
NULL                 : 
OR                   : 
OR_EQUAL             : 
PLUS                 : 29
PLUS_EQUAL           : 
PP_DATE              : 
PP_DEFINE            : 
PP_DTMACRO           : 
PP_ERROR             : 
PP_FILE              : 
PP_IF                : 
PP_IFDEF             : 
PP_IFNDEF            : 
PP_INCLUDE           : 7
PP_LINE              : 
PP_PRAGMA            : 
PP_STMACRO           : 
PP_TIME              : 
PP_TIMESTAMP         : 
PP_UNDEF             : 
QUESTIONMARK         : 
RBRACKET             : 
RCURL_BRACE          : 
REGISTER             : 
RETURN               : 
RPAREN               : 
SEMICOLON            : 
SHIFTL_EQUAL         : 
SHIFTR_EQUAL         : 
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
SHORT                : 20
SIGNED               : 
SINGLE_APOS          : 
SINGLE_QUOTE         : 
SIZEOF               : 
STATIC               : 
STRING               : 
STRUCT               : 
SWITCH               : 15
TILDE                : 
TIMES                : 31
TIMES_EQUAL          : 
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VARNAME              : 24 25 26 28
VOID                 : 
VOLTILE              : 
VTAB                 : 
WHILE                : 14
XOR_EQUAL            : 
error                : 

Nonterminals, with rules where they appear

COMENTARIOLEX        : 1
DATA_TYPE            : 24
DECIMAL_DECLARATION  : 
DECIMAL_TYPE         : 17 26
DECLARATION          : 4
EXPRESSION           : 0
INCLUDE              : 6
INTEGER_DECLARATION  : 
INTEGER_TYPE         : 16 25
OPERADOR             : 34
OPERATION            : 3
SENTENCIAS           : 5
VALUE                : 34 34
VARIABLELEX          : 2

Parsing method: LALR

state 0

    (0) S' -> . EXPRESSION
    (1) EXPRESSION -> . COMENTARIOLEX
    (2) EXPRESSION -> . VARIABLELEX
    (3) EXPRESSION -> . OPERATION
    (4) EXPRESSION -> . DECLARATION
    (5) EXPRESSION -> . SENTENCIAS
    (6) EXPRESSION -> . INCLUDE
    (27) COMENTARIOLEX -> . COMMENT
    (28) VARIABLELEX -> . VARNAME
    (34) OPERATION -> . VALUE OPERADOR VALUE
    (24) DECLARATION -> . DATA_TYPE VARNAME EQUAL INTEGER
    (10) SENTENCIAS -> . IF
    (11) SENTENCIAS -> . ELSEIF
    (12) SENTENCIAS -> . ELSE
    (13) SENTENCIAS -> . FOR
    (14) SENTENCIAS -> . WHILE
    (15) SENTENCIAS -> . SWITCH
    (7) INCLUDE -> . PP_INCLUDE HEADER_LIB
    (8) VALUE -> . INTEGER
    (9) VALUE -> . DECIMAL
    (16) DATA_TYPE -> . INTEGER_TYPE
    (17) DATA_TYPE -> . DECIMAL_TYPE
    (18) DATA_TYPE -> . CHAR
    (19) INTEGER_TYPE -> . INT
    (20) INTEGER_TYPE -> . SHORT
    (21) INTEGER_TYPE -> . LONG
    (22) DECIMAL_TYPE -> . FLOAT
    (23) DECIMAL_TYPE -> . DOUBLE

    COMMENT         shift and go to state 8
    VARNAME         shift and go to state 9
    IF              shift and go to state 13
    ELSEIF          shift and go to state 14
    ELSE            shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    SWITCH          shift and go to state 18
    PP_INCLUDE      shift and go to state 19
    INTEGER         shift and go to state 12
    DECIMAL         shift and go to state 20
    CHAR            shift and go to state 23
    INT             shift and go to state 24
    SHORT           shift and go to state 25
    LONG            shift and go to state 26
    FLOAT           shift and go to state 27
    DOUBLE          shift and go to state 28

    EXPRESSION                     shift and go to state 1
    COMENTARIOLEX                  shift and go to state 2
    VARIABLELEX                    shift and go to state 3
    OPERATION                      shift and go to state 4
    DECLARATION                    shift and go to state 5
    SENTENCIAS                     shift and go to state 6
    INCLUDE                        shift and go to state 7
    VALUE                          shift and go to state 10
    DATA_TYPE                      shift and go to state 11
    INTEGER_TYPE                   shift and go to state 21
    DECIMAL_TYPE                   shift and go to state 22

state 1

    (0) S' -> EXPRESSION .



state 2

    (1) EXPRESSION -> COMENTARIOLEX .

    $end            reduce using rule 1 (EXPRESSION -> COMENTARIOLEX .)


state 3

    (2) EXPRESSION -> VARIABLELEX .

    $end            reduce using rule 2 (EXPRESSION -> VARIABLELEX .)


state 4

    (3) EXPRESSION -> OPERATION .

    $end            reduce using rule 3 (EXPRESSION -> OPERATION .)


state 5

    (4) EXPRESSION -> DECLARATION .

    $end            reduce using rule 4 (EXPRESSION -> DECLARATION .)


state 6

    (5) EXPRESSION -> SENTENCIAS .

    $end            reduce using rule 5 (EXPRESSION -> SENTENCIAS .)


state 7

    (6) EXPRESSION -> INCLUDE .

    $end            reduce using rule 6 (EXPRESSION -> INCLUDE .)


state 8

    (27) COMENTARIOLEX -> COMMENT .

    $end            reduce using rule 27 (COMENTARIOLEX -> COMMENT .)


state 9

    (28) VARIABLELEX -> VARNAME .

    $end            reduce using rule 28 (VARIABLELEX -> VARNAME .)


state 10

    (34) OPERATION -> VALUE . OPERADOR VALUE
    (29) OPERADOR -> . PLUS
    (30) OPERADOR -> . MINUS
    (31) OPERADOR -> . TIMES
    (32) OPERADOR -> . MODULUS
    (33) OPERADOR -> . DIVIDE

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    TIMES           shift and go to state 32
    MODULUS         shift and go to state 33
    DIVIDE          shift and go to state 34

    OPERADOR                       shift and go to state 29

state 11

    (24) DECLARATION -> DATA_TYPE . VARNAME EQUAL INTEGER

    VARNAME         shift and go to state 35


state 12

    (8) VALUE -> INTEGER .

    PLUS            reduce using rule 8 (VALUE -> INTEGER .)
    MINUS           reduce using rule 8 (VALUE -> INTEGER .)
    TIMES           reduce using rule 8 (VALUE -> INTEGER .)
    MODULUS         reduce using rule 8 (VALUE -> INTEGER .)
    DIVIDE          reduce using rule 8 (VALUE -> INTEGER .)
    $end            reduce using rule 8 (VALUE -> INTEGER .)


state 13

    (10) SENTENCIAS -> IF .

    $end            reduce using rule 10 (SENTENCIAS -> IF .)


state 14

    (11) SENTENCIAS -> ELSEIF .

    $end            reduce using rule 11 (SENTENCIAS -> ELSEIF .)


state 15

    (12) SENTENCIAS -> ELSE .

    $end            reduce using rule 12 (SENTENCIAS -> ELSE .)


state 16

    (13) SENTENCIAS -> FOR .

    $end            reduce using rule 13 (SENTENCIAS -> FOR .)


state 17

    (14) SENTENCIAS -> WHILE .

    $end            reduce using rule 14 (SENTENCIAS -> WHILE .)


state 18

    (15) SENTENCIAS -> SWITCH .

    $end            reduce using rule 15 (SENTENCIAS -> SWITCH .)


state 19

    (7) INCLUDE -> PP_INCLUDE . HEADER_LIB

    HEADER_LIB      shift and go to state 36


state 20

    (9) VALUE -> DECIMAL .

    PLUS            reduce using rule 9 (VALUE -> DECIMAL .)
    MINUS           reduce using rule 9 (VALUE -> DECIMAL .)
    TIMES           reduce using rule 9 (VALUE -> DECIMAL .)
    MODULUS         reduce using rule 9 (VALUE -> DECIMAL .)
    DIVIDE          reduce using rule 9 (VALUE -> DECIMAL .)
    $end            reduce using rule 9 (VALUE -> DECIMAL .)


state 21

    (16) DATA_TYPE -> INTEGER_TYPE .

    VARNAME         reduce using rule 16 (DATA_TYPE -> INTEGER_TYPE .)


state 22

    (17) DATA_TYPE -> DECIMAL_TYPE .

    VARNAME         reduce using rule 17 (DATA_TYPE -> DECIMAL_TYPE .)


state 23

    (18) DATA_TYPE -> CHAR .

    VARNAME         reduce using rule 18 (DATA_TYPE -> CHAR .)


state 24

    (19) INTEGER_TYPE -> INT .

    VARNAME         reduce using rule 19 (INTEGER_TYPE -> INT .)


state 25

    (20) INTEGER_TYPE -> SHORT .

    VARNAME         reduce using rule 20 (INTEGER_TYPE -> SHORT .)


state 26

    (21) INTEGER_TYPE -> LONG .

    VARNAME         reduce using rule 21 (INTEGER_TYPE -> LONG .)


state 27

    (22) DECIMAL_TYPE -> FLOAT .

    VARNAME         reduce using rule 22 (DECIMAL_TYPE -> FLOAT .)


state 28

    (23) DECIMAL_TYPE -> DOUBLE .

    VARNAME         reduce using rule 23 (DECIMAL_TYPE -> DOUBLE .)


state 29

    (34) OPERATION -> VALUE OPERADOR . VALUE
    (8) VALUE -> . INTEGER
    (9) VALUE -> . DECIMAL

    INTEGER         shift and go to state 12
    DECIMAL         shift and go to state 20

    VALUE                          shift and go to state 37

state 30

    (29) OPERADOR -> PLUS .

    INTEGER         reduce using rule 29 (OPERADOR -> PLUS .)
    DECIMAL         reduce using rule 29 (OPERADOR -> PLUS .)


state 31

    (30) OPERADOR -> MINUS .

    INTEGER         reduce using rule 30 (OPERADOR -> MINUS .)
    DECIMAL         reduce using rule 30 (OPERADOR -> MINUS .)


state 32

    (31) OPERADOR -> TIMES .

    INTEGER         reduce using rule 31 (OPERADOR -> TIMES .)
    DECIMAL         reduce using rule 31 (OPERADOR -> TIMES .)


state 33

    (32) OPERADOR -> MODULUS .

    INTEGER         reduce using rule 32 (OPERADOR -> MODULUS .)
    DECIMAL         reduce using rule 32 (OPERADOR -> MODULUS .)


state 34

    (33) OPERADOR -> DIVIDE .

    INTEGER         reduce using rule 33 (OPERADOR -> DIVIDE .)
    DECIMAL         reduce using rule 33 (OPERADOR -> DIVIDE .)


state 35

    (24) DECLARATION -> DATA_TYPE VARNAME . EQUAL INTEGER

    EQUAL           shift and go to state 38


state 36

    (7) INCLUDE -> PP_INCLUDE HEADER_LIB .

    $end            reduce using rule 7 (INCLUDE -> PP_INCLUDE HEADER_LIB .)


state 37

    (34) OPERATION -> VALUE OPERADOR VALUE .

    $end            reduce using rule 34 (OPERATION -> VALUE OPERADOR VALUE .)


state 38

    (24) DECLARATION -> DATA_TYPE VARNAME EQUAL . INTEGER

    INTEGER         shift and go to state 39


state 39

    (24) DECLARATION -> DATA_TYPE VARNAME EQUAL INTEGER .

    $end            reduce using rule 24 (DECLARATION -> DATA_TYPE VARNAME EQUAL INTEGER .)

